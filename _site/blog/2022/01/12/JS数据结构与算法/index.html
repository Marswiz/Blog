<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="路旁有花，心中有歌，天上有星。">
  <meta name="keywords" content="Marswiz,blog,Mars,技术博客,前端,Frontend,个人博客">
  <meta name="author" content="Marswiz"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>JS：数据结构与算法 | 个人杂记:MarsWiz</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="JS：数据结构与算法" />
<meta name="author" content="Mars" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="记录一些算法 &amp; 技巧" />
<meta property="og:description" content="记录一些算法 &amp; 技巧" />
<link rel="canonical" href="http://localhost:4000/blog/2022/01/12/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" />
<meta property="og:url" content="http://localhost:4000/blog/2022/01/12/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" />
<meta property="og:site_name" content="个人杂记:MarsWiz" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-12T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"记录一些算法 &amp; 技巧","@type":"BlogPosting","url":"http://localhost:4000/blog/2022/01/12/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","headline":"JS：数据结构与算法","dateModified":"2022-01-12T00:00:00+08:00","datePublished":"2022-01-12T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2022/01/12/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},"author":{"@type":"Person","name":"Mars"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="preload" href="/assets/fonts/Didot.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Clarendon_BT.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/TodaySB-CapExtLig.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/PoiretOne-Regular.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Memphis.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Folio-Light.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="stylesheet" href="/assets/main1.css?v=1.1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="个人杂记:MarsWiz" /><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Icons -->
	<link rel="shortcut icon" href = "/assets/pics/logo_cat.jpg">
	<link rel="bookmark" href = "/assets/pics/logo_cat.jpg">
	<link rel="apple-touch-icon" href = "/assets/pics/logo_cat.jpg">

  <!--  jquery  -->
  <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js" defer></script>


    <!-- Valine 评论
    <script src='//unpkg.zhimg.com/valine/dist/Valine.min.js'></script> -->
  <!-- Vconsole -->
<!--   <script src="http://localhost:4000/assets/js/vconsole.min.js"></script>
  <script>
    // init vConsole
    var vConsole = new VConsole();
    console.log('Hello world');
  </script>
   -->
  <!-- Hammer.js 移动手势操作库 -->
  <script src="http://localhost:4000/assets/js/hammer.js" defer></script>


</head>
<body><!-- 日志页导航栏结构 -->

<nav id="navBlog">


	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id="blogLogo" src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>
		<!-- 导航按钮 -->
<!--		<div id="navItems">-->
<!--			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>-->
<!--			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>-->
<!--			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>-->
<!--			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>-->
<!--			<a href="" id="projectsBtn">Projects</a>-->
<!--		</div>-->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><div id="blogBtnSprite"></div></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><div id="tagsBtnSprite"></div></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><div id="aboutMeBtnSprite"></div></a>
			<a id="searchBtn" href="http://localhost:4000/search"><div id="searchBtnSprite"></div></a>
			<a href="http://localhost:4000/projects" id="projectsBtn"><div id="projectsBtnSprite"></div></a>
		</div>

		<!-- 移动端按钮 -->
		<div id="navItemsBtnMobile">
			<span class="fa fa-bars"></span>
		</div>
	</div>



</nav>
<!-- 日志页移动端导航栏结构 -->

<nav id="navMobile">
	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>

		<!-- 导航按钮 -->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>
			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>
			<a id="projectsBtn" href="http://localhost:4000/projects"><img src="http://localhost:4000/assets/nav/projectBlack.svg" alt="project"></a>
		</div>
		<div id="changeDayNight" class="fa fa-lightbulb-o"></div>
	</div>
</nav>
<main id="mainBox" aria-label="Content">

        <!-- 移动端页面标题 -->
        <!--   <a id="logoBoxBlog" href="/">
      <img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
    </a> -->
        <!--  -->
        <span id="pIdentifier" style="display: none;">中文缩进</span>
<span id="baseURLIdentifier" style="display: none;">http://localhost:4000</span>
<article id="postBox">

    <!-- 标题和日期 -->
    <header id="postHeader">
        <h1 id="postTitle">JS：数据结构与算法</h1>
        <p id="postInfo">
            Posted by<span id="postAuthor"> Mars </span>. Modified at
            <time id="postTime">Jan 12, 2022
            </time>
        </p>
    </header>

    <div id="postContentBox">
        <!-- 标题headerIndex导航 -->
        <div id="headerIndex"></div>

        <!-- 内容主体 -->
        <div id="postContent">
            <blockquote>
  <p>记录一些算法 &amp; 技巧</p>
</blockquote>

<h1 id="preview">Preview</h1>
<h2 id="算法的复杂度">算法的复杂度</h2>

<h3 id="基本操作">基本操作</h3>

<p>在普通的计算机上，<strong>加减乘除</strong>、<strong>访问变量</strong>（访问基本数据类型的变量）、<strong>给变量赋值</strong>等都可以看作基本操作。</p>

<p><strong>对基本操作的次数统计或是估测，可以作为评判算法用时的指标。</strong></p>

<blockquote>
  <p>不同的基本操作，其实执行用时是不同的（除法比加法用时长），这种不同在计算时间复杂度的时候因过小被忽略。</p>
</blockquote>

<h3 id="数据规模">数据规模</h3>

<p>衡量一个算法的快慢，一定要考虑数据规模的大小。</p>

<p>所谓数据规模，一般指输入的<strong>数字个数</strong>、输入中<strong>给出的图的点数与边数</strong>等等。</p>

<p>一个数据规模，一般用一个字母来表示（m、n等）。</p>

<h3 id="时间复杂度">时间复杂度</h3>

<p><strong>程序执行的用时随数据规模而增长的趋势</strong>，叫做时间复杂度。</p>

<p>时间复杂度分为<strong>最坏时间复杂度</strong>和<strong>平均时间复杂度</strong>。</p>

<blockquote>
  <p><strong>最坏时间复杂度</strong>，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。</p>

  <p><strong>平均（期望）时间复杂度</strong>，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。</p>
</blockquote>

<h2 id="算法如何高效">算法如何高效</h2>

<ul>
  <li>计算机解决问题，本质上都是<strong>穷举出所有可能结果</strong>，然后进行比较选择；</li>
  <li>计算的问题可能性越多，就从本质上决定了计算的复杂度越大；</li>
  <li>提升算法效率，一般只有以下几个途径：
    <ul>
      <li>通过人进行逻辑分析，充分<strong>避免无意义的计算步骤</strong>（剪枝）；</li>
      <li>通过充分利用已经计算的结果，避免重复计算（记忆化）；</li>
      <li>通过合并操作，减少高成本的操作次数。</li>
    </ul>
  </li>
</ul>

<h1 id="思路相关">思路相关</h1>
<h2 id="一些思考方向">一些思考方向</h2>

<ol>
  <li>查看解本身，或者与解有关的因变量，是否具有<strong>单调性</strong>。具有单调性的问题可以用<strong>二分查找</strong>求解；</li>
  <li>求解空间上连续子区间的问题，考虑<strong>滑动窗口</strong>法；</li>
  <li>自变量与因变量之间存在负相关（一增一减），考虑从两端开始相向而行的<strong>双指针</strong>法；</li>
  <li>问题明显与状态相关，可以清晰地用几个参数定义问题的状态，而且前后状态之间存在转移关系，考虑<strong>动态规划</strong>。特别地，当状态空间非常小时（大约数万），考虑用二进制进行<strong>状态压缩</strong>；</li>
  <li>对比分析每一步的几种决策，可以消除掉一些非优策略。当问题存在<strong>唯一的局部最优策略</strong>，那么整体最优结果一定由这个局部最优策略得来，可以使用<strong>贪心算法</strong>；</li>
  <li>问题可以分解为两个或多个子问题，且问题小到一定规模结果是显然可得的，考虑<strong>分治法</strong>；</li>
  <li>问题状态空间较小（例如只有&lt;= 16位的长度），可以直接进行<strong>枚举</strong>。特别地，可以用二进制数表示每一个状态，从而用二进制数代表状态，进行枚举；</li>
  <li>问题数据量有关的提示信息：
    <ol>
      <li><code>≤ 20</code>： 可以是指数级算法。如：回溯等；</li>
      <li><code>≤ 2*10^4</code>：复杂度至少为O(n2)的方法，如：动态规划等。；</li>
      <li><code>≥ 10^5</code>：复杂度至少为O(n*logn)的方法。如：二分查找、滑动窗口、贪心等。</li>
    </ol>
  </li>
</ol>

<h2 id="关注点">关注点</h2>

<ol>
  <li><strong>达成目标的条件</strong>：题目的目标是什么，什么情况下就达成了目标，达成目标的条件是否可以等价转化；</li>
  <li><strong>不变量</strong>：如果在变化过程中存在恒定不变的变量、点或序列等，可能是求解的关键；</li>
  <li><strong>转移关系</strong>：随着变量的改变，前后二者是否存在可以互相转移的关系；</li>
  <li><strong>多个约束条件的耦合性</strong>：如果同时存在多个<strong>约束条件</strong>，考察它们之间是否存在<strong>耦合性</strong>，如果无耦合可以将它们分开。例如：左右两侧分别进行一次遍历；</li>
  <li><strong>可操作的方式</strong>：如果题目给你一定的权限进行某种操作，尽可能<strong>枚举所有操作</strong>，观察它们对结果的影响；</li>
  <li><strong>选择唯一的情况</strong>：当可以进行多种选择时，关注选择情况受限（或只能进行唯一的选择）的情况，它可能是动态规划等方式解决问题的起点；</li>
  <li><strong>映射不变性</strong>：给定的元素编号、索引等，在经过一次变换后，如果仍保持一一映射关系，且某些基本性质并未发生改变，可以考虑将利用映射关系，分解问题为子问题；</li>
  <li><strong>覆盖</strong>：状态之间是否存在覆盖，从而可以去掉一些情况；</li>
  <li><strong>操作是否有效:</strong> 每种操作，需要观察其后果，是否等价于其他操作，或者是无效操作；</li>
</ol>

<h2 id="注意事项">注意事项</h2>

<ol>
  <li>正确可行的思路是核心。在没有形成完整的思路之前，不要开始写程序；</li>
  <li>读题。读题。读题。（充分理解题目要求）；</li>
  <li>充分构造边界条件下的测试用例，全通过后再提交。</li>
</ol>

<h2 id="雷点坑点">雷点&amp;坑点</h2>

<ol>
  <li>关注是否存在<strong>负数</strong>节点，出现负元素，很多算法都有所限制，尤其和最优化相关；</li>
  <li>二分查找的<strong>数据范围</strong>。一般不要使用<code>((l+r) &gt;&gt; 1)</code>这种找中点的方法，容易溢出。要使用<code>Math.floor((l+r)/2)</code>；</li>
</ol>

<h1 id="栈队列优先队列和哈希表">栈、队列（优先队列）和哈希表</h1>
<h2 id="栈">栈</h2>

<p>栈是只能在一端进出，有”先进后出（FIFO）”特性的数据结构。</p>

<h3 id="单调栈">★单调栈</h3>

<blockquote>
  <p>单调栈：栈内的元素<strong>索引值单调递增</strong>，且<strong>元素值</strong>从底向顶也<strong>单调递增</strong>或<strong>单调递减</strong>。</p>

  <p>单调栈同普通栈一样，元素只能在栈顶进出。</p>
</blockquote>

<p>单调栈的目的是，<strong>随着原序列的遍历，维护一个局部最优的子序列</strong>。属于贪心算法的工具。</p>

<p>单调栈可以用来解决：</p>

<ol>
  <li><strong>查找数组中每个元素下一个大于（或小于）自身的值</strong>；</li>
  <li>按索引顺序，查找<strong>具有最大跨度的上升(下降)元素对</strong>；</li>
  <li>△查找最小或最大子序列。</li>
</ol>

<p>有关用法2的详细解释，见<a href="https://www.marswiz.com/blog/2022/02/15/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/#%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1">最大宽度坡题解</a>。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/">找出最具竞争力的子序列</a></p>

  <p><a href="https://leetcode-cn.com/problems/remove-k-digits/">移掉K位数字</a></p>

  <p><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></p>

  <p>★<a href="https://leetcode-cn.com/problems/maximum-width-ramp/">962. 最大宽度坡</a></p>

  <p><a href="https://leetcode-cn.com/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></p>
</blockquote>

<h2 id="队列">队列</h2>

<p>队列是”先进先出（FIFO）”的数据结构。</p>

<h3 id="单调队列">单调队列</h3>

<blockquote>
  <p>单调队列：队列中元素的索引值单调递增，且队列中的元素值单调也递增（或递减）。</p>

  <p>单调队列与普通队列不同，一般为双端队列。元素可以在两侧出队，而只能在队尾入队。</p>

  <p>Out: <code>Head &lt;- [a,b,c,d] -&gt; Tail</code>;</p>

  <p>In: <code>[a,b,c,d] &lt;- Tail</code></p>
</blockquote>

<p>单调队列在滑动窗口中应用，可以<strong>获取窗口内的最大、最小值</strong>。操作如下：</p>

<ol>
  <li>设置单调队列queue，初始值为空；（假设我们要保存的是窗口的最大值，queue为单调递减队列）</li>
  <li>假设窗口左指针为left，右指针为right。当窗口扩大时，right向右移动，此时判断新加入窗口的元素<code>arr[right+1]</code>与queue队尾的元素大小关系：
    <ul>
      <li>如果<code>arr[right+1] &gt; queue[queue.length-1]</code>，说明有新的最大值加入，这里因为queue中的元素都比新加入的元素更靠前，因此在left到达right+1位置之前<code>queue[queue.length-1]</code>绝不可能再成为最大值，因此可以将它在队尾删除；</li>
      <li>同理，删除后还需要对下一个队尾值进行比较删除操作，直到队空或队尾元素值<strong>大于等于</strong>新值，将新值从队尾加入队列；（等于的情况需要保留，因为之前加入的值仍然是最大值。）</li>
      <li>这样就保证了单调队列的两个特性：索引和值都单调递增。</li>
    </ul>
  </li>
  <li>当窗口需要缩小，left向右移动，事项如下：
    <ul>
      <li>在窗口中不存在的元素，需要从队列中删除；</li>
      <li>因为left &lt;= right，当前要删除的left元素最先加入队列，因此它要么在队列的最前面，要么已经被后来的最大值淘汰，被从队尾删除掉；</li>
      <li>此时只需判断队首元素是否是left对应的元素，如果是则将它从队首出队，如果不是则不用做任何操作。</li>
    </ul>
  </li>
  <li>每次窗口移动，队首的元素就是当前窗口内的最大值。</li>
</ol>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">窗口中的最大值</a></p>

  <p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">绝对差不超过限制的最长连续子数组</a></p>
</blockquote>

<h2 id="哈希表">哈希表</h2>

<p>适用于：<strong>计数类问题。哈希表可以快速判断一个值是否出现在集合中，而避免了每次都要遍历查找</strong>。</p>

<p>缺点是空间复杂度高，是以空间换时间的方法。</p>

<p>哈希结构：<strong>数组、对象、Set、Map</strong></p>

<h3 id="哈希表计数去重">哈希表计数去重</h3>

<blockquote>
  <p><strong>使用哈希表计数两数组合，如何能不重复？</strong></p>

  <p><em><code>给出一个数组arr，求数组中子序列 [a,b] 加和 a+b=target 的组合数。</code></em></p>

  <p>使用暴力解法时间复杂度为<code>O(n^2)</code>，可以使用两个嵌套for循环，通过索引来实现无重复计数。</p>

  <p>使用一个哈希表map，可以实现<code>O(n)</code>复杂度的算法。但是如果采用<strong>先将数组元素添加到map统计数目，后遍历map计算组合数</strong>的方式，计算的组合数将包含重复情况：</p>

  <p><strong>例如:</strong>  map = {1: 3, 2: 3} ，target = 3，遍历map时，会得到<code>[1,2]</code>+<code>[2,1]</code> 共计18种组合，实际上只有9种。</p>

  <p><strong>可以采用边统计，边计数的方式，避免这种重复计数的情形：</strong></p>

  <ul>
    <li><strong>每次将元素i放入map前，先计算 map 中 target-i 的数目num，将其加入计数结果count；</strong></li>
    <li><strong>将元素放入map，它对应在map中的数目+1.</strong></li>
  </ul>

  <p>这样做可以避免重复计数（<code>[a,b]</code>和<code>[b,a]</code>）的原因是：</p>

  <p>如果a和b是一对待计入组合，那么按照这种依次加入的方式，他们加入map一定有先后顺序。我们只在二者中后加入map的一方加入map的时候计数。因为所有元素最终一定都被添加到map，他们之间两两存在先后顺序，也就是说如果存在任意组合需要被计入，只会在组合元素最后一次被添加的时候计数，也就是只会计数一次。</p>
</blockquote>

<h2 id="st表">ST表</h2>
<h3 id="st表的功能与复杂度">ST表的功能与复杂度</h3>

<p>ST表（Sparse Table，稀疏表），是一种基于倍增思想的数据结构。</p>

<p>ST表经常用于解决<strong>高效查询区间最值问题（RMQ）</strong>。</p>

<p>ST表可以在<code>O(n*log_n)</code>时间复杂度进行建立，然后在<code>O(1)</code>时间复杂度内实现对<code>[l,r]</code>区间内最值的查询。</p>

<blockquote>
  <p>实际上，ST表可以解决的问题叫做<strong>可重复贡献性问题</strong>。</p>

  <p>任何一个操作<code>opt</code>，如果<code>x opt x === x</code>，则<code>opt</code>叫做可重复贡献操作，也就是对同一参数多次执行，不影响计算结果。</p>
</blockquote>

<h3 id="st表的原理与结构">ST表的原理与结构</h3>

<p>ST表基于以下原理实现：</p>

<ol>
  <li>任何一个区间<code>[l,r]</code>，都能找到两个长度<code>len = 2^i （2^i ∈ [1, r-l+1]）</code>的子区间<code>[l,a]</code>和<code>[b,r]</code> (a,b在<code>[l,r]</code>区间内)；</li>
  <li>我们可以以<code>2的幂</code>为区间长度，预先计算出各个区间的最值；</li>
  <li><code>[l,r]</code>区间内的整体最值结果，与分别对子区间<code>[l,a]</code>和<code>[b,r]</code>求最值，然后再联合求最值的结果相同。</li>
</ol>

<p><img src="/assets/posts/49.png" alt="sttable" /></p>

<p>ST表的处理过程：</p>

<ol>
  <li><strong>预处理，建立ST表</strong>：
    <ol>
      <li>设<code>d[i][j]</code>为从<code>i</code>开始的，长度为<code>2^j</code>的闭区间<code>[i, i+2^j-1]</code>的最值结果；</li>
      <li>使用动态规划，计算出原区间<code>[l,r]</code>的全部<code>d[i][j]</code>值；</li>
      <li>对于区间<code>[l,r]</code>，i的取值范围为<code>[1,r]</code>，j的取值范围为<code>[0, log(r-l+1)]</code>。</li>
    </ol>
  </li>
  <li><strong>查询<code>[l,r]</code>区间的最值：</strong>
    <ol>
      <li>将<code>[l,r]</code>区间分为两个子区间<code>[l,a]</code>和<code>[b,r]</code>。为了让子区间最大程度地重叠，子区间长度尽可能靠近<code>r-l+1</code>，因此<code>len = 2^j</code>的指数<code>j</code>选取为<code>j = ⌊ log(r-l+1) ⌋</code>;</li>
      <li>获取<code>d[l][j]</code>和<code>d[r-2^j+1][j]</code>的值，取二者的最值即为结果。</li>
    </ol>
  </li>
</ol>

<p><img src="/assets/posts/50.png" alt="sttable" /></p>

<h3 id="st表的实现">ST表的实现</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ST</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">JMAX</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">JMAX</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">i</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">d</span><span class="p">[</span><span class="nx">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">JMAX</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">j</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// [i, i+2^j-1] --&gt; [i, i+2^(j-1)-1] + [i+2^(j-1), i+2^j-1]</span>
                <span class="c1">// d[i][j] --&gt; d[i][j-1] + d[i+2^(j-1)][j-1];</span>
                <span class="c1">// 动态规划：[i,j]用到j-1列的数据，因此计算顺序是先列后行。</span>
                <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">// 这里执行对应的可重复贡献逻辑: max, min, gcd...</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">query</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">[</span><span class="nx">r</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="堆优先队列">堆（优先队列）</h2>

<p><a href="/blog/2021/06/17/使用数组构建堆结构的过程和原理/">堆相关</a></p>

<h1 id="数组">数组</h1>

<h2 id="差分数组">差分数组</h2>

<h3 id="定义和适用情况">定义和适用情况</h3>

<p><strong>差分数组</strong>：对于一个源数组arr，差分数组<code>diff[i]</code>定义如下：</p>

<ol>
  <li><code>diff[0] = 0;</code></li>
  <li><code>diff[i] = arr[i] - arr[i-1]; (i &gt; 0)</code></li>
</ol>

<p>差分数组主要用于<strong>对原数组子区间内元素，进行统一增减操作</strong>的情况，将区间内的统一变化，转化为两个端点的变化。</p>

<p>可以将数组操作转化为哈希表记录端点变化的操作，降低复杂度。</p>

<h3 id="差分数组的性质">差分数组的性质</h3>

<blockquote>
  <p><a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组是什么</a></p>
</blockquote>

<p>对于一个数组arr，计算它的差分数组diff，如果它的子区间<code>[a,b]</code>进行统一的增减n的操作，diff数组的变化如下：</p>

<ul>
  <li>统一增大n：<code>diff[a]增大n，diff[b+1]减小n</code>，其他不变；</li>
  <li>统一减小n: <code>diff[a]减小n，diff[b+1]增大n</code>，其他不变；</li>
</ul>

<blockquote>
  <p>也就是说，区间<code>[a,b]</code>同时增减操作，只影响差分数组的区间<strong>头位置a</strong>和<strong>尾位置+1位置b+1</strong>，diff[a]与变化方向相同，diff[b+1]与变化方向相反，变化值绝对值相同都为n。</p>
</blockquote>

<p>从另一个角度考虑，在对区间<code>[a,b]</code>进行了统一增加n操作后，<strong>diff的<code>[a,b]</code>区间前缀和统一增加了n，而其他位置前缀和不变。</strong></p>

<blockquote>
  <p>因为+n发生在<code>diff[a]</code>位置，-n发生在<code>diff[b+1]</code>位置，而中间的元素不变。</p>

  <p>所以<code>[a,b]</code>区间内前缀和都统一增加了n，而到b+1位置恢复，b+1之后的前缀和没有变化。</p>
</blockquote>

<h3 id="差分数组的好处">差分数组的好处</h3>

<p>差分数组将一个区间内的操作，转化为在两个端点的操作，省去了遍历整个区间的过程，减少了时间复杂度。</p>

<p>差分数组应用实例：</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893.区间是否被全覆盖</a></p>

  <p><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">★ 1674.使数组互补的最少操作次数</a></p>
</blockquote>

<h2 id="前缀和">前缀和</h2>

<p>对于一个数组arr的索引i，前缀和也就是求区间<code>[0,i]</code>中数组所有元素的和。</p>

<p>对于一个<strong>子数组（连续）的所有元素之和，等于它首尾位置前缀和之差</strong>。这有时可以用于降低复杂度。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为K的子数组</a></p>
</blockquote>

<h2 id="子数组">子数组</h2>

<blockquote>
  <p>子数组是一个数组<code>arr</code>中索引连续的元素组成的数组。</p>
</blockquote>

<p>子树组类题目，一般情况是需要<strong>统计符合某种规则的子数组数目</strong>。</p>

<p>一个长度为<code>n</code>的数组，它的全部子数组数目为<code>n *（n+1）/ 2</code>，为<code>n^2</code>量级。因此当数据量较大（一般大于30000）时，暴力法无效。</p>

<p>当暴力法无效时，就需要一些特殊的判断技巧，以降低复杂度。这时可以观察题目要求规则的特点，枚举子数组中比较有特点的某个元素位置，从而寻找子数组数目。</p>

<p>一般有以下两种情况：</p>

<ol>
  <li><strong>枚举子数组左、右边界</strong>：比如统计以某个字符作为结尾的子数组数目，我们枚举找到这个字符的位置，以它为结尾的子数组数目，等于它前面元素的数目<code>n+1</code>；</li>
  <li><strong>枚举子数组中某个特殊元素位置，可以依此将子数组分为左右两部分</strong>：比如约定了子数组的最大值、最小值区间范围时，我们直接枚举以某个元素为最大、最小值的子区间数目。</li>
</ol>

<p><img src="/assets/posts/54.png" alt="子数组" /></p>

<h4 id="最值在某一区间范围lr的子数组个数">最值在某一区间范围<code>[l,r]</code>的子数组个数</h4>

<p>现在给定我们一个区间<code>[l,r]</code>，让我们求出最大（小）值落在这个区间的，<code>arr</code>的子数组的个数。</p>

<p>基于上节思路，现在再多考虑一些细节：</p>

<ol>
  <li><strong>枚举哪个位置？</strong>如果我们选择<strong>从左到右</strong>遍历原数组，因为我们已遍历的区间在当前位置<code>i</code>的左侧，要实现<code>O(n)</code>的算法，只能认为我们当前枚举的位置是区间的<strong>右边界</strong>；</li>
  <li>**如何判断符合要求子区间的数目，以及取舍？
    <ol>
      <li><strong>要实现<code>O(n)</code>的算法，我们每次只能考虑当前正在遍历的这个元素<code>arr[i]</code>，利用它的值来判断以<code>arr[i]</code>为右边界的一系列区间的</strong>保留<strong>与</strong>舍弃**，因此要设定一个对当前元素的判定条件；</li>
      <li>已经遍历的部分，我们记录符合条件的元素出现的长度<code>len</code>，以当前位置<code>arr[i]</code>为结尾的符合要求子数组个数，就等于<code>len+1</code>。（见上节图）；</li>
      <li>对于取区间最大值的问题，符合要求的元素为<code>arr[i] &lt;= MAX</code>，我们必须保证计入<code>len</code>的元素都满足这一条件，因此我们将原区间<code>[l,r]</code>划分为<code>[~,l-1]</code>和<code>[~,r]</code>两个向左的区间差；</li>
      <li>对于取区间最小值的问题，符合要求的元素为<code>arr[i] &gt;= MIN</code>，我们必须保证计入<code>len</code>的元素都满足这一条件，因此我们将原区间<code>[l,r]</code>划分为<code>[l,~]</code>和<code>[r+1,~]</code>两个向左的区间差；</li>
    </ol>
  </li>
</ol>

<p><img src="/assets/posts/55.png" alt="区间划分" /></p>

<p>代码实现：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 求子数组最小值满足[l,r]的个数：</span>
<span class="kd">function</span> <span class="nx">minValueBetweenCnt</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span> <span class="p">,</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// [1,3,2,4,5,10,6,3,1,5,4,9,12,1]</span>
    <span class="c1">// [3,6]</span>
    <span class="c1">// min &gt;= 3 &amp;&amp; min &lt;= 6</span>
    <span class="c1">// (min &gt;= 3) - (min &gt;= 7) 区间取最小值，划分为两个向右的区间差</span>
    <span class="kd">function</span> <span class="nx">cntMinValueLargerThan</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 枚举子数组右边界位置</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">e</span><span class="p">)</span> <span class="nx">cur</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 当满足要求，连续出现的符合要求元素数 +1</span>
            <span class="k">else</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// 不满足要求，连续出现的符合要求元素数 归0</span>
            <span class="nx">res</span> <span class="o">+=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cntMinValueLargerThan</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">-</span> <span class="nx">cntMinValueLargerThan</span><span class="p">(</span><span class="nx">r</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 求子数组最大值满足[l,r]的个数：(原理相同)</span>
<span class="kd">function</span> <span class="nx">maxValueBetween</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// [l,r]</span>
    <span class="c1">// [~,r] - [~,l-1]</span>
    <span class="kd">function</span> <span class="nx">cntMaxValueSmallerThan</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">e</span><span class="p">)</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span> <span class="nx">cur</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">res</span> <span class="o">+=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cntMaxValueSmallerThan</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">-</span> <span class="nx">cntMaxValueSmallerThan</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="动态前缀和树状数组">动态前缀和：树状数组</h3>

<h4 id="树状数组binary-indexed-array">树状数组（Binary Indexed Array）</h4>

<p><strong>树状数组</strong>（Binary Indexed Array，BIT）的功能，是求解某一数组的<strong>动态前缀和</strong>。</p>

<p>它巧妙地利用了数组索引的二进制表示信息，实现了在<code>O(log_n)</code>时间复杂度，实现对数组<code>arr</code>的任意位置前缀和的<strong>修改</strong>和<strong>查询</strong>操作。</p>

<p>同样，区间和的查询，相当于两次前缀和的查询，因此也可以在<code>O(log_n)</code>时间复杂度实现区间和的查询操作。</p>

<p>树状数组建立的过程，复杂度是<code>O(n * log_n)</code>。</p>

<blockquote>
  <p><strong>动态前缀和有什么用？</strong></p>

  <p>动态前缀和可以随着原数组的遍历，对前缀数组进行动态修改，从而更快找到我们想要的信息。</p>

  <p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></p>

  <p><a href="https://leetcode-cn.com/problems/count-good-triplets-in-an-array/">2179. 统计数组中好三元组数目</a></p>

</blockquote>

<h4 id="树状数组的结构">树状数组的结构</h4>

<ol>
  <li>树状数组的索引从<code>1</code>开始；</li>
  <li>树状数组的每一个位置，都保存着原数组<code>arr</code>某一区间的加和；</li>
  <li><code>bit[i]</code>具体保存的是哪一个区间的信息，与索引<code>i</code>有关；</li>
  <li>从索引<code>i</code>二进制表示最末位开始，一直向前直到找到第一个<code>1</code>位，区间所表示的二进制数<code>len = lowbit(i)</code>，就是<code>bit[i]</code>所表示的向前区间长度（包含当前位置）;</li>
  <li>某一位置<code>i</code>所表示区间的前一个区间元素位置：<code>i - lowbit(i)</code>；</li>
  <li>某一位置<code>i</code>所表示区间的上层覆盖区间的元素位置：<code>i + lowbit(i)</code>。</li>
</ol>

<p><img src="/assets/posts/48.png" alt="树状数组" /></p>

<h4 id="树状数组的功能">树状数组的功能</h4>

<ol>
  <li><code>[1, i]</code>区间前缀和的查询<code>query(i)</code>；</li>
  <li>原数组<code>i</code>位置数据的更新<code>update(i, diff)</code>；（diff为更新的增量）</li>
  <li><code>lowbit(i)</code>，计算<code>i</code>位置的区间长度<code>len</code>；</li>
</ol>

<p><img src="/assets/posts/47.png" alt="lowbit的实现" /></p>

<h4 id="树状数组的实现">树状数组的实现</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mars 2022.02</span>
<span class="kd">class</span> <span class="nx">BIT</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[]){</span>
        <span class="c1">// arr[i] -&gt; bit[i+1]</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bit</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">i</span><span class="p">,</span><span class="nx">idx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="nx">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="nx">lowBit</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">update</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">diff</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// update arr[i] with delta &lt;diff&gt;.</span>
        <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">bit</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 不断向上寻找覆盖区间，并更新；</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">bit</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">diff</span><span class="p">;</span>
            <span class="nx">c</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lowBit</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">query</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// query prefix sum of [0, i]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">bit</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s2">`index exceed the limit.`</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 不断向前寻找区间，并加和；</span>
            <span class="nx">r</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">bit</span><span class="p">[</span><span class="nx">c</span><span class="p">];</span>
            <span class="nx">c</span> <span class="o">-=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lowBit</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="线段树">线段树</h3>

<p>线段树将一个数组的<strong>区间计算信息</strong>，预先计算并保存在一个树状结构中，降低后续数组区间查询和更新数据的复杂度。</p>

<p>线段树可以在<code>O(n*log_n)</code>时间复杂度内建立，然后在<code>O(log_n)</code>的时间复杂度内实现<strong>单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）</strong>等操作。</p>

<p>线段树适用于<strong>需要频繁对数组进行区间信息查询，且频繁对数组进行更新</strong>的情况。</p>

<h4 id="线段树的结构">线段树的结构</h4>

<ol>
  <li>线段树是二叉树形式的数据结构，可以用<strong>Node</strong>或<strong>数组</strong>形式表示；</li>
  <li>线段树的每一个节点，代表原数组一个区间的信息。例如：节点A可以表示<code>[0,3]</code>区间内，原数组的元素加和结果；</li>
  <li>线段树节点的子节点，记录父节点区间，从中间点拆分而成的子区间信息，中间点属于左子节点还是右子节点均可，可以自行约定。
    <blockquote>
      <p>例如：节点A表示<code>[0,3]</code>区间，我们约定取中间点为<code>m = Math.floor((l+r)/2)</code>，且左子节点保存<code>[left, m]</code>的区间，右子节点保存<code>[m+1, right]</code>区间，那么A的左子节点保存<code>[0,1]</code>区间信息，右子节点保存<code>[2,3]</code>区间信息。</p>
    </blockquote>
  </li>
  <li>线段树的叶子节点，就是<strong>区间长度为1</strong>的结果，也就是保存了原数组的各个元素值。</li>
</ol>

<p><img src="/assets/posts/segmentTree.png" alt="SegmentTree" /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">constructor</span><span class="p">(</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">build</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="线段树的生成-build">线段树的生成 build</h4>

<p>使用递归的方式生成。</p>

<ol>
  <li>线段树需要的数组空间不好计算，根据渐进公式可以设其长度为<code>4 * n</code>(n为原数组长度);</li>
  <li>与建堆一样，<code>i</code>的左子节点索引为<code>2i+1</code>，右子节点为<code>2i+2</code>；</li>
  <li>递归函数需要记录的参数：当前树节点的索引<code>idx</code>，当前节点代表的区间左边界<code>left</code>，右边界<code>right</code>;</li>
  <li>递归出口条件：
    <ol>
      <li><code>left === right</code>: 叶子节点，返回<code>arr[left]</code> ；</li>
      <li><code>left &gt; right</code>: 空节点，返回null。</li>
    </ol>
  </li>
  <li>函数体内，将区间按约定的中点分隔方式，分隔并递归调用即可。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">build</span><span class="p">(</span><span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">];</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">leftIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">rightIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="c1">// [start, m] [m+1, end]</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">build</span><span class="p">(</span><span class="nx">leftIdx</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">m</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">build</span><span class="p">(</span><span class="nx">rightIdx</span><span class="p">,</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">leftIdx</span><span class="p">]</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">rightIdx</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="线段树的更新-update">线段树的更新 update</h4>

<p>更新<code>arr[i] = val</code>，只需要对线段树的<code>arr[i]</code>所处的叶子节点，及其各祖先节点进行更新即可。其他节点不受影响。</p>

<ol>
  <li>判断更新前后的值是否相同，相同则无需更新，直接结束；</li>
  <li>计算要更新的差值，<code>delta = val - arr[i]</code>；</li>
  <li>递归遍历线段树，判断更新的位置<code>i</code>是否位于<code>[left, right]</code>区间内，是则在当前节点的值上加上差值<code>delta</code>，并对子区间递归调用。不在区间内则直接返回；</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">update</span><span class="p">(</span><span class="nx">arrIdx</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">arrIdx</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">delta</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">arrIdx</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="nx">arrIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span> <span class="c1">// refresh arr self</span>
        <span class="c1">// refresh tree</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_treeUpdate</span><span class="p">(</span><span class="nx">arrIdx</span><span class="p">,</span> <span class="nx">delta</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">_treeUpdate</span><span class="p">(</span><span class="nx">arrIdx</span><span class="p">,</span> <span class="nx">delta</span><span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arrIdx</span> <span class="o">&lt;</span> <span class="nx">start</span> <span class="o">||</span> <span class="nx">arrIdx</span> <span class="o">&gt;</span> <span class="nx">end</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">delta</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">delta</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">leftIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">rightIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_treeUpdate</span><span class="p">(</span><span class="nx">arrIdx</span><span class="p">,</span> <span class="nx">delta</span><span class="p">,</span> <span class="nx">leftIdx</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">m</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_treeUpdate</span><span class="p">(</span><span class="nx">arrIdx</span><span class="p">,</span> <span class="nx">delta</span><span class="p">,</span> <span class="nx">rightIdx</span><span class="p">,</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="线段树的查询-query">线段树的查询 query</h4>

<p>对原数组某个子区间<code>[l,r]</code>内的结果进行查询：</p>

<ol>
  <li>分治思想，递归将原数组拆分，直到区间两端节点与线段树某一节点的两个端点相同，将线段树中结果加和计入结果中；</li>
  <li>返回加和结果。</li>
</ol>

<p>注意：这里在递归对区间进行拆分的时候，需要按照线段树节点区间的中点<code>m</code>位置来分情况讨论：</p>

<ol>
  <li>当<code>m</code>位于查询区间左侧，只需要对右子节点进行递归查询，且区间不用分割；</li>
  <li>当<code>m</code>位于查询区间右侧，只需要对左子节点进行递归查询，且区间不用分割；</li>
  <li>当<code>m</code>位于查询区间内部，需要将区间分割成<code>[l, m]</code>和<code>[m+1, r]</code>，对左右子节点分别进行递归查询、求和。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">query</span><span class="p">(</span><span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">&gt;</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s2">`Start must be smaller than or equal to End.`</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_query</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">_query</span><span class="p">(</span><span class="nx">qStart</span><span class="p">,</span> <span class="nx">qEnd</span><span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">qStart</span> <span class="o">===</span> <span class="nx">start</span> <span class="o">&amp;&amp;</span> <span class="nx">qEnd</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tree</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
            <span class="k">return</span> <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">leftIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">rightIdx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// [start, m] [m+1, end]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">&gt;=</span> <span class="nx">qEnd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_query</span><span class="p">(</span><span class="nx">qStart</span><span class="p">,</span> <span class="nx">qEnd</span><span class="p">,</span> <span class="nx">leftIdx</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">qStart</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_query</span><span class="p">(</span><span class="nx">qStart</span><span class="p">,</span> <span class="nx">qEnd</span><span class="p">,</span> <span class="nx">rightIdx</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_query</span><span class="p">(</span><span class="nx">qStart</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">leftIdx</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_query</span><span class="p">(</span><span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">qEnd</span><span class="p">,</span> <span class="nx">rightIdx</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="哈希数组">哈希数组</h3>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/snapshot-array/">1146. 快照数组</a></p>
</blockquote>

<p>哈希数组，数组的每一个元素为一个哈希表，适用于需要保存数组元素各个变化状态的情况。</p>

<p>数组元素<code>arr[i]</code>每次变化，将变化存储在<code>i</code>对应位置的哈希表中，需要时从哈希表中取出对应状态的值即可。这样没有变化的元素不会被额外存储，造成空间浪费。</p>

<h1 id="树二叉树bsttrie">树：二叉树、BST、Trie</h1>
<h2 id="二叉树-binary-tree">二叉树 Binary Tree</h2>
<h3 id="二叉树的特点">二叉树的特点</h3>

<p>二叉树是一种特殊的图，可以将二叉树看成有向图：</p>

<ul>
  <li>除了根节点外，它的每个节点<strong>入度都是1</strong>；</li>
  <li>除了叶子节点外，它的每个节点<strong>出度都为2</strong>；</li>
  <li>全部节点的<strong>入度加和，等于出度加和</strong>。</li>
</ul>

<h3 id="二叉树的前中后序遍历">二叉树的前、中、后序遍历</h3>

<p><strong>二叉树前中后序遍历的迭代的统一写法思路：</strong></p>

<ul>
  <li>使用一个栈stk来保存遍历的路径，使用Res数组记录结果；</li>
  <li>因为栈的入栈与出栈顺序相反，所以入栈顺序需要与前、中、后序遍历的顺序相反（<strong>前序：</strong> 中→左→右，<strong>入栈：</strong> 右→左→中）；</li>
  <li>只有在中间元素出栈的时候才记录结果到res数组；</li>
  <li>在中间元素后面添加一个null元素，作为它出现在中间位且没被res数组记录的标志，一旦在出栈过程中出现null，说明此时应该向res添加记录下一个元素；</li>
  <li>直到栈stk为空，结束迭代。</li>
</ul>

<p>例如：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 后序遍历：</span>

<span class="c1">// 遍历：左右中</span>
<span class="c1">// 入栈：中右左</span>
<span class="kd">function</span> <span class="nx">postOrderIterate</span><span class="p">(</span><span class="nx">root</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">stk</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">cur</span> <span class="o">===</span> <span class="kc">null</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">stk</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">stk</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// 中 （记录标志为null）</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span> <span class="c1">// 右</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>   <span class="c1">// 左</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="二叉树的序列化与反序列化">二叉树的序列化与反序列化</h3>

<h4 id="什么是序列化">什么是序列化</h4>

<blockquote>
  <p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。</p>
</blockquote>

<p>通俗地讲，序列化就是将一种数据结构，<strong>转化为字符串等不同环境通用的中间格式</strong>的过程。需要注意的是，序列化后的结果，在另一个执行环境中进行复原后（反序列化），其<strong>复原结果必须与原数据一致，没有歧义</strong>。</p>

<h4 id="二叉树该如何序列化">二叉树该如何序列化</h4>

<ul>
  <li>如果树中<strong>不存在重复的元素</strong>，那么知道了二叉树的<strong>三种遍历结果中的任意两种</strong>，即可还原出原有的树结构。</li>
  <li>如果<strong>存在重复元素</strong>，则需要<strong>对二叉树的空节点也进行输出，用一个特殊符号表示</strong>（将二叉树转化为扩充二叉树），然后进行<strong>先序或后序</strong>遍历（中序无法确定根节点位置，故不行）。</li>
</ul>

<blockquote>
  <p>扩充二叉树的先序、后序遍历结果，与二叉树的节点是一一对应的，因此恢复的结果也是唯一的。</p>
</blockquote>

<h4 id="二叉树的反序列化">二叉树的反序列化</h4>

<p>如何对含空节点标记的二叉树的先序遍历序列化结果，进行反序列化（复原）？</p>

<p>以<code>'1234###5###'</code>为例：</p>

<ol>
  <li>先序遍历结果以<code>中-左-右</code>顺序出现，所以最左侧的值一定是当前根节点的值；</li>
  <li>先序遍历会沿着一条路径一直向左探索，直到遇见叶子节点；</li>
  <li>我们用一个栈<code>stk</code>保存路径，每次从序列拿到新的节点值<code>val</code>，我们根据<code>val</code>的值新建一个节点<code>Node</code>（可能是空节点null）：
    <ol>
      <li>如果栈顶节点<code>top</code>的左子节点为空，则将<code>val</code>填充到<code>top</code>的左子节点；</li>
      <li>如果栈顶节点<code>top</code>的左子节点不为空，则将<code>val</code>填充到<code>top</code>的右子节点；</li>
    </ol>
  </li>
  <li>如果当前值<code>val</code>不是代表空节点的占位符<code>#</code>，则将新插入的节点入栈，记录下来；</li>
  <li>循环判断栈顶元素的左右子节点是否都被填充过，如果是，则对栈顶元素进行出栈，以保证栈顶是下一个待填充的节点；</li>
  <li>最后返回根节点即可。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">_buildFromPreorderSerialzation</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Mars 2022.02</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">str</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="o">+</span><span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">stk</span> <span class="o">=</span> <span class="p">[</span><span class="nx">res</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="o">+</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">stk</span><span class="p">[</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">left</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stk</span><span class="p">[</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="k">else</span> <span class="nx">stk</span><span class="p">[</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">[</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">right</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stk</span><span class="p">[</span><span class="nx">stk</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">left</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">$</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="字典树-trie">字典树 Trie</h2>

<p>字典树由字符串生成，形式是嵌套的哈希表形成的树结构。</p>

<p>字典树以输入字符串的每位字母为键名，</p>

<p>字典树可以用于<strong>文本推断、自动填充</strong>等场景。</p>

<p><strong>时间复杂度：</strong></p>

<ul>
  <li>构建、插入： O(n)</li>
  <li>查询： O(n)</li>
</ul>

<p><strong>空间复杂度：</strong></p>

<ul>
  <li>构建、插入： O(n)</li>
  <li>查询： O(1)</li>
</ul>

<h3 id="构建字典树前缀后缀">构建字典树：前缀、后缀</h3>

<p><img src="/assets/posts/trie.svg" alt="Trie" /></p>

<p>构建前缀、后缀字典树Trie的步骤：</p>

<ol>
  <li><strong>初始化：</strong>设置根节点为一个空哈希表(Map或空对象)，也可以在内部设置各种结尾的标志符；</li>
  <li><strong>插入操作：</strong>从插入字符串的0位置（前缀）或末尾位置（后缀）开始，向后（前）遍历，设置初始哈希表cur为根节点，对于每一位的字符letter，执行如下操作：
    <ul>
      <li>① 在当前哈希表中查找letter键名，如果不存在，则在cur中为letter创建一个新哈希表；</li>
      <li>② 将cur指向letter对应的哈希表，在letter哈希表设置对应的结束标志为true（如果构建前缀树，每步都设置前缀结束标志为true，最后词尾设置词汇结束标志true）；</li>
      <li>③ 继续遍历，直到字符串尽头，完成插入；</li>
    </ul>
  </li>
  <li><strong>查询操作：</strong>从插入字符串的0位置（前缀）或末尾位置（后缀）开始，向后（前）遍历，设置初始哈希表cur为根节点，对于被查询字符串query每一位的字符letter，执行如下操作：
    <ul>
      <li>① 在当前哈希表中查找letter键名，如果不存在，则说明没有此查询字符串，返回false结束；</li>
      <li>② 将cur指向letter对应的哈希表，继续查询；</li>
      <li>③ query全部查询完毕后，判断此时cur中各结束标志是否为true（比如查询前缀query，那么此时前缀结束标志应该是True），如果为true则返回ture，否则返回false。</li>
    </ul>
  </li>
</ol>

<h1 id="并查集">并查集</h1>
<h2 id="定义">定义</h2>
<p>并查集是一种抽象数据类型，它操作一组互不相交的集合，可进行高效<strong>集合合并</strong>和<strong>查询两个元素是否在同一集合</strong>的操作。</p>

<p>并查集解决的是<strong>图的动态连通性</strong>问题。即在动态过程中，判断一个图中存在几个连通分量。</p>

<h2 id="应用">应用</h2>

<ol>
  <li>判断一个<strong>图中连通分量的个数</strong>；</li>
</ol>

<h2 id="基本思路">基本思路</h2>
<ol>
  <li>一个集合用一个代表元素来表示，称为<strong>代表元</strong>。判断两个集合是否相同，被简化为判断两个集合的代表元是否相同；</li>
  <li>一个集合被组织成一个树形结构，代表元是这个树的根元素；</li>
  <li>集合中的每个元素<code>x</code>，具有根据<code>x</code>本身访问它父元素的途径<code>parent(x)</code>；</li>
  <li>根元素的<code>parent</code>，指向它自己，也就是<code>parent(x) = x</code>；</li>
  <li>查找一个元素<code>x</code>的代表元，只需要不断迭代查询元素的<code>parent(x)</code>，即可最终找到集合的根元素；</li>
</ol>

<h2 id="并查集的方法">并查集的方法</h2>
<ol>
  <li>初始化：每个元素的父节点各自指向自身，因为它们独立组成集合，还没有合并；</li>
  <li>查询：两个元素是否在同一集合中；</li>
  <li>合并：将两个集合合并成一个；</li>
  <li>获取集合中子集合个数：获取当前并查集中子集合的个数。</li>
</ol>

<h2 id="并查集的优化">并查集的优化</h2>
<h3 id="记录集合高度">记录集合高度</h3>
<p>对于每个集合，记录集合树的高度<code>rank</code>，在合并的时候，<strong>将较小<code>rank</code>的集合连接到较大<code>rank</code>的集合树上</strong>，可以减小合并后树的高度。</p>

<h3 id="路径压缩">路径压缩</h3>
<p>对于每次查询，如果查询到元素<code>a</code>所在集合的根元素是<code>root_A</code>，那么直接把<code>a</code>连接在<code>root_A</code>上，这样下次查询可以省去多级遍历的过程。</p>

<blockquote>
  <p>路径压缩后，集合树的高度可能有所变化，但是一般为简单起见，路径压缩后树的高度rank保持不变。</p>
</blockquote>

<h3 id="并查集的实现">并查集的实现</h3>

<p>可以用数组实现，也可以用哈希表。</p>

<p>用数组实现，是每个数组位置代表一个元素，同时定义<code>parent</code>数组和<code>rank</code>数组，记录每个位置的元素的父元素和它为根节点树的高度。</p>

<p>用哈希表实现，是每个元素的值作为键名，键值为一个对象，将<code>parent</code>和<code>rank</code>储存在其中。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HashMap Implementation</span>
<span class="kd">class</span> <span class="nx">BingChaJi</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">vals</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">vals</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="p">{</span>
                <span class="na">rank</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="na">parent</span><span class="p">:</span> <span class="nx">v</span><span class="p">,</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">findParent</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">v</span><span class="p">)[</span><span class="dl">'</span><span class="s1">parent</span><span class="dl">'</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">===</span> <span class="nx">v</span><span class="p">)</span> <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findParent</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">v</span><span class="p">}</span><span class="s2">'s parent is set to </span><span class="p">${</span><span class="nx">root</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">isSameSet</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">root1</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findParent</span><span class="p">(</span><span class="nx">v1</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">root2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findParent</span><span class="p">(</span><span class="nx">v2</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">root1</span> <span class="o">===</span> <span class="nx">root2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">merge</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">root1</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findParent</span><span class="p">(</span><span class="nx">v1</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">root2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findParent</span><span class="p">(</span><span class="nx">v2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">root1</span> <span class="o">===</span> <span class="nx">root2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root1</span><span class="p">).</span><span class="nx">rank</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root2</span><span class="p">).</span><span class="nx">rank</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">r1</span> <span class="o">&lt;</span> <span class="nx">r2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root1</span><span class="p">).</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">root2</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`root is </span><span class="p">${</span><span class="nx">root2</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root2</span><span class="p">).</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">root1</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`root is </span><span class="p">${</span><span class="nx">root1</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">r1</span> <span class="o">===</span> <span class="nx">r2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root1</span><span class="p">).</span><span class="nx">rank</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`rank is set to </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">root1</span><span class="p">).</span><span class="nx">rank</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="图">图</h1>

<h2 id="dfs深度优先搜索">DFS深度优先搜索</h2>
<h3 id="记忆化dfs搜索">记忆化DFS搜索</h3>

<p>记忆化DFS搜索，就是在DFS搜索的基础上，添加一个哈希表（或数组），用于保存计算过的结果（备忘录）。</p>

<p>当备忘录中存在结果时，直接返回。否则再进行计算+存储。</p>

<p>记忆化搜索是以空间换时间，可以降低时间复杂度。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></p>
</blockquote>

<p>基本思路：</p>

<ol>
  <li>先对原大礼包数组进行筛选，<strong>不划算的</strong>或<strong>礼包中某一物品数量多于所需数量的</strong>，都要筛除；</li>
  <li>搜索从当前需求<code>need = needs</code>开始，对于每一个<code>need</code>数组，它都对应着一个<code>最低购买价格</code>，我们把求出这个最低价格的函数叫做<code>getMinPrice()</code>，则对于需求need的最低价格为<code>min = getMinPrice(need)</code>；</li>
  <li>下面是<code>getMinPrice()</code>函数的实现：
    <ol>
      <li>最坏情况是，我们的需求，一个大礼包也买不了，这时需要原价买入所有的物品，假设此时价格为<code>originalPrice</code>；</li>
      <li>对于每一个大礼包，我们现在已知买入它们都是划算的（因为筛选过，但它们划算程度不同）。我们要找到所有大礼包中，买入后能满足当前需求，且总价格最低的；</li>
      <li>对于每一个大礼包，如果礼包中各物品的数量，都≤当前需求物品数量，则大礼包可以买入。反之，则不能买入。</li>
      <li>我们遍历所有大礼包，对于一个大礼包<code>s</code>，它内部物品数目列表为<code>sn</code>，如果它可以买入，那么它买入后，下次我们的需求就变成了<code>need - sn</code>（数组各位分别减去对应物品数目）。那么它买入后需求的最低购入价格就是<code>getMinPrice([need - sn])</code>，因此，买了这个礼包后，我们的购入价格是<code>price_need = getMinPrice([need - sn]) + price_s</code>；</li>
      <li>遍历所有大礼包，对每一个能买入的礼包<code>s</code>，都计算<code>price_need = getMinPrice([need - sn]) + price_s</code>，则达成当前需求need的最低费用是: 原价购买价格<code>originalPrice</code>与所有<code>price_need </code>中的最小值；</li>
    </ol>
  </li>
  <li>每次找到当前need的最低购入价格，就把它放在备忘录<code>map</code>中，键名是当前need形成的字符串<code>need.join('-')</code>，键值是价格；</li>
  <li>如果当前<code>need</code>的最低购入价格在备忘录中存在，则直接返回，省去计算步骤；</li>
  <li>要找的结果是最后备忘录中初始需求<code>needs</code>对应的价格。</li>
</ol>

<h2 id="bfs广度优先搜索">BFS广度优先搜索</h2>

<p>广度优先搜索从几个节点出发，这些节点本身组成一层。他们可到达的节点组成新的一层，在本层遍历完成后遍历，依次这样分层遍历，直到全部遍历完成。</p>

<p>广度优先搜索一般借助一个<strong>队列q</strong>来实现，每次从队列头部取出一个元素n，然后把这个元素n的下一层元素添加到队列末尾，这样可以保证元素按序分层遍历。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">地图分析</a></p>
</blockquote>

<h3 id="js广度优先搜索的优化">JS广度优先搜索的优化</h3>

<p>因为<code>JS</code>中没有标准的队列数据类型，需要用数组的<code>shift()</code>进行模拟，而数组的<code>shift()</code>是一个比较费时的操作，经常造成TLE。</p>

<p>解决方法是：</p>

<p><strong>每一层用一个<code>next</code>数组存放下一层的结点，将<code>q</code>中的元素一一<code>pop()</code>出来，然后将下一层的元素<code>push()</code>到next数组，最后用next代替q。</strong></p>

<p>这样就避免了<code>shift()</code>操作造成超时。（但是会造成搜索顺序变化）</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/map-of-highest-peak/submissions/">地图中的最高点</a></p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// template</span>
<span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[</span><span class="nx">init</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 新next数组</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span> <span class="c1">// 从原队列pop()</span>
        <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>  <span class="c1">// 找到下一层结点</span>
        <span class="nx">next</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>  <span class="c1">// push到next</span>
    <span class="p">}</span>
    <span class="nx">q</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span> <span class="c1">// 用next代替q</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="拓扑排序">拓扑排序</h2>

<blockquote>
  <p><a href="https://oi-wiki.org/graph/topo/#_1">OI Wiki拓扑排序</a></p>
</blockquote>

<h3 id="定义-1">定义</h3>

<p>拓扑排序要解决的问题，是给一个<strong>有向无环图（DAG：directed acyclic graph）</strong>的所有节点进行<strong>一维排序</strong>，使得对于存在的任何<code>u</code>到<code>v</code>的有向边<code>u -&gt; v</code>, 都可以保证<code>u</code>在<code>v</code>的前面。</p>

<h3 id="实现">实现</h3>

<p>拓扑排序的实现，一般有两种形式：<strong>Kahn算法</strong> 和 <strong>DFS</strong>。</p>

<p>其区别是：</p>

<ul>
  <li><strong>Kahn算法</strong>：从入度为0的节点开始，正序记录（在入度为0的时候记录数据）；</li>
  <li><strong>DFS</strong>：在出度为0的时候记录数据，记录顺序为逆序。</li>
</ul>

<h4 id="kahn-算法">Kahn 算法</h4>

<p>Kahn算法基本过程：</p>

<ol>
  <li>遍历有向无环图，记录每个节点的下一相邻节点集合，以及节点的<strong>入度（进入该节点的边数）</strong>；</li>
  <li>遍历所有节点，找到初始入度为0的节点，组成初始队列<code>q</code>；</li>
  <li>每次从队列<code>q</code>中出列一个节点<code>n</code>，然后执行如下操作：
    <ol>
      <li>将<code>n</code>添加到结果数组<code>res</code>尾部;</li>
      <li>找到<code>n</code>全部的相邻下一节点<code>t</code>，将<code>t</code>的入度<code>-1</code>（等同于将<code>n</code>从图中删除）；</li>
      <li>如果<code>t</code>的入度此时为0，则将<code>t</code>加入队列<code>q</code>尾部；</li>
    </ol>
  </li>
  <li>直到队列<code>q</code>为空，停止遍历，<code>res</code>为拓扑排序结果。</li>
</ol>

<p><strong>时间复杂度</strong>：O(N+E) (N为节点总数、E为边总数)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">kahnSort</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">entryNum</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">tos</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">f</span><span class="p">,</span> <span class="nx">t</span><span class="p">]</span> <span class="k">of</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">entryNum</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="nx">entryNum</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">entryNum</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="nx">entryNum</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">entryNum</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">entryNum</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">tos</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="nx">tos</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">());</span>
        <span class="nx">tos</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">entryNum</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">tos</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">t</span> <span class="k">of</span> <span class="nx">tos</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">entryNum</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">entryNum</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">entryNum</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dfs-实现拓扑排序">DFS 实现拓扑排序</h4>

<p>DFS实现拓扑排序基本过程：</p>

<ol>
  <li>用一个数组<code>visited</code>，标记节点是否被记录；</li>
  <li>遍历图，记录每一节点<code>n</code>的下一相邻节点集合，集合的元素数目就是<code>n</code>的<strong>出度</strong>；</li>
  <li>从任意节点开始，遍历全部节点，对任一节点<code>n</code>，如果其未被遍历:
    <ol>
      <li>如果出度为0，则push<code>n</code>到结果数组<code>res</code>;</li>
      <li>如果出度不为0，则递归对每一相邻下一节点<code>t</code>执行<code>dfs(t)</code>；</li>
      <li>记录<code>visited[n]</code>为true；</li>
    </ol>
  </li>
  <li>执行完毕，<code>res</code>为倒序的拓扑遍历结果。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">dfsSort</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>  <span class="c1">// 记录下一邻接节点集，以及出度</span>
    <span class="kd">let</span> <span class="nx">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span> <span class="c1">// 记录全部节点集合</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">f</span><span class="p">,</span><span class="nx">t</span><span class="p">]</span> <span class="k">of</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">());</span>
        <span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
        <span class="nx">nodes</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
        <span class="nx">nodes</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span> <span class="c1">// 已访问节点集合</span>

    <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">c</span> <span class="k">of</span> <span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">dfs</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">nodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="特殊的图结构">特殊的图结构</h2>

<h3 id="二分图">二分图</h3>

<p>一个图的节点能够被分成两组，并且每条边连接的两个顶点，都分别属于不同的组，那么这个图叫做<strong>二分图</strong>。</p>

<p>另一个等价说法：二分图是一个<strong>不包含由奇数条边组成的环</strong>的图。</p>

<h2 id="最小生成树">最小生成树</h2>

<h3 id="什么是最小生成树">什么是最小生成树</h3>

<p>无向连通图的<code>最小生成树（Minimum Spanning Tree，MST）</code>，为<strong>边权和最小</strong>的生成树。</p>

<p>一个由<code>n</code>个节点构成的图，它的最小生成树的边数为<code>n-1</code>。</p>

<h3 id="最小生成树kruskal算法">最小生成树：Kruskal算法</h3>

<p>Kruskal算法属于贪心算法。它的流程如下：</p>

<ol>
  <li>用并查集维护节点的连通性关系；</li>
  <li>维护已添加的边的权重加和<code>sum</code>，以及添加的边数<code>num</code>；</li>
  <li>从所有边中，选出权值最小的边<code>a -- b</code>，查看<code>a</code>和<code>b</code>是否在同一个连通分量中：
    <ol>
      <li>如果不在，则将这个边的权值计入结果<code>sum</code>，并将边数<code>num += 1</code>;</li>
      <li>如果在同一个连通分量，则跳过，寻找下一个权值最小边长；</li>
    </ol>
  </li>
  <li>直到添加了<code>n-1</code>条边，结束返回。</li>
</ol>

<p><img src="/assets/posts/kruskal.apng" alt="kruskal" /></p>

<h1 id="动态规划dynamic-programming">动态规划（Dynamic Programming）</h1>

<p>动态规划是一种思想，将问题<strong>分解为一个个状态</strong>，利用<strong>记忆化的方法储存计算过状态</strong>的结果，并<strong>利用现有状态结果转移计算新状态</strong>的方法。</p>

<p>因此要成功应用动态规划，有几个重要步骤：</p>

<ol>
  <li><strong>区分操作和状态</strong>：操作是对状态进行转移的动作。首先要区分题目中哪些是可进行的操作，哪些是问题的状态；</li>
  <li><strong>定义状态</strong>：找到问题所描述的解的状态，从而确定定义一个什么样的状态，可以由状态转移逐步推导出问题的解；</li>
  <li><strong>寻找状态变量</strong>：找寻合适的参数变量集合，使得一组确定的参数变量，可以确定问题唯一的状态；</li>
  <li><strong>给定初始状态或状态的边界：</strong> 无法再分割的最小状态，往往对应着<strong>单一且显而易见的结果</strong>，直接将结果赋值，然后从这些边界状态开始递推；</li>
  <li><strong>找到状态转移方式：</strong> 找到由旧状态递推新状态的方法。</li>
</ol>

<p>以上都成功应用的话，找到解只是向目标状态进行转移的过程，最终返回解所在的状态结果就可以了。</p>

<h2 id="背包零钱问题">背包（零钱）问题</h2>

<p>背包问题有两种形式：</p>

<ul>
  <li>① <strong>0-1背包问题：</strong> 背包内的东西只能取一次；</li>
  <li>② <strong>完全背包问题：</strong> 背包内的东西是无限的。</li>
</ul>

<blockquote>
  <p>0-1背包问题:</p>

  <p><a href="https://leetcode-cn.com/problems/YaVDxD/">加减的目标值</a>
<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></p>

  <p>完全背包问题：<a href="https://leetcode-cn.com/problems/coin-change-2/">零钱问题2</a></p>
</blockquote>

<h3 id="0-1背包问题">0-1背包问题</h3>

<p><a href="https://www.cnblogs.com/kkbill/p/12081172.html">详解0-1背包问题</a></p>

<p>主要思想是建立一个二维DP数组，行坐标代表<strong>物品集合区间</strong>，列坐标代表<strong>背包的剩余容量</strong>。</p>

<p><code>dp[r][c]</code>的含义是： 背包剩余容量为<code>c</code>的情况下，仅由<code>[0,r]</code>中的物品组成，能装下的最大价值。</p>

<p>这样对于一个<code>[r,c]</code>组合，有两种选择：</p>

<ul>
  <li><strong>选择装下这个物品r</strong>：假设物品r本身重量为wr，价值为vr，那么背包剩余容量为c-wr，物品r已经装入，只能从<code>[0,r-1]</code>物品区间继续装入，此时能装下的最大价值为<code>dp[r-1][c-wr]</code>。 因此这种情况的最大价值为<code>vr+dp[r-1][c-wr]</code>；</li>
  <li><strong>放弃装这个物品r</strong>：最大价值与r-1个物品时一样。为<code>dp[r-1][c]</code>。</li>
</ul>

<p>每次选二者之中较大者。</p>

<p>因为每次值只用到了r-1和r两行数据，可以对dp数组进行压缩。</p>

<blockquote>
  <p>最大可以压缩为一行。每次需要从右到左更新数据。(见上面的详解最下方。)</p>
</blockquote>

<h3 id="完全背包问题">完全背包问题</h3>

<p>0-1背包问题中，每个物品只能选择一次。而完全背包问题中，每个物品的数目是无限的，可以重复选择。</p>

<blockquote>
  <p>经典完全背包问题：凑零钱。给出零钱种类和目标值，求组成目标值的方法数。（比如由1,2,5组成10元有几种方法）</p>
</blockquote>

<p>对于完全背包问题，存在一个for循环先后顺序导致的，<strong>排列数</strong>和<strong>组合数</strong>的问题。</p>

<blockquote>
  <p><strong>详细说明：</strong></p>

  <p>动态规划解题，可以想到将钱数amount和钞票面值note联系起来: 组成一个目标值amount的方法数，等于所有钞票面值note对应的amount-note的方法数加在一起。<code>dp[amount] = sum( dp[amount-note] )</code></p>

  <p>比如： 如果给出钞票<code>[3,10]</code>，那么组成目标钱数20的方法数，应该等于组成20-3=17和20-10=10的方法数之和。因为组成17的每一个方法，再加上一张3元的钞票，就都可以组成目标值20，另一个例子同理。</p>

  <p>可以用两层for循环分别遍历amount数组和notes数组，动态更新amount数组的值： <code>amount[i] += amount[i-note]</code>。</p>

  <p>但是这里存在一个遍历顺序问题：</p>

  <ul>
    <li>
      <p><strong>① 如果先遍历amount，后遍历notes，则意味着：对于每个目标值，都直接穷举出所有当前可能的钞票组合，之后再进入下一个目标值进行更新。</strong></p>
    </li>
    <li>
      <p><strong>② 如果先遍历notes，后遍历amount，则意味着：对于每个钞票note，先计算并更新单独由这个note组成各个目标值的方法数，然后再进入下一个面额note，再更新这个新面额和之前所有面额组成的方法数，保证了每个方案中的钱的排布顺序，是<code>notes</code>的顺序。</strong></p>
    </li>
  </ul>

  <p>对于情况①，计算出来的是所有的<strong>无重复排列数</strong>。对于情况②，计算出来的是<strong>无重复组合数</strong>。</p>

  <p>本题不同排列同一组合，视为同一个方法，因此应该使用第二个遍历方式。</p>

</blockquote>

<h2 id="股票买卖">股票买卖</h2>

<blockquote>
  <p><a href="https://www.algoexpert.io/questions/Max%20Profit%20With%20K%20Transactions">股票买卖</a></p>

  <p>给你一个每日股票价格组成的数组prices（索引是日期，值是价格），和一个可交易次数k。编写返回可实现的最大收益的函数。</p>

  <p>股票同时期最多只能持有一份，一次也只能交易一份。也就是如果持有，必须先卖出才能再买入。</p>
</blockquote>

<p><strong>思路分析：</strong></p>

<ol>
  <li>一天可以有三种选择：买入、卖出、不操作；</li>
  <li>只有卖出才能获得收益；</li>
  <li>卖出必须先买入；</li>
  <li>如果不操作，则总收益和之前一天的收益相同。</li>
</ol>

<p>基于以上四点，可以得出下面的算法：</p>

<blockquote>
  <p>对于某一天，只关注卖出操作。我们可以选择<strong>卖出</strong>或<strong>不卖出</strong>。</p>

  <ul>
    <li>如果卖出， 则之前必定有一天进行了买入。此次交易赚取收益为<code>price[sell]-price[buy]</code>；</li>
    <li>如果不卖出，则总收益与前一天收益相同；</li>
  </ul>

  <p>设置一个矩阵，每一行代表最大可交易次数k，每一列代表交易日期day。每一个元素代表最大交易次数为k时，当前日期所能达到的最大收益。</p>

  <p>则有如下关系：</p>

  <p><img src="/assets/posts/20.png" alt="股票买卖" /></p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">maxProfitWithKTransactions</span><span class="p">(</span><span class="nx">prices</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="kd">let</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">trans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="nx">trans</span> <span class="o">&lt;=</span> <span class="nx">k</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kd">let</span> <span class="nx">notSellMaxProfit</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
				<span class="kd">let</span> <span class="nx">sellMaxProfit</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
				<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">buyDay</span><span class="o">=</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">buyDay</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">buyDay</span><span class="o">--</span><span class="p">){</span>
					<span class="nx">sellMaxProfit</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">sellMaxProfit</span><span class="p">,</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="nx">buyDay</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">buyDay</span><span class="p">]);</span>
				<span class="p">}</span>
				<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">notSellMaxProfit</span><span class="p">,</span> <span class="nx">sellMaxProfit</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
		<span class="nx">trans</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="三个无重叠子数组最大和">三个无重叠子数组最大和</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">三个无重叠子数组最大和</a></p>
</blockquote>

<p>使用动态规划方法解题。步骤如下：</p>

<ol>
  <li>先遍历数组，用一个map记录以i位置为结束位置的长度为k的子数组的加和，i&lt;k-1的值都为0，因为元素数目不够。（map.get(i)是<code>[i-k+1, i]</code>区间的加和）；</li>
  <li>使用一个二维dp数组保存计算结果。
    <ul>
      <li>dp的行n取值从0到3，代表可以选取的不相交子数组个数；</li>
      <li>dp的列i取值从0到nums.length-1，代表结束位置；</li>
      <li>因此，<code>dp[n][i]</code>代表可以取n个子数组时，<code>[0,i]</code>区间内可以取到的n个子数组的最大和。</li>
    </ul>
  </li>
  <li>当n=0时，<code>dp[n][i]</code>全部为0；其他情况下，当进行<code>dp[n][i]</code>的取值时，分为以下两种情况：
    <ul>
      <li>不使用当前位置i构成的子数组map.get(i)：<code>dp[n][i] = dp[n][i-1]</code></li>
      <li>使用当前位置i构成的子数组map.get(i): 则子数组<code>[i-k+1,i]</code>一定被使用了，当前dp值应该为 <code>dp[n][i] = dp[n-1][i-k] + map.get(i)</code></li>
    </ul>
  </li>
  <li>当n=3，保留结果中的最大值和它对应的索引值index；</li>
  <li>反向查找dp表，获得各子数组起始索引：
    <ul>
      <li>对于一个值<code>dp[n][i]</code>，如果它使用了i位置的子数组，那么<code>dp[n][i]</code>一定大于<code>dp[n][i-1]</code>；</li>
      <li>从n=3开始找，一直到n=1，保存结果值返回即可。</li>
    </ul>
  </li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">maxSumOfThreeSubarrays</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="nx">first</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">first</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">k</span><span class="p">];</span>
        <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">cur</span> <span class="o">-</span> <span class="nx">prev</span><span class="p">;</span>
        <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">sum</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">n</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kd">let</span> <span class="nx">notUsed</span> <span class="o">=</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kd">let</span> <span class="nx">used</span> <span class="o">=</span> <span class="nx">i</span><span class="o">-</span><span class="nx">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="o">-</span><span class="nx">k</span><span class="p">]</span> <span class="p">:</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">notUsed</span><span class="p">,</span> <span class="nx">used</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">){</span>
                <span class="nx">max</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="p">];</span>
                <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">findIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
                <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="o">-</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="o">-</span><span class="nx">k</span><span class="p">;</span>
            <span class="nx">n</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">findIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="最长回文子序列">最长回文子序列</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">Leetcode516: 最长回文子序列</a></p>
</blockquote>

<p><strong>思路:</strong></p>

<ol>
  <li>回文序列首尾元素一定相同；</li>
  <li>设置一个二维dp数组，<code>dp[i][j]</code>代表从<code>[i,j]</code>区间的最长子序列长度；</li>
  <li><code>dp[i][j]</code>递推根据首尾元素是否相同判断：
    <ul>
      <li>如果首尾元素相同，则<code>dp[i][j] = dp[i+1][j-1] + 2</code>;</li>
      <li>如果首尾元素不同，则它们必定不能同时作为最长子序列的首尾，<code>dp[i][j] = max (dp[i+1][j], dp[i][j-1])</code>。</li>
    </ul>
  </li>
  <li>需要注意dp遍历顺序问题，如果j从0到字符串末尾，那么i需要从j-1递减到0，这样才能正确利用之前的计算结果。</li>
</ol>

<h2 id="从1到n的bst的种类数">从1到n的BST的种类数</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></p>

  <p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
</blockquote>

<p><strong>思路：</strong></p>

<ol>
  <li>对于一个数字<code>n</code>，那么从1到n，每一个数都可以选取作为根节点；</li>
  <li>根据BST的性质，如果选择了i作为根节点，那么：
    <ul>
      <li><code>[1,i-1]</code>的元素都在左子树；</li>
      <li><code>[i+1,n]</code>的元素都在右子树。</li>
    </ul>
  </li>
  <li>根据BST的规则，<code>[1,n]</code>的BST种类和<code>[1+K,n+K]</code>的BST种类相同；</li>
  <li>设<code>dp[i]</code>为<code>[1,i]</code>区间可构建的BST种类数，那么：
    <ul>
      <li><code>[1,i-1]</code>的元素都在左子树，构建的BST种类数为<code>dp[i-1]</code>；</li>
      <li><code>[i+1,n]</code>的元素都在右子树，构建的BST种类数为<code>dp[n-i]</code>。</li>
    </ul>
  </li>
  <li>对于一个根节点，总种类数为左右子树种类数相乘，则有状态转移方程：<code>dp[i] = dp[i-1] * dp[n-i]</code>；</li>
  <li>从1到n遍历<code>n</code>，对每一个<code>n</code>遍历<code>i = [1,n]</code>选取作为根节点，计算其种类数加和做为<code>dp[n]</code>；</li>
  <li>返回<code>dp[n]</code>即可。</li>
</ol>

<h2 id="区间dp">区间DP</h2>

<p>状态与区间相关，且可以由区间的切分等进行状态转移。</p>

<p>区间DP的基本流程是：</p>

<ol>
  <li><code>dp[l][r]</code>代表闭区间<code>[l,r]</code>范围内的结果；</li>
  <li>对<code>[l,r]</code>区间进行某种拆分，常见的是在<code>[l+1,r-1]</code>区间枚举切分点<code>i</code>，将区间分为<code>[l,i]</code>和<code>[i,r]</code>两部分，并对每个切分点结果进行比较取最值，记录到<code>dp[l][r]</code>；</li>
  <li>注意区间DP的顺序问题：因为大区间要用到小区间的信息，所以遍历的时候要先以区间长度<code>len</code>为条件（从小到大），再枚举区间的起点<code>l</code>（从小到大、从大到小均可），<code>r</code>的位置此时可以确定为<code>l+len</code>；</li>
</ol>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/">1039. 多边形三角剖分的最低得分</a></p>
</blockquote>

<ul>
  <li>假设<code>dp[l][r]</code>为<code>[l,r]</code>区间切分的最小得分，那么整体的最小得分就是<code>dp[0][len-1]</code>；</li>
  <li>在<code>[l+1,r-1]</code>区间内可以枚举切分点，将区间分为<code>[l,i]</code>和<code>[i,r]</code>两部分；</li>
  <li><code>dp[l][r] = min(dp[l][i] + dp[i][r] + v[l]*v[r]*v[i])</code>；</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">minScoreTriangulation</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 区间DP</span>
    <span class="c1">// dp[l][r]: [l,r] 区间的最低分。</span>
    <span class="c1">// dp[l][r] = min(v[l]*v[r]*v[k] + dp[l][k] + dp[k][r]), k -&gt; [l+1, r-1];</span>
    <span class="kd">let</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">len</span> <span class="o">&lt;=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="o">&lt;</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dp</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">dp</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="p">],</span> <span class="nx">values</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span><span class="o">*</span><span class="nx">values</span><span class="p">[</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="p">]</span><span class="o">*</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">l</span><span class="o">+</span><span class="nx">len</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="贪心算法">贪心算法</h1>

<h1 id="分治算法">分治算法</h1>

<h2 id="平面最近点对">平面最近点对</h2>

<blockquote>
  <p>给出一系列二维平面内的点<code>[p1,p2,p3,p4...]</code>，每个点由<code>[x,y]</code>坐标构成，请寻找最近的一对坐标点之间的欧氏距离。</p>
</blockquote>

<h3 id="思路">思路</h3>

<ol>
  <li>直接暴力求解，问题复杂度为<code>O(n^2)</code>，复杂度高的原因是进行了大量的无意义计算（比如相隔非常远的点间距离）；</li>
  <li>可以用一条线将平面分割成两部分（假定选择垂直于X轴的竖线），发现问题可以被分为子问题：
    <ol>
      <li>左边部分点集的最小距离<code>l_min</code>；</li>
      <li>右边部分点集的最小距离<code>r_min</code>；</li>
      <li>横跨左右点集的最小距离<code>m_min</code>；</li>
    </ol>
  </li>
  <li>对于任何一个点集的最终结果，都是上述三个子区间各自结果中的最小值<code>min(l_min, r_min, m_min)</code>；</li>
  <li>采用分治算法：
    <ol>
      <li>先对点集进行按x坐标从小到大排序；</li>
      <li>递归出口：如果区间内的元素小于<code>3</code>个，直接进行计算返回；</li>
      <li>按上述划分法，对每一个区间<code>[l,r]</code>，取中间点<code>m = Math.floor((l+r)/2);</code>，分割成左右两部分；</li>
      <li>对左右两部分分别递归求最小距离，假设结果为<code>l_min</code>和<code>r_min</code>，我们取它们二者中的最小值为<code>delta</code>；</li>
      <li>对<code>m</code>位置的左右两侧，只对<code>± delta</code>范围内的元素进行求距离比对，找出这个范围内的最小距离<code>m_min</code>；</li>
      <li>返回三者中的最小值。</li>
    </ol>
  </li>
</ol>

<h3 id="实现-1">实现</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">((</span><span class="nx">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">closestPair</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">l</span><span class="p">]);</span>
        <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">r</span><span class="p">]);</span>
        <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">points</span><span class="p">[</span><span class="nx">r</span><span class="p">]);</span>
        <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">lmin</span> <span class="o">=</span> <span class="nx">closestPair</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">m</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">rmin</span> <span class="o">=</span> <span class="nx">closestPair</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">delta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">lmin</span><span class="p">,</span> <span class="nx">rmin</span><span class="p">);</span>
    <span class="c1">// +- delta</span>
    <span class="kd">let</span> <span class="nx">leftSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">rightSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">m</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">points</span><span class="p">[</span><span class="nx">m</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">leftSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">c</span><span class="p">]);</span>
        <span class="nx">c</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&lt;</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">points</span><span class="p">[</span><span class="nx">m</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rightSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">points</span><span class="p">[</span><span class="nx">c</span><span class="p">]);</span>
        <span class="nx">c</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">p1</span> <span class="k">of</span> <span class="nx">leftSet</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">p2</span> <span class="k">of</span> <span class="nx">rightSet</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">lmin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">lmin</span><span class="p">,</span> <span class="nx">getDist</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">lmin</span><span class="p">,</span> <span class="nx">rmin</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// test</span>
<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">200</span><span class="p">]];</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">closestPair</span><span class="p">(</span><span class="nx">p</span><span class="p">));</span> <span class="c1">// 1.414..</span>
</code></pre></div></div>

<h2 id="为运算表达式设计优先级">为运算表达式设计优先级</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></p>
</blockquote>

<p>采用分治算法+dfs：</p>

<ul>
  <li>设置一个dfs(l,r)函数，用来计算原表达式从l到r闭区间内子表达式的计算结果；</li>
  <li>原表达式可以从任一操作符一分为二，可知左右两侧仍是一个表达式；</li>
  <li>对两侧表达式重复上述分割步骤，直到两侧为不含操作符的数字；</li>
  <li>每一个表达式因计算优先级的不同，可能有多种计算结果，因此返回的应该是一个数组，里面保存了所有表达式可能的计算结果；</li>
  <li>每次用当前运算符，对左右两个表达式的计算结果进行遍历计算，合并结果集，最终返回整个表达式的结果。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">diffWaysToCompute</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">expression</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 测试字符串是否是纯数字</span>
    <span class="kd">function</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sr">/^</span><span class="se">\d</span><span class="sr">+$/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 执行单次计算</span>
    <span class="kd">function</span> <span class="nx">cal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="dl">'</span><span class="s1">+</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">l</span><span class="o">+</span><span class="nx">r</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="dl">'</span><span class="s1">-</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">l</span><span class="o">-</span><span class="nx">r</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="dl">'</span><span class="s1">*</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">l</span><span class="o">*</span><span class="nx">r</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 按操作符分隔表达式，取结果集合。</span>
    <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">expression</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">expression</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span><span class="nx">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="o">+</span><span class="nx">expression</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span><span class="nx">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">r</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">expression</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">);</span>
                <span class="kd">let</span> <span class="nx">operater</span> <span class="o">=</span> <span class="nx">expression</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="k">of</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cal</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">operater</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">dfs</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="回溯算法">回溯算法</h1>

<h2 id="算法基本思路">算法基本思路</h2>

<p>回溯算法是遍历决策树的过程。决策过程可以表示为<strong>当前路径</strong>、<strong>当前决策空间</strong>和<strong>结束条件</strong>。</p>

<ul>
  <li><strong>当前路径</strong>：是由已经进行过的所有决策组成的。下一步决策依赖于当前走过的决策路径。（比如：有三张牌ABC，第一次选择B，第二次选择C，则当前第三次选择的路径为B-C）；</li>
  <li><strong>当前决策空间</strong>：根据当前路径，本次决策剩余的选择空间。（ABC三张牌，前两次选择BC，则第三次当前选择空间只有一张牌A）；</li>
  <li><strong>结束条件</strong>：决策空间中没有任何选项时，则代表决策树遍历到尽头，需要用结束条件处理这次决策的结果。（比如将当前决策路径B-C-A保存起来）</li>
</ul>

<p>回溯算法一般是基于<strong>递归调用</strong>实现，递归主要负责实现决策树的遍历。回溯算法的主要过程如下：</p>

<blockquote>
  <ol>
    <li>先判断当前路径是否满足结束条件，满足则执行结束操作；</li>
    <li>在当前决策空间B内进行决策，然后在当前路径A中添加当前决策（结果为A1），在当前决策空间B中去掉当前决策（结果为B1）；</li>
    <li>以A1为下一决策的路径，以B1为下一决策的决策空间，递归调用自身；</li>
    <li>调用完成后，将决策路径B1恢复为B，路径A1也恢复为A。（这一步称为回溯过程）</li>
  </ol>
</blockquote>

<p>回溯算法的应用：DFS深度优先搜索、全排列问题、组合问题等。</p>

<blockquote>
  <p><strong>注意：</strong></p>

  <p>理论上使用回溯算法，执行决策后的回溯过程（恢复空间），应该与决策前的顺序正好相反，代码在结构上完全<strong>镜像对称</strong>。否则容易出现Bug。</p>
</blockquote>

<h2 id="回溯的注意事项">回溯的注意事项</h2>

<ol>
  <li>回溯算法复杂度高(<code>O(n!)</code>)，一般数据量要小于20；</li>
  <li>回溯算法本质上是递归，一般都可以应用<strong>记忆化</strong>方法，记录计算结果，防止重复计算；</li>
  <li>回溯计算过程中，如果找到了想要的结果，要及时提前退出递归，终止后续计算。</li>
</ol>

<h2 id="回溯算法全排列问题">回溯算法：全排列问题</h2>

<h3 id="元素互不相同的全排列">元素互不相同的全排列</h3>

<blockquote>
  <p>给定一个由字母组成的数组arr，数组中元素互不相同，请返回由全部数组元素组成的所有排列。</p>

  <p>例如: <code>['a','b','c']</code> 的全排列是<code>[['a','b','c']，['a','c','b']，['b','a','c']，['b','c','a']，['c','b','a']，['c','a','b']]</code></p>
</blockquote>

<p>考虑使用回溯算法：</p>

<ol>
  <li>当前路径就是已经选择过的字母序列，当前决策空间就是剩余的可被选择的字母集合；</li>
  <li>每次决策，在剩余字母中选择一个(比如’a’)，添加到路径中，然后在可选择字母集合中删除掉这个已经选过的字母a；</li>
  <li>使用新路径和新决策空间，递归调用执行下一次决策；</li>
  <li>结束条件：当可选择字母集合为空，说明排列已经完成，将结果添加到结果集合，然后返回；</li>
  <li>递归调用完成后，恢复路径（删掉添加的字母a）和决策空间（恢复字母a）。</li>
</ol>

<p><img src="/assets/posts/21.png" alt="全排列问题" /></p>

<p>代码如下：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 方法1：</span>
<span class="kd">function</span> <span class="nx">getArrangement</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">path</span><span class="o">=</span><span class="p">[],</span> <span class="nx">res</span><span class="o">=</span><span class="p">[]){</span>
<span class="c1">// arr是当前决策空间，path是当前路径 </span>
<span class="c1">// 1.判断结束条件：决策空间内无元素可选；</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
<span class="c1">// 2.进行决策；</span>
        <span class="kd">let</span> <span class="nx">selected</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="c1">// 3. 修改决策空间和路径，用来进行下一次决策；</span>
        <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">selected</span><span class="p">);</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 4. 递归调用，执行下一次决策；</span>
        <span class="nx">getArrangement</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
<span class="c1">// 5. 恢复 决策空间 和 路径。</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">selected</span><span class="p">);</span>
        <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 方法2： 使用一个used记录选择的路径</span>
<span class="kd">function</span> <span class="nx">allArrangement2</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kd">function</span> <span class="nx">backtrack</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="nx">backtrack</span><span class="p">();</span>
                <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
                <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">backtrack</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="元素存在重复的全排列">元素存在重复的全排列</h3>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/permutations-ii/">元素存在重复的全排列</a></p>
</blockquote>

<p>当给定数组中存在重复元素时，进行全排列会出现重复结果。</p>

<p>比如： <code>[1,1,2,3]</code>的全排列中，<code>[1,1,2,3]</code>本身会出现两次，因为存在两个1。</p>

<p><strong>解决方法是：在相同决策空间进行选择的时候，进行一个判断。如果前后两次选择的元素值相同，则后续排列必重复，直接跳过此次选择即可。</strong></p>

<blockquote>
  <p>例如在某次决策过程中，决策空间为<code>[1,1,2,3]</code>，选择从左到右进行。本轮选择为第一个1元素，则下一次决策的空间为<code>[1,2,3]</code>。</p>

  <p>本轮回溯过程执行完毕后，下次决策选择了第二个元素，此时发现同样为1元素，剩余空间还是<code>[1,2,3]</code>。那么这两次决策结果一定相互重复，第二轮直接跳过即可。</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="o">=</span><span class="p">[],</span> <span class="nx">space</span><span class="o">=</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">res</span><span class="o">=</span><span class="p">[]){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">space</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// 为每一轮回溯决策过程，设置一个Set，用来保存已经选择过的元素值。</span>
    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">space</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
<span class="c1">// 当该决策空间中已经选取过当前元素，直接跳过，防止重复。</span>
        <span class="k">if</span><span class="p">(</span><span class="kd">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">space</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">space</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">space</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">);</span>
            <span class="nx">space</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
            <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">space</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="nx">space</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">cur</span><span class="p">);</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="全部子集组合问题">全部子集（组合问题）</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/subsets/">子集</a></p>
</blockquote>

<p>求子集的回溯算法，思路如下：</p>

<ol>
  <li>设置一个path，代表已经选择的元素路径；</li>
  <li>对于每一个path，设置一个start值，代表下次选择的起始位置；（含义是：path条件下，<code>index &lt; start</code>的全部元素子集已经处理完毕）</li>
  <li>每次从start到数组结尾遍历剩余选择空间，将元素放入path然后记录到结果数组，最后返回结果数组。</li>
</ol>

<p>子集（组合）问题，每次都要进行判断，记录结果，而不是在最后判断返回。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">allCombination</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>

    <span class="kd">function</span> <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]){</span>
    <span class="c1">// 对于每一个path，选择空间是[start, arr.length-1]，[0,start) 全部子集都处理完成，不用考虑。</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">start</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// 对于每一个可选择元素，我们可以将其加入组合，也可以选择跳过（不加入）。</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
            <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span> <span class="c1">// 回溯，当前元素arr[i]被选择的情况已经遍历完成，将其弹出（表示当前元素被跳过），继续下一个元素的决策。</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">backtrack</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="组合的去重">组合的去重</h3>

<p>如果一个集合<code>arr</code>中有重复的元素，那么在上述求组合的结果中，会出现重复的组合。</p>

<blockquote>
  <p><strong>重复组合</strong>： 组合中的元素种类，及各种类的数目都相同。</p>

  <p>例如: <code>[1,2,3]</code> 和 <code>[3,2,1]</code></p>
</blockquote>

<p>去除重复组合的方法：</p>

<ol>
  <li>先将数组排序，这样重复的元素位置会相邻分布；</li>
  <li>在回溯寻找组合的过程中，对于某次元素选择<code>arr[i]</code>，查看其上一元素<code>arr[i-1]</code>是否与它相同，如果相同则跳过。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">subsetsWithDup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// 先排序，让相同元素凑在一起。</span>
   <span class="kd">function</span> <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]){</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">start</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">start</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 这里判断当前元素与前一元素是否相同，相同则跳过。（同一深度，添加相同的元素会造成重复）</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
            <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">backtrack</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="回溯算法括号匹配">回溯算法：括号匹配</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
</blockquote>

<p>回溯算法，解法等同于<a href="#283-典型递归问题">div标签生成</a>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">generateParenthesis</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">function</span> <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="o">=</span><span class="p">[],</span> <span class="nx">leftleft</span><span class="o">=</span><span class="nx">n</span><span class="p">,</span> <span class="nx">rightleft</span><span class="o">=</span><span class="nx">n</span><span class="p">,</span> <span class="nx">res</span><span class="o">=</span><span class="p">[]){</span>
<span class="c1">// 结束条件</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">leftleft</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">rightleft</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">''</span><span class="p">));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
<span class="c1">// 回溯：选择</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">leftleft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">(</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">leftleft</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">rightleft</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="p">}</span>
<span class="c1">// 这里可以保证：右括号只有在有左括号能匹配的情况下，才会被添加。</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">rightleft</span> <span class="o">&gt;</span> <span class="nx">leftleft</span><span class="p">){</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">)</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">backtrack</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">leftleft</span><span class="p">,</span> <span class="nx">rightleft</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
            <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">backtrack</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="回溯算法优美的排列">回溯算法：优美的排列</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">优美的排列</a></p>
</blockquote>

<p>回溯算法的路径，如果每次选择只涉及两种情况，则可以使用一个与原空间等长度的数组，用true和false代表选择的与否。</p>

<h1 id="递归">递归</h1>

<h2 id="递归的特点和基本思想">递归的特点和基本思想</h2>

<p>递归是一种<strong>解空间的遍历手段</strong>，它不同于for/while循环，递归遍历的空间可以是<strong>非线性</strong>的。（图、树等）</p>

<p>递归通过在函数内调用自身实现。递归在内存中是通过函数调用栈来实现的，每次调用函数在调用栈中压入函数，函数执行完毕后弹出，恢复上层函数的执行环境。</p>

<p>因为这个原因，递归在内存中需要占用空间，空间复杂度较高。（占用空间与函数的最大调用次数n正相关。）</p>

<p><strong>递归的注意事项：</strong></p>

<ul>
  <li>设置合理的退出条件；</li>
  <li>递归深度影响空间复杂度，能用迭代实现尽量不用递归。</li>
</ul>

<h2 id="递归复杂度分析">递归复杂度分析</h2>

<p>递归问题的复杂度可以画<strong>递归树</strong>分析：</p>

<p>时间复杂度等于：<strong>每次函数调用的时间复杂度 × 递归调用次数</strong>。</p>

<p>空间复杂度等于：<strong>每次调用函数所需空间复杂度 * 最大递归深度</strong>。</p>

<h2 id="典型递归问题">典型递归问题</h2>

<blockquote>
  <p><a href="https://www.algoexpert.io/questions/Generate%20Div%20Tags">生成DIV标签</a></p>
</blockquote>

<p>思路： 回溯算法，递归实现。</p>

<ol>
  <li>控制可用的开始和结束标签数目，当开始标签可用数&gt;0时，向后面添加一个开始标签；</li>
  <li>然后检查结束标签可用数，如果发现结束标签可用数大于开始标签可用数，说明有开始标签没有被正确关闭，此时向字符串后添加一个结束标签；</li>
  <li>当开始标签和结束标签可用数都为0，则向结果数组中保存结果。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">generateDivTags</span><span class="p">(</span><span class="nx">numberOfTags</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
	<span class="kd">function</span> <span class="nx">getStrings</span><span class="p">(</span><span class="nx">prefix</span><span class="p">,</span> <span class="nx">openings</span><span class="p">,</span> <span class="nx">closings</span><span class="p">,</span> <span class="nx">result</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="nx">openings</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">closings</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
			<span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">prefix</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="nx">openings</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
			<span class="kd">let</span> <span class="nx">newPrefix</span> <span class="o">=</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">&lt;div&gt;</span><span class="dl">'</span><span class="p">;</span>
			<span class="nx">getStrings</span><span class="p">(</span><span class="nx">newPrefix</span><span class="p">,</span> <span class="nx">openings</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">closings</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="nx">closings</span> <span class="o">&gt;</span> <span class="nx">openings</span><span class="p">){</span>
			<span class="kd">let</span> <span class="nx">newPrefix</span> <span class="o">=</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">&lt;/div&gt;</span><span class="dl">'</span><span class="p">;</span>
			<span class="nx">getStrings</span><span class="p">(</span><span class="nx">newPrefix</span><span class="p">,</span> <span class="nx">openings</span><span class="p">,</span> <span class="nx">closings</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">getStrings</span><span class="p">(</span><span class="dl">''</span><span class="p">,</span> <span class="nx">numberOfTags</span><span class="p">,</span> <span class="nx">numberOfTags</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="排序算法">排序算法</h1>

<p><a href="/blog/2021/03/26/排序算法基本思想与JS实现/">各排序算法基本思想与JS实现</a></p>

<h2 id="堆排序">堆排序</h2>
<h3 id="构建堆也叫优先级队列">构建堆（也叫优先级队列）</h3>

<blockquote>
  <p><a href="/blog/2021/06/17/使用数组构建堆结构的过程和原理/">构建堆</a></p>
</blockquote>

<p>适用于：<strong>在对一个集合的遍历过程中，动态获取最大值或最小值的问题。</strong></p>

<blockquote>
  <p>例如： 获取一个数组中出现次数最高的前N个元素。</p>
</blockquote>

<p>为集合元素构建堆（大顶堆、小顶堆），可以通过堆排序，方便获取某一属性优先的前N个元素。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">1792. 最大平均通过率</a></p>
</blockquote>

<h2 id="字典序">字典序</h2>

<p>字典序的比较优先级从高到低（以字典序从小到大为例）：</p>

<ol>
  <li>从前到后逐位比较，<strong>同一位置上字符值更大</strong>的，字典序更靠后；</li>
  <li>前缀相同的两个字符串，<strong>长度更长</strong>的，字典序靠后；</li>
</ol>

<p>也就是说，在字典序中比较两个字符串<code>a</code>和<code>b</code>，相当于比较它们<strong>最靠前的不同字符<code>a[i]</code>和<code>b[i]</code></strong>。</p>

<p>一个给定的字典序排列<code>[a,b,c,d,e...]</code>，假设长度为<code>n</code>，则：</p>

<ul>
  <li>它可以按照给定的字母顺序，形成一个<code>n叉字典树</code>；</li>
  <li>将字符串按字典序排列，等同于将字符串加入这个字典树，然后对这个<code>n叉树</code>进行<strong>先序遍历</strong>。</li>
</ul>

<h1 id="搜索算法">搜索算法</h1>

<p>各种搜索问题，本质上都是<strong>树的遍历问题</strong>。</p>

<h2 id="二分查找">二分查找</h2>
<h3 id="复杂度分析">复杂度分析</h3>

<p>时间复杂度： <strong>O(logN)</strong>，N为原数组长度。</p>

<p>空间复杂度： <strong>O(1)</strong></p>

<h3 id="二分查找适用情况">二分查找适用情况</h3>

<p>应用二分查找的必要条件是：</p>

<ul>
  <li>①顺序存储：数组结构；</li>
  <li>②有序，可以缩小结果范围。</li>
</ul>

<p>一般适用于：<strong>按序排列</strong>的数组元素搜索。</p>

<h3 id="二分查找的关键信息">二分查找的关键信息</h3>

<ul>
  <li>成功应用二分查找，必须要找到一个<strong>根据中间点，能对左右两侧区间进行取舍的判据</strong>；</li>
  <li>二分查找的最终时间复杂度为<code>O(log_n)</code>；</li>
</ul>

<h3 id="二分查找的区间情况和对应的代码">★二分查找的区间情况和对应的代码</h3>

<p>假设二分查找应用的数据是<strong>升序排列</strong>的，假设它的区间是<code>[a,b]</code>。将它以目标值<code>target</code>分成两部分，一定是如下两种情况之一：</p>

<ol>
  <li><code>[a,target)</code>和<code>[target,b]</code>;</li>
  <li><code>[a,target]</code>和<code>(target,b]</code>。</li>
</ol>

<p>对于一个<code>target</code>,我们进行查找的目标的情况可以是：</p>

<ul>
  <li><code>≤target</code>的最后一个元素；</li>
  <li><code>&lt;target</code>的最后一个元素；</li>
  <li><code>≥target</code>的第一个元素；</li>
  <li><code>&gt;target</code>的第一个元素。</li>
</ul>

<p><img src="/assets/posts/22.png" alt="二分情况" /></p>

<p>需要根据上述四种查找的目标情况，对区间进行正确切分，注意<strong>我们需要保证<code>[left,right]</code>区间内元素是我们想要的元素，而且最后left和right要重合，否则会出现数组越界。</strong></p>

<ul>
  <li><strong>查找<code>≤target</code>的最后一个元素时：</strong>
    <ul>
      <li>mid ≤ target: left = mid;</li>
      <li>mid &gt; target: right = mid - 1;</li>
      <li>mid的取整情况：向上取整。</li>
    </ul>
  </li>
  <li><strong>查找<code>&lt;target</code>的最后一个元素:</strong>
    <ul>
      <li>mid &lt; target: left = mid;</li>
      <li>mid ≥ target: right = mid - 1;</li>
      <li>mid的取整情况：向上取整。</li>
    </ul>
  </li>
  <li><strong>查找<code>≥target</code>的第一个元素:</strong>
    <ul>
      <li>mid &lt; target: left = mid + 1;</li>
      <li>mid ≥ target: right = mid;</li>
      <li>mid的取整情况：向下取整。</li>
    </ul>
  </li>
  <li><strong>查找<code>&gt;target</code>的第一个元素:</strong>
    <ul>
      <li>mid ≤ target: left = mid + 1;</li>
      <li>mid &gt; target: right = mid;</li>
      <li>mid的取整情况：向下取整。</li>
    </ul>
  </li>
</ul>

<p>这里有几个技巧（对于升序排列）：</p>

<ol>
  <li>先正确切分区间（哪边闭哪边开），然后判断查找的目标区间在哪一侧，目标区间边界在收缩的时候一定是闭的（在左侧：<code>left = mid</code> 或 在右侧：<code>right = mid</code>）；</li>
  <li>right只能向左缩小，left只能向右缩小。也就是说，left、right取值只有以下两种情况：
    <ul>
      <li>left = mid, right = mid - 1;</li>
      <li>left = mid+1, right = mid;</li>
    </ul>
  </li>
  <li>向上还是向下取整，取决于哪边是开区间：
    <ul>
      <li>当存在left = mid + 1，向下取整；</li>
      <li>当存在right = mid - 1， 向上取整。</li>
    </ul>
  </li>
  <li>二分查找过程中，mid的判断条件，和区间的切分情况一定完全相同。需要做的只是根据区间的切分情况，对mid进行开闭取舍；</li>
  <li>mid位于目标值target左侧，动左区间。mid位于目标值右侧，动右区间。</li>
</ol>

<blockquote>
  <p>此外，二分查找的取中点操作，一定要用<code>Math.floor((l+r)/2)</code>形式，而不是位运算<code>(l+r) &gt;&gt; 1</code>!</p>

  <p>因为JS对位运算参与的数，当做32位整数处理，而不是64位。这样做在数值大于<code>2^32-1</code>的时候会造成计算错误。</p>

  <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(((</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">// 1073741823</span>
<span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>           <span class="c1">// 1073741823</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(((</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">// 2147483647</span>
<span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>           <span class="c1">// -1</span>
</code></pre></div>  </div>
</blockquote>

<h3 id="基本代码实现">基本代码实现</h3>

<p>二分查找实现的两种方式：1.迭代 2.递归。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 递归实现：升序数组nums中，查找≤target的最后一个元素。</span>
<span class="kd">const</span> <span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">find</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">){</span>
            <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">((</span><span class="nx">left</span><span class="o">+</span><span class="nx">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="p">)</span> <span class="k">return</span> <span class="nx">find</span><span class="p">(</span><span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span><span class="p">);</span>
            <span class="k">else</span> <span class="k">return</span> <span class="nx">find</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">find</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 迭代实现</span>
<span class="kd">var</span> <span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">((</span><span class="nx">left</span><span class="o">+</span><span class="nx">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="p">)</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span><span class="p">;</span>   
        <span class="k">else</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">left</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="二多维空间的二分查找">二（多）维空间的二分查找</h3>

<p>对于一个二（多）维数组，如果它的元素按照各维度的增长方向，已经是有序排列，那么它就满足了二分查找的条件：可以对任意一个中间值<code>mid</code>，查找比<code>mid</code>大或小的元素个数。</p>

<p>方法如下：</p>

<ol>
  <li>先确定元素的左右极值：因为为有序排列，极值位于维度增长方向的两个端点；
    <blockquote>
      <p>例如：</p>

      <p>对于二维数组<code>arr</code>，如果按行按列都是递增的，那么极小值在<code>arr[0][0]</code>，极大值在<code>arr[arr.length-1][arr[0].length-1]</code>，也就是左上角、右下角;</p>
    </blockquote>
  </li>
  <li>对于一个<code>k</code>维有序数组，我们可以在<strong>O(n<sup>k-1</sup>)</strong>时间复杂度完成一次查询，方法是：固定其他维度，将多维降为二维，然后找到二维数据某一递增轴的末端点，作为起点，向另一个轴方向进行计数；<br />
<img src="/assets/posts/43.png" alt="二分" /></li>
  <li>然后利用左右极值，进行常规二分查找即可。</li>
</ol>

<h1 id="滑动窗口">滑动窗口</h1>

<p>适用于：在一个大的连续空间，寻找满足特定要求的<strong>连续</strong>子区间。</p>

<blockquote>
  <p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p>

  <p>— 《挑战程序设计竞赛》</p>
</blockquote>

<p>滑动窗口的基本过程是：</p>

<ol>
  <li>通过左右边界维护一个窗口：<code>left</code>和<code>right</code>，初始都在<code>0</code>位置;</li>
  <li>窗口的有效区间范围是<code>[left, right]</code>双闭区间；</li>
  <li>右边界是<strong>主动</strong>前进的，它负责向右扩展窗口探索新区域，<strong>每次只前进一步</strong>；</li>
  <li>左边界是<strong>被动</strong>前进的，因为每次右边界都会前进，窗口内的值可能不再符合要求，需要收缩左边界使得当前窗口内的值继续满足要求，左边界<strong>每次可以前进多步</strong>；</li>
  <li>直到右边界到达末尾<code>length-1</code>位置，停止搜索。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 滑动窗口的伪代码</span>
<span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">target</span> <span class="o">+=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="cm">/* target do not fit the condition */</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">target</span> <span class="o">-=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">];</span> <span class="c1">// decrease length of the window, change the target value.</span>
        <span class="nx">left</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="nx">target</span> <span class="c1">// record the found answer here.</span>
    <span class="nx">right</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
</code></pre></div></div>
<h1 id="枚举">枚举</h1>

<p>当问题解的空间不大时（一般小于 <code>2^16</code>），可以直接进行枚举，找出所有的解。</p>

<p>特殊情况下，可以用二进制数字表示每个状态，通过二进制数字进行解空间的枚举。</p>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/">6029. 射箭比赛中的最大得分</a></p>
</blockquote>

<h2 id="双指针">双指针</h2>

<h2 id="快慢指针">快慢指针</h2>

<p>快慢指针：同一方向，不同前进速度的两个指针。</p>

<p>快慢指针的用途：</p>

<ul>
  <li><strong>链表寻环</strong>： 使用快慢指针，快指针比慢指针每次多走1步，如果有环存在，则快慢指针一定会相遇；</li>
  <li><strong>寻找链表的中点</strong>； 使用快慢指针，慢指针每次走1步，快指针每次走2步，则快指针到达尾部，慢指针正好在链表中间位置；</li>
</ul>

<h1 id="有序集合">有序集合</h1>
<h2 id="跳表-skiplist">跳表 SkipList</h2>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/23370124">Redis为什么用跳表而不用平衡树？ - 张铁蕾的文章 - 知乎</a></p>
</blockquote>

<p>跳表是有序链表的扩展，是有序集合的一种。它可以实现<code>O(logN)</code>时间复杂度的集合元素<strong>添加、删除和查询</strong>操作。</p>

<p>相比于各种平衡树，跳表的平均时间复杂度相当，且在原理和实现上更为简单。</p>

<p><img src="/assets/posts/59.png" alt="skiplist" /></p>

<p>跳表为什么能够降低有序链表查询的时间复杂度？</p>

<p><strong>跳表为有序链表的每个结点，额外增加了多个指针，用于指向其他节点。这些指针被分成多层，层数从低到高，每层的指针数目递减。查询时，从最顶层开始查找，这样可以大步长快速定位到查询节点附近，然后逐层降低层数，直到层数为0，返回查询到的结果（或未找到）。</strong></p>

<p>因为跳表涉及到频繁插入、删除等操作，无法使用固定的递减模式进行层数设计。跳表一般使用一个概率值<code>p</code>确定节点指针的层数，并设置一个最大层数<code>M</code>，防止层数过高。</p>

<p>根据Redis的实现，<code>M = 32， p = 1/4</code>是合适的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Marswiz @2022</span>
<span class="c1">// Skiplist in JS.</span>
<span class="kd">class</span> <span class="nx">SkipList</span> <span class="p">{</span>
    <span class="nx">MAX_LAYER</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="nx">P</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">data</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">MAX_LAYER</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="kc">null</span><span class="p">));</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="o">-</span><span class="kc">Infinity</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">MAX_LAYER</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">addNode</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">P</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">nextLayer</span> <span class="o">=</span> <span class="p">[</span><span class="kc">null</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">nextLayer</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">MAX_LAYER</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">p</span><span class="p">)</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">curNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">nextLayer</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">curLayer</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">MAX_LAYER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">curLayer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getNext</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">curLayer</span><span class="p">).</span><span class="nx">val</span> <span class="o">&lt;=</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getNext</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">curLayer</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">curLayer</span> <span class="o">&lt;</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">curNode</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">curLayer</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">curLayer</span><span class="p">];</span>
                <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">curLayer</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curNode</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">curLayer</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">getNext</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">layer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">layer</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="nx">show</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">next</span> <span class="o">=</span> <span class="p">[</span><span class="kc">null</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="一些操作">一些操作</h1>

<h2 id="概念定义">概念定义</h2>

<p><strong>子序列</strong>： 由原数组中部分或全部元素组成的新数组，子序列中元素的先后顺序必须与原数组相同，但是元素在原数组中不必相邻。</p>

<p><strong>子数组</strong>： 由原数组中部分或全部元素组成的新数组，子数组中元素的先后顺序必须与原数组相同，而且元素在原数组中必须相邻。</p>

<h2 id="字符串操作">字符串操作</h2>

<ul>
  <li>字母转化为数值：<code>a.charCodeAt(0) - 97</code>; (97是字母a的ASCII码)</li>
</ul>

<h2 id="位运算">位运算</h2>

<ul>
  <li><strong>补码</strong>：
    <ul>
      <li>正数的补码是它本身；</li>
      <li>负数的补码，是符号位保持为<code>1</code>不变，其他位取反，然后整体再加1。</li>
    </ul>
  </li>
  <li><code>AND OR XOR</code>都满足交换律和结合律；</li>
  <li><code>(a&amp;b)^(a&amp;c) = a&amp;(b^c)</code></li>
  <li><code>x^0 = x</code></li>
  <li><code>x^x = 0</code></li>
  <li><code>&gt;&gt;</code>是带符号右移，表示移动过程中左侧空出来位置用符号位的值来填充（正数补0，负数补1）；</li>
  <li><code>&gt;&gt;&gt;</code>是无符号右移，表示移动过程中左侧空出来位置，始终用<code>0</code>来填充；</li>
  <li><code>a &amp; (-a)</code> 可以找出数字a的<strong>最低非0位</strong>；</li>
</ul>

<h2 id="bigint">BigInt</h2>

<ul>
  <li>除了比较数值大小外(<code>&gt;</code>/<code>&lt;</code>/<code>&gt;=</code>/<code>&lt;=</code>)，BigInt只能与BigInt类型进行计算；</li>
  <li>BigInt基本可以表示任意长度的整数，但仍有上界，只是非常大；</li>
  <li><strong>BigInt的位运算：</strong>
    <ul>
      <li>BigInt只有带符号左右移操作符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>；</li>
      <li>BigInt在<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的时候，不会被视作<code>32</code>位整数，而是它本身。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>因此<code>1 &lt;&lt; 32</code> 和<code>1n &lt;&lt; 32n</code>结果是不同的，<code>1n &lt;&lt; 32n</code>会返回正确的结果。</p>
</blockquote>

<h2 id="数组操作">数组操作</h2>

<h3 id="数组中随机取一个元素">数组中随机取一个元素</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">randPos</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span>
<span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">randPos</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="数组中删除一个元素">数组中删除一个元素</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="数组中动态删除元素考虑从右到左遍历">数组中动态删除元素，考虑从右到左遍历</h3>

<p>从右到左遍历，指针左侧的元素不会被动态修改，指针右侧的元素删除不影响指针的下一位置。</p>

<h3 id="浅拷贝数组">浅拷贝数组</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1.</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="c1">// 2.</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>

<span class="c1">// 3. </span>
<span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="数组sort排序">数组sort排序</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 字符串升序</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>
<span class="c1">// 字符串降序</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">().</span><span class="nx">reverse</span><span class="p">()</span>
<span class="c1">// 数字升序</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span> <span class="p">)</span>
<span class="c1">// 数字降序</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="o">-</span><span class="nx">a</span> <span class="p">)</span>
</code></pre></div></div>

<h2 id="判断变量类型">判断变量类型</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 精确返回变量类型，首字母大写</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="链表操作">链表操作</h2>

<h3 id="链表的前序后序遍历">链表的前序、后序遍历</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">iterate</span><span class="p">(</span><span class="nx">nodeHead</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nodeHead</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 这里写是前序；</span>
            <span class="nx">iterate</span><span class="p">(</span><span class="nx">nodeHead</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span>
            <span class="c1">// 这里写是后序。</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="数值操作">数值操作</h2>

<h3 id="辗转相除找最大公约数">辗转相除找最大公约数</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">num2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num1</span> <span class="p">:</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">num2</span><span class="p">,</span> <span class="nx">num1</span> <span class="o">%</span> <span class="nx">num2</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="找两数最小公倍数">找两数最小公倍数</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">LCM</span> <span class="o">=</span> <span class="nx">num1</span> <span class="o">*</span> <span class="nx">num2</span> <span class="o">/</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span><span class="nx">num2</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="寻找1--n范围内每个数的约数">寻找1 ~ n范围内每个数的约数</h3>

<p>这个算法的复杂度为<code>O(n * log_n)</code>。</p>

<p>因为内层循环执行了<code>n/1 + n/2 + ... + 1</code>次，其级数的极限为<code>log_n</code>。而外层循环执行<code>n</code>次，所以总时间复杂度为<code>O(n * log_n)</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">findDividers</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">i</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">+=</span><span class="nx">i</span><span class="p">){</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="abc集合的合集元素数目">ABC集合的合集元素数目</h3>

<p><code>|A∪B∪C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|</code></p>

<h3 id="合并区间">合并区间</h3>

<p>对于一系列闭区间组成的数组arr：<code>[[l1,r1],[l2,r2],[l3,r3]...[ln,rn]]</code>，它们之间可能无序，也可能存在嵌套，合并它们的策略是：</p>

<ol>
  <li>先按起始位置<code>l1,l2,l2.3...</code>对区间进行升序排序；</li>
  <li>声明一个left和一个right变量，用来保存当前区间的左右边界值，以及一个数组res用来保存结果；</li>
  <li>从左到右遍历区间数组（索引index从0到n-1），对每个区间<code>[l1,r1]</code>和它下一个区间<code>[l2,r2]</code>，因为排过序可知此时存在<code>l2 &gt;= l1</code>：
    <ul>
      <li>如果l2 &gt; r1，说明下一个区间和现在的区间不重合，直接把现在的结果区间<code>[left,right]</code>放入结果数组，并更新left = l2, right = r2；</li>
      <li>否则l2 &lt;= r1，说明区间存在重合：
        <ul>
          <li>此时如果r2 &lt;= r1，说明<code>[l2,r2]</code>区间被完全覆盖，此时直接跳过；</li>
          <li>如果r2 &gt; r1，此时更新新的区间右边界值right = r2；</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="最大值--m-的子数组个数">最大值 &lt;= M 的子数组个数</h3>

<blockquote>
  <p><strong>给你一个数组<code>arr</code>，请你找到内部元素最大值<code>&lt;= M</code>的子数组个数？</strong></p>

  <p><strong>例如：</strong><code>[1,5,2,3,4]</code>中最大值<code>&lt;= 3</code>的子数组有<code>[1]、[2]、[3]、[2,3]</code>，共四个。</p>

  <p>注意，子数组是连续的。</p>
</blockquote>

<p>思路：</p>

<ol>
  <li>每一个子数组都有一个结尾，我们可以通过枚举子数组结尾元素位置，来计数；</li>
  <li>对于以<code>arr[i]</code>为结尾元素的一系列子数组：
    <ol>
      <li>如果<code>arr[i]</code>本身<code>&gt; M</code>，则没有满足要求的子数组；</li>
      <li>如果<code>arr[i]</code>本身<code>&lt;= M</code>，则以<code>arr[i]</code>为结尾的满足要求的子数组个数，等于<strong>从<code>i</code>位置向前(包含<code>i</code>)满足<code>&lt;=M</code>的连续元素个数</strong>.</li>
    </ol>
  </li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">cal</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">M</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">M</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="nx">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="nx">res</span> <span class="o">+=</span> <span class="nx">cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// cal([1,5,2,3,4],3);</span>
<span class="c1">// 4</span>
</code></pre></div></div>

<h3 id="矩阵旋转">矩阵旋转</h3>

<p>一个矩阵旋转（顺时针、逆时针），可以转化成<strong>水平、垂直翻转</strong>或<strong>沿对角线翻转</strong>的组合。</p>

<ol>
  <li>如果旋转90度，可以转化为<strong>一次沿水平、垂直的翻转+一次沿对角线的翻转</strong>；</li>
  <li>如果旋转180度，可以转化为<strong>两次沿水平、垂直的翻转</strong>。</li>
</ol>

<h2 id="消除相同的数问题">消除相同的数问题</h2>
<h3 id="消除相同的两个数">消除相同的两个数</h3>

<p>可以考虑使用位运算中的<code>异或运算</code>，对完全相同的两个数进行消除。</p>

<blockquote>
  <p>异或： 位相同则返回0， 否则返回1。</p>
</blockquote>

<ul>
  <li>如果两个数 <code>a === b</code>，那么<code>a ^ b === 0</code>；</li>
  <li>任何一个数<code>a</code>，它与0异或运算后，仍然是它本身，<code>a ^ 0 === a</code>。</li>
</ul>

<h3 id="消除相同的多个数">消除相同的多个数</h3>

<p><strong>问题类型：</strong> 一个数组中，只有一个数<code>x</code>出现的次数为1，其他数都重复出现n次，请找出这个单独的数。</p>

<p>基本思路：</p>

<ol>
  <li>按位思考，对于每一个数的每一位，因为只能是1或0，对于重复出现的n个数，它们在这一位上的加和只能是<code>n</code>或<code>0</code>；</li>
  <li>所以对于除单独的数<code>x</code>外，其他的数在每一位上的加和只能是<code>nk</code> (k &gt;= 0 &amp;&amp; k &lt;= n)；</li>
  <li>考虑单独的数x，全部数在每一位上，加起来的和只能是<code>nk+1</code>或<code>nk</code>；</li>
  <li>因此，对全部数每一位进行加和，然后用<code>n</code>取余数，余数就是要找的单独数x在该位上的实际值。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span>
<span class="kd">var</span> <span class="nx">singleNumber</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">31</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="nx">n</span> <span class="o">&amp;</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">s</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">res</span> <span class="o">+=</span> <span class="nx">cur</span> <span class="o">*</span> <span class="p">(</span><span class="nx">s</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nx">cur</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="位运算判断纯字母字符串是否含有重复字母">位运算判断纯字母字符串是否含有重复字母</h2>

<blockquote>
  <p><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></p>
</blockquote>

<p>因为字母一共只有26个，使用二进制数字的每一位<code>(0~25)</code>表示一个字母，最大为<strong>2<sup>26</sup>-1</strong>不会超出JS数字上限。</p>

<p>设初始掩码为<code>mask=0</code>（全0），当字母存在时置对应位为1。具体操作为获取字母在字符串<code>abcdefghijklmnopqrstuvwxyz</code>的索引i，然后执行以下操作：</p>

<ol>
  <li><code>let cur = 1 &lt;&lt; i</code>;</li>
  <li><code>mask |= cur</code>;</li>
</ol>

<p>例如：<code>acde</code>对应的二进制掩码后五位为<code>11101</code>（其余全为0）</p>

<p>当判断字符串a与b是否有重复字母时，取a、b的掩码<code>mask_a</code>和<code>mask_b</code>，对它们执行<strong>与操作&amp;</strong>：</p>

<ul>
  <li>如果为0，则没有重复字母；</li>
  <li>否则含有重复字母。</li>
</ul>

<h2 id="取余操作">取余操作</h2>
<h3 id="对较大的幂值进行取余操作">对较大的幂值进行取余操作</h3>

<blockquote>
  <p>求<code>a ** b % mod</code>，假设 <code>a ** b</code> 是一个较大的值，超出了JS数字的表示范围。</p>
</blockquote>

<p>使用一个<code>for</code>循环即可。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">b</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">*=</span> <span class="nx">a</span><span class="p">;</span>
    <span class="nx">res</span> <span class="o">%=</span> <span class="nx">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="概率问题">概率问题</h2>
<h3 id="按照权重随机选取元素">按照权重随机选取元素</h3>

<blockquote>
  <p>给定一个权重数组<code>w</code>，每个位置<code>i</code>上的值<code>w[i]</code>代表<code>i</code>元素的权重值，目标是按照权重的大小，随机选取一个元素位置<code>t</code>。需要保证权重值越大，被选取的概率越大。</p>
</blockquote>

<p>思路：</p>

<ol>
  <li>要随机选取，一定要用到随机数API<code>Math.random()</code>，但是它只能在一个区间内均匀选取；</li>
  <li>要按照权重选取，我们需要将这些权重转化为区间长度，这样在区间内均匀随机选取一个位置，判断其在哪一个区间内，就可以实现按权重选取一个元素了；</li>
  <li>具体地：
    <ol>
      <li>从<code>0</code>开始，我们将<code>w[i]</code>转化为区间长度，则<code>i</code>位置对应的区间右边界为<code>[0,i]</code>区间内<code>w[i]</code>的前缀和，进行预计算，<code>w[i]</code>前缀和组成的数组假设为<code>pre[i]</code>；</li>
      <li>设<code>w[i]</code>的总和为<code>s</code>，则我们在<code>[0,s]</code>范围内随机均匀抽样，选取一个随机数<code>t</code>；</li>
      <li>二分查找，找到第一个<code>pre[i] &gt;= t</code>的位置<code>i</code>，则<code>i</code>是我们按权重随机选择的结果。</li>
    </ol>
  </li>
</ol>

<h3 id="使用rand7生成rand10">使用rand7生成rand10</h3>

<blockquote>
  <p>如何使用一个随机生成<code>[1,7]</code>的范围内整数的函数rand7()，实现一个在<code>[1,10]</code>均匀采样的函数rand10() ？</p>
</blockquote>

<p>这个问题更精确的描述是：使用一个较小范围的均匀随机离散点生成器，实现一个更大范围的均匀随机离散点生成器？</p>

<p>解决思路：</p>

<ol>
  <li>可以多次执行提供的随机函数，生成更多的随机结果；</li>
  <li>为保证结果是均匀的，我们不能让两次随机产生的结果互相有叠加，因为这样会让概率值发生变化；</li>
</ol>

<p>解决方法：</p>

<p>使用<code>rand7()</code>生成一个二维坐标点。</p>

<ol>
  <li>调用两次<code>rand7()</code>，分别当做横坐标<code>r</code>和纵坐标<code>c</code>；</li>
  <li><code>r</code>和<code>c</code>一共可以表示<code>7*7 = 49</code>个二维格子位置，将格子从上到下、从左到右进行编号<code>1 ~ 49</code>；</li>
  <li>计算出抽到的格子编号<code>idx</code>；</li>
  <li>因为<code>49</code>无法整除<code>10</code>，对于后面的<code>[41, 49]</code>，如果抽到，我们<strong>拒绝采样</strong>，直接重新再采样一次，直到抽到的数<code>idx &lt;= 40</code>；</li>
  <li>返回<code>（idx - 1) % 10 + 1</code>。（为了让取模后的起始点为<code>1</code>而不是零）</li>
</ol>

<p><img src="/assets/posts/rand.jpg" alt="rand" /></p>

<h1 id="小技巧-tips">小技巧： Tips</h1>

<ol>
  <li><strong>集合中选取元素组成目标和<code>tar</code></strong>的问题，可以转化为<strong>给集合中的元素添加符号</strong>的问题：
    <ul>
      <li>抽取若干元素凑成目标和：转化为在原集合中的每个元素前面添加<code>+1</code>或<code>0</code>因子；</li>
      <li>将集合中的元素，分为各自加和为目标和的两组：转化为在原集合中的每个元素前面添加<code>+1</code>或<code>-1</code>因子，使得加和结果为<code>0</code>；</li>
      <li>选取集合中的部分元素，分为各自加和相同的两组：转化为在原集合中的每个元素前面添加<code>+1</code>、<code>-1</code>或<code>0</code>因子，使得加和结果为<code>0</code>；</li>
    </ul>
  </li>
  <li>判断数组的前<code>n</code>个元素<code>arr[0] ~ arr[n-1]</code>是否<strong>与索引值一一对应</strong>（也就是元素取值范围是<code>[0, n-1]</code>）：
    <ul>
      <li>从前向后遍历原数组，记录最大值<code>max</code>，如果<code>max === i</code>，则<code>[0,i]</code>区间满足索引与元素一一对应。</li>
    </ul>
  </li>
</ol>

        </div>
    </div>

    <!-- 关键词 -->
    <div id="tagsBox">
      Keywords:
      <a id="tags" href="JavaScript"><span>JavaScript</span></a>
      
      <a id="tags" href="Algorithm"><span>Algorithm</span></a>
      
      <a id="tags" href="Data Structure"><span>Data Structure</span></a>
      </div>

</article>

<!-- 上一篇与下一篇按钮 -->
<div id="postPager">
    
    <span id="previousPost">
        <a href="/blog/2022/01/01/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/" title="数学、博弈问题">
            <img src="http://localhost:4000/assets/posts/beforeBlack.svg" alt="previousPost">
        </a>
    </span>
    

    <!-- 文章位置功能 （未实现）-->
    <!-- 
      <p id="postNumBox">Blog &nbsp; 
        <span id="postNum"></span> &nbsp; Of &nbsp; 
        <span id="postNum"></span>
      </p> -->

    
    <span id="nextPost">
        <a href="/blog/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0/" title="计算机硬件组成笔记">
            <img src="http://localhost:4000/assets/posts/nextBlack.svg" alt="nextPost">
        </a>
    </span>
    
</div>
<!-- Valine 浏览量统计 -->
<span id="/blog/2022/01/12/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="leancloud-visitors" data-flag-title="Your Article Title">
    <span>已经有 </span><i class="leancloud-visitors-count" style="color: #edebdc;">1000000</i> <span> 个小伙伴看完了这篇推文。</span>
</span>

<!-- Valine 评论框 -->
<div id="vcomments"></div>

    </main><footer>
    <div id="footerBox">
        <div id="socialBox">
            
            
            
            <a href="mailto:mars_yao@yeah.net" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-envelope"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://marswiz.com/aboutMe" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-weixin"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://github.com/marswiz" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-github"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://juejin.cn/user/131597123717319" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent2">掘</p>
                    
                </div>
            </a></div>
        <div id="webInfo">
            <p>
                <span id="beian">京ICP备 17067352 号</span>
                <span id="powered">&nbsp;Powered by <span style="font-style: italic;">Jekyll</span>. &nbsp;</span>
                <span id="copyright">Copyright © 2019 Mars. All rights reserved.</span>
            </p>
        </div>
    </div>

    <script src="http://localhost:4000/assets/js/dist/main.js" defer></script>
    <script>
        // window.addEventListener('load', postsFunc, false);
        // if (window.innerWidth <= 768) {
        //     window.addEventListener('load', loadDayNight, false);
        //     $(document).one('touchstart', loadDayNight);
        // }
    </script>

    <!-- Valine 评论 -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '5mfc7sb6aVJyKPMGY6K423B6-MdYXbMMI',
            appKey: 'Tv40sJl6jo9ac84eFi8H3ejb',
            placeholder: '- 无需注册，理性讨论.&#10;- 可使用Gravatar注册邮箱修改个人头像~&#10;- 我爱刘小宝~~',
            notify: true,
            verify: true,
            visitor: true,
            avatar: 'retro',
            serverURLs: 'https://5mfc7sb6.api.lncldglobal.com'
        })
    </script>
</footer><!-- 回到页首按钮 -->
    <a href="#mainBox" class="fa fa-rocket" id="toTop"></a>

</body>
<!-- <script>
    blogYearFunc();
    if (window.innerWidth >= 769) {
        document.querySelector('#navBlog').style.display = 'block';
    }

    window.addEventListener('resize', debounce(resize, 0.5));
</script> --></html>