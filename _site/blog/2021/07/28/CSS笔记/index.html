<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="路旁有花，心中有歌，天上有星。">
  <meta name="keywords" content="Marswiz,blog,Mars,技术博客,前端,Frontend,个人博客">
  <meta name="author" content="Marswiz"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>CSS笔记 | 个人杂记:MarsWiz</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="CSS笔记" />
<meta name="author" content="Mars" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CSS细节记录" />
<meta property="og:description" content="CSS细节记录" />
<link rel="canonical" href="http://localhost:4000/blog/2021/07/28/CSS%E7%AC%94%E8%AE%B0/" />
<meta property="og:url" content="http://localhost:4000/blog/2021/07/28/CSS%E7%AC%94%E8%AE%B0/" />
<meta property="og:site_name" content="个人杂记:MarsWiz" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-28T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"CSS细节记录","@type":"BlogPosting","url":"http://localhost:4000/blog/2021/07/28/CSS%E7%AC%94%E8%AE%B0/","headline":"CSS笔记","dateModified":"2021-07-28T00:00:00+08:00","datePublished":"2021-07-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2021/07/28/CSS%E7%AC%94%E8%AE%B0/"},"author":{"@type":"Person","name":"Mars"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="preload" href="/assets/fonts/Didot.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Clarendon_BT.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/TodaySB-CapExtLig.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/PoiretOne-Regular.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Memphis.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Folio-Light.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="stylesheet" href="/assets/main1.css?v=1.1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="个人杂记:MarsWiz" /><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Icons -->
	<link rel="shortcut icon" href = "/assets/pics/logo_cat.jpg">
	<link rel="bookmark" href = "/assets/pics/logo_cat.jpg">
	<link rel="apple-touch-icon" href = "/assets/pics/logo_cat.jpg">

  <!--  jquery  -->
  <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js" defer></script>


    <!-- Valine 评论
    <script src='//unpkg.zhimg.com/valine/dist/Valine.min.js'></script> -->
  <!-- Vconsole -->
<!--   <script src="http://localhost:4000/assets/js/vconsole.min.js"></script>
  <script>
    // init vConsole
    var vConsole = new VConsole();
    console.log('Hello world');
  </script>
   -->
  <!-- Hammer.js 移动手势操作库 -->
  <script src="http://localhost:4000/assets/js/hammer.js" defer></script>


</head>
<body><!-- 日志页导航栏结构 -->

<nav id="navBlog">


	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id="blogLogo" src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>
		<!-- 导航按钮 -->
<!--		<div id="navItems">-->
<!--			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>-->
<!--			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>-->
<!--			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>-->
<!--			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>-->
<!--			<a href="" id="projectsBtn">Projects</a>-->
<!--		</div>-->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><div id="blogBtnSprite"></div></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><div id="tagsBtnSprite"></div></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><div id="aboutMeBtnSprite"></div></a>
			<a id="searchBtn" href="http://localhost:4000/search"><div id="searchBtnSprite"></div></a>
			<a href="http://localhost:4000/projects" id="projectsBtn"><div id="projectsBtnSprite"></div></a>
		</div>

		<!-- 移动端按钮 -->
		<div id="navItemsBtnMobile">
			<span class="fa fa-bars"></span>
		</div>
	</div>



</nav>
<!-- 日志页移动端导航栏结构 -->

<nav id="navMobile">
	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>

		<!-- 导航按钮 -->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>
			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>
			<a id="projectsBtn" href="http://localhost:4000/projects"><img src="http://localhost:4000/assets/nav/projectBlack.svg" alt="project"></a>
		</div>
		<div id="changeDayNight" class="fa fa-lightbulb-o"></div>
	</div>
</nav>
<main id="mainBox" aria-label="Content">

        <!-- 移动端页面标题 -->
        <!--   <a id="logoBoxBlog" href="/">
      <img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
    </a> -->
        <!--  -->
        <span id="pIdentifier" style="display: none;">中文缩进</span>
<span id="baseURLIdentifier" style="display: none;">http://localhost:4000</span>
<article id="postBox">

    <!-- 标题和日期 -->
    <header id="postHeader">
        <h1 id="postTitle">CSS笔记</h1>
        <p id="postInfo">
            Posted by<span id="postAuthor"> Mars </span>. Modified at
            <time id="postTime">Jul 28, 2021
            </time>
        </p>
    </header>

    <div id="postContentBox">
        <!-- 标题headerIndex导航 -->
        <div id="headerIndex"></div>

        <!-- 内容主体 -->
        <div id="postContent">
            <blockquote>
  <p>CSS细节记录</p>
</blockquote>

<h1 id="二主要内容">二、主要内容</h1>
<h2 id="21-特指度继承和层叠关系">2.1 特指度、继承和层叠关系</h2>
<h3 id="211-css特指度">2.1.1 CSS特指度</h3>

<p>CSS特指度由4位构成<code>比如(0,0,0,0)</code>，可以认为是个十百千四位。越靠左优先级越高。</p>

<p>每存在一个选择器，总的CSS特指度按选择器权重增大。各选择器权重如下：</p>

<ul>
  <li>行内声明（元素的style属性）：<code>(1,0,0,0)</code>；</li>
  <li>Id选择器： <code>(0,1,0,0)</code>；</li>
  <li>类、伪类：<code>(0,0,1,0)</code>；</li>
  <li>元素、伪元素：<code>(0,0,0,1)</code>；</li>
  <li>通用选择器（*）的特指度为0：<code>(0,0,0,0)</code>;</li>
  <li>连接符（如：&gt;、+等）和<strong>继承的属性没有特指度</strong>。（区别于0，它们没有特指度，相当于比0还要小）</li>
</ul>

<p>如果两个选择器选择了同一个元素，特指度更大的将胜出（被应用）。</p>

<blockquote>
  <p>末尾带有!important的声明单独进行比较，同样遵循特指度优先规则。</p>

  <p>带有!important和不带的CSS规则进行比较，始终是带！important的规则胜出。</p>
</blockquote>

<h3 id="212-css属性继承">2.1.2 CSS属性继承</h3>

<p>CSS属性一般只会父传后代，不会向上传播。（特例是body元素的背景属性，可以向上传播给html根元素。）</p>

<p>不继承的CSS属性：</p>

<ul>
  <li>边框属性；</li>
  <li>盒模型相关属性；</li>
</ul>

<p>继承的属性，没有特指度，连0也没有。（弱于通配选择器*）</p>

<h3 id="213-css的层叠关系">2.1.3 CSS的层叠关系</h3>

<p>CSS的层叠关系，也就是谁的优先级更高，相互之间的覆盖关系。</p>

<p>CSS的层叠关系有以下几个影响因素：</p>

<ul>
  <li><strong>显式权重</strong>：有无<code>!important</code>标记；（带有!important的比没有的优先级更高）</li>
  <li><strong>来源</strong>： 内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式；</li>
  <li><strong>特指度：</strong> 同上节；</li>
  <li><strong>声明顺序：</strong> CSS语句的声明前后顺序。（后声明的覆盖前面声明的）</li>
</ul>

<blockquote>
  <p>因为有层叠关系，超链接的CSS伪类推荐声明顺序： LVFHA （link -&gt; visited -&gt; focus -&gt; hover -&gt; active）</p>
</blockquote>

<h2 id="22-css函数">2.2 CSS函数</h2>
<h3 id="221-calc函数">2.2.1 calc()函数</h3>

<p>calc()用于进行简单的数学计算。它的使用有如下<strong>几点限制</strong>：</p>

<ul>
  <li>+和-号两边必须是同一单位类型，或者都是数字；</li>
  <li>*号两边必须有一个是数字，不能都是带单位的值；</li>
  <li>/号右边必须是数字，左边可以是数字也可以是带单位的值；</li>
  <li>任何情况下都不能除以0；</li>
  <li>+和-号两边必须有空格，因为要与正负数区分开。</li>
</ul>

<h3 id="222-attr函数">2.2.2 attr()函数</h3>

<p>attr()函数，用于获取CSS选择的元素上的某一个属性值。（比如id属性）</p>

<blockquote>
  <p>attr()目前仅支持在伪元素的content属性里使用，用于获取元素的某一属性作为字符串显示在伪元素中。</p>
</blockquote>

<h1 id="23-css自定义变量">2.3 CSS自定义变量</h1>

<p>使用<code>--</code>开头可以自定义一个CSS变量，它的作用和特性如下：</p>

<ul>
  <li>在后面可以使用var()函数引用这个变量，作用仅是把变量值替换到当前位置；</li>
  <li>变量名称一般根据作用定义，尽量使用带有短横线连接的变量名；</li>
  <li>变量名大小写敏感；</li>
  <li><strong>自定义变量具有作用域</strong>。</li>
</ul>

<h2 id="24-css的规则">2.4 CSS的@规则</h2>
<h3 id="241-css特性查询">2.4.1 CSS特性查询</h3>

<p>使用<code>@supports(&lt;css&gt;){&lt;css&gt;}</code>语法可以对不同的CSS支持情况，编写不同的CSS。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 仅支持color:black;的情况，才添加如下CSS */</span>
<span class="k">@supports</span> <span class="p">(</span><span class="n">color</span><span class="p">:</span><span class="no">black</span><span class="p">)</span> <span class="p">{</span>
    <span class="nt">body</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="no">black</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="242-font-face">2.4.2 @font-face</h3>

<p>用于使用自定义字体。可以指定一个服务器上的字体，然后用户在读取到这个声明的时候会下载这个字体文件，用于渲染页面。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@font-face</span> <span class="p">{</span>
    <span class="nl">font-family</span><span class="p">:</span> <span class="s2">'Good'</span><span class="p">;</span>
    <span class="nl">src</span><span class="p">:</span> <span class="sx">url("good.otf")</span> <span class="n">format</span><span class="p">(</span><span class="s2">'opentype'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>对于浏览器，无论是否使用声明的字体，都会进行下载。</p>
</blockquote>

<p>@font-family中两个属性是必须的：</p>

<ul>
  <li>font-family: 给要引入的字体起个名；</li>
  <li>src: 字体的位置。</li>
</ul>

<blockquote>
  <p>src中指定的字体文件位置，必须是同源的。</p>

  <p>也可以设置多个用逗号分隔的列表，用于提供备用字体文件下载。</p>
</blockquote>

<p>使用@font-face，在字体没加载完成前，会使用默认字体显示，然后在加载完成后瞬间替换成自定义字体。如果二者字形大小相差过大，会导致页面重新布局，影响性能。</p>

<h2 id="25-视觉格式化">2.5 视觉格式化</h2>
<h3 id="251-容纳块">2.5.1 容纳块</h3>

<blockquote>
  <p>容纳块由离元素最近的生成<strong>块级框</strong>或<strong>列表项目</strong>的祖辈元素的边界构成。</p>
  <blockquote>
    <p>—《CSS权威指南》</p>
  </blockquote>
</blockquote>

<p>容纳块是元素布局的参考基础。比如计算width等的百分比。</p>

<ul>
  <li>body元素的容纳块是html元素；</li>
  <li>html元素对应的容纳块，叫初始容纳块。它由的宽度等于视口的宽度，高度初始为0。</li>
  <li>内部框的左右外边界间距（content-box宽度+内边距+边框+外边距），永远等于容纳块的content-box宽度；</li>
</ul>

<h3 id="252-块级框模型">2.5.2 块级框模型</h3>

<p><img src="/assets/posts/23.png" alt="box" /></p>

<p>块级元素内部格式化基本原理：</p>

<p><strong>横向</strong>：</p>

<ul>
  <li>核心条件：左右外边界间距（content-box宽度+内边距+边框+外边距），永远等于容纳块的content-box宽度；</li>
  <li><strong>只有margin和width可以设置为auto（自动计算），其他横向属性(padding、border)不能，只能设置为0或具体值；</strong></li>
  <li><strong>只有外边距可以为负值，其他都不可以；</strong></li>
  <li>块级元素的width设为百分数，基准于容纳块的内容框content-box的宽度；</li>
  <li>如果两边margin都设为auto，则两外边距平分，值相等；</li>
  <li><strong>横向外边距永远不发生折叠</strong>；</li>
  <li>置换元素（比如img），设置width为auto时，会自动设置为内部元素（图片）的宽度的100%；</li>
</ul>

<p><strong>纵向</strong>：</p>

<ul>
  <li>当设定块高度小于实际内容的高度时，行为取决于overflow属性的设置；</li>
  <li>相邻的<strong>纵向外边距</strong>会发生折叠；</li>
  <li>正外边距折叠时，结果取二者之间较大值。 负外边距折叠时，结果取负的绝对值较大的那个，然后用正外边距与它相加得到结果。</li>
  <li><strong>内边距和边框，不与任何区域发生折叠；</strong></li>
  <li>当设定块height为自动计算(auto，默认):
    <ul>
      <li>如果<strong>没有为块设置边框、内边距（或者设置了宽度为0的内边距、边框宽度）</strong>，块的高度由子元素撑开，默认为：子代块级元素中<strong>最上面的上边框外侧</strong>到<strong>最下面的下边框外侧</strong>（内部元素外边距与外部父元素外边距折叠）；</li>
      <li>如果父元素设置了<strong>非0宽度边框、内边距</strong>，则块的高度为：子代块级元素中<strong>最上面的上边距外边界</strong>到<strong>最下面的下边距外边界</strong>（有东西隔开，子元素外边距与父元素不发生折叠）；</li>
    </ul>
  </li>
  <li>当height设为百分数时，基准于容纳块<strong>显式设置的高度</strong>。如果容纳块的高度是auto，则百分数没有效果，退化为auto。</li>
</ul>

<h3 id="253-box-sizing-块模型修改">2.5.3 box-sizing 块模型修改</h3>

<p>box-sizing属性只能用于块级元素，作用是设定块级元素的盒模型类型。（标准盒模型、怪异盒模型）</p>

<p><strong>本质上是设定了width和height属性，约束的是哪一个框。</strong></p>

<ul>
  <li>content-box（默认）：width和height都约束内容框（内边距内界以里）的尺寸；</li>
  <li>border-box: width和height都约束边框框（边框外界以里）的尺寸，内边距从里面扣除，扣除后部分才是内容框；</li>
</ul>

<h3 id="254-行内元素模型">2.5.4 行内元素模型</h3>

<p><img src="/assets/posts/24.png" alt="inline-box" /></p>

<p>行内元素内部格式化基本原理：</p>

<ul>
  <li>行内元素内部可以划分为：内容区、行内框；</li>
  <li>非置换元素（比如span）的内容区，等于<strong>字体框的合集区域</strong>；</li>
  <li>置换元素（比如img）的内容区，等于<strong>置换元素内容本身+内边距+边框+外边距的合集区域</strong>；</li>
  <li>行距 = line-height - font-size；</li>
  <li>非置换行内元素的行内框高度由line-height属性决定，非置换元素的行内框高度 = line-height = 内容区高度 + 行距；（因为行距可正可负，所以行内框可以大于内容框高度，也可以小于）</li>
  <li>置换元素的行内框高度 = 内容区高度；</li>
  <li>行内框在行中纵向如何对齐，用vertical-align属性设定，这也决定着行框的高度；</li>
  <li><strong>内边距、外边距和边框，都不影响行内非置换元素的行内框高度，因此也不对当前行框高度产生影响；</strong></li>
  <li>行的高度（行框高度），由一行内各元素（置换、非置换）的行内框<strong>最高点和最低点之差</strong>决定；</li>
</ul>

<p><strong>确定一行的行框高度</strong>步骤：</p>

<ol>
  <li>非置换元素：根据line-height与font-size之差计算行距，然后除以2，分别添加在字体框的上部和下部；</li>
  <li>置换元素：将纵向的padding、border和margin与height相加即为内容区高度；</li>
  <li>非置换元素的基线是内部字体的基线，置换元素的基线相当于是内容区的底边；</li>
  <li>根据各元素的vertical-align设置，按各自方法进行纵向对齐；</li>
  <li>找到最高点和最低点，二者就是行框的上界和下界，行框高度是二者之差；</li>
</ol>

<h3 id="255-行内块级元素-inline-block">2.5.5 行内块级元素 inline-block</h3>

<p>行内块级元素(display:inline-block;)，对外部其他元素与行内框相同，对其内部内容它本身视作块级元素。</p>

<h2 id="26-内外边距边框和轮廓">2.6 内外边距、边框和轮廓</h2>
<h2 id="261-内外边距">2.6.1 内外边距</h2>

<ul>
  <li><strong><code>★★★</code></strong>内、外边距如果使用百分数定义，它相对的是<strong>父元素内容区的宽度</strong>；</li>
  <li>内外边距不影响行内非置换元素的行内框高度，也不影响这个元素所在行的行高；</li>
</ul>

<h3 id="262-边框相关">2.6.2 边框相关</h3>

<ul>
  <li><strong>默认情况下，背景延伸到边框的外边界；</strong>（通过<code>background-clip</code>可以设置）</li>
  <li>边框颜色默认为当前元素文字的颜色；</li>
  <li>边框的样式默认是none，也就是没有样式；</li>
  <li><strong>边框样式为none时，边框完全不存在，边框的宽度也会自动置为0</strong>（而不是显示一个透明的带宽度的边框）；</li>
  <li>边框样式 hidden 等价于 none;</li>
  <li>边框宽度只能是thin / thick / medium / &lt;length&gt;，<strong>不能是百分数</strong>。</li>
</ul>

<h4 id="2621-图像边框">2.6.2.1 图像边框</h4>

<p>待补充。</p>

<h3 id="263-轮廓">2.6.3 轮廓</h3>

<ul>
  <li>轮廓绘制在边框的外侧，紧贴边框；</li>
  <li><strong>轮廓不占空间，对布局没有任何影响，只是视觉上的效果</strong>；</li>
  <li>轮廓不能单独设置一侧，只能四周同时设置；</li>
  <li>轮廓可以不是矩形，在行内元素换行之后，可能形成只沿着外围的独特形状；</li>
</ul>

<p><img src="/assets/posts/25.png" alt="25" /></p>

<h2 id="27-背景">2.7 背景</h2>

<h3 id="271-几个分开的属性和合并属性">2.7.1 几个分开的属性和合并属性</h3>

<ul>
  <li>
    <p>分开的属性：</p>

    <ul>
      <li><strong>background-color</strong>: 设置最底层背景的背景色；</li>
      <li><strong>background-image</strong>: 设置背景图片url，或各种<strong>渐变</strong>；</li>
      <li><strong>background-position</strong>:
        <ul>
          <li>取值：<strong>长度、百分数</strong>或<strong>关键词(left,right,top,bottom,center)</strong>；</li>
          <li>计算基准是：<strong><code>background-origin</code>属性所设定边框的左上角；</strong></li>
          <li>可以定义一对值，先横坐标后纵坐标；</li>
          <li>百分数表示：<strong>将背景图的当前坐标百分数位置线，与元素的对应坐标百分数位置对齐；</strong></li>
          <li>可以混用百分数和长度值。</li>
        </ul>
      </li>
      <li><strong>background-size</strong>:
        <ul>
          <li>关键字：<strong>cover、contain</strong>;</li>
          <li>长度值：一对长度值定义背景大小；</li>
          <li>百分数：根据background-origin定义的元素区域计算；</li>
          <li>auto：根据背景宽高比自动计算，如果没有宽高比，则使用元素本身的尺寸值。</li>
        </ul>
      </li>
      <li><strong>background-repeat</strong>: 定义背景是否可以重复；</li>
      <li><strong>background-attachment</strong>:
        <ul>
          <li>scroll（默认）: 元素内容滚动时，背景图始终在元素可见区域的固定位置；</li>
          <li>local: 元素内容滚动时，背景图相对元素内容固定，因此背景图随着元素可见区域滚动而滚动；</li>
          <li>fixed: 元素相对于当前视口固定，设置这个值，background-position的定位基准也会被设置为视口；</li>
        </ul>
      </li>
      <li><strong>background-clip</strong>: 定义背景的绘制区域，只负责裁剪背景的显示区域；(<code>默认是border-box</code>，可以设为content-box、padding-box)</li>
      <li><strong>background-origin</strong>: 定义背景的定位区域，也就是<strong>background-position参考的基准</strong>（<code>默认是padding-box</code>，可以设为content-box、border-box）；</li>
      <li><strong>background-origin的默认值是padding-box，而background-clip的默认值是border-box!</strong></li>
    </ul>
  </li>
  <li>
    <p>合并属性：<strong>background</strong></p>
    <ul>
      <li>同时设定background-position和background-size，必须用/号隔开，顺序是<code>&lt;position&gt;/&lt;size&gt;</code>;</li>
      <li>同时设定background-origin和background-clip，顺序是先origin后clip。</li>
      <li>其他属性顺序随意。</li>
    </ul>
  </li>
</ul>

<h2 id="28-浮动">2.8 浮动</h2>

<h3 id="281-浮动元素的特点和排布规则">2.8.1 浮动元素的特点和排布规则</h3>

<ul>
  <li>浮动元素<strong>脱离原来的文档流，原来占据的位置也消失</strong>；</li>
  <li>浮动元素的<strong>外边距不折叠</strong>；</li>
  <li><code>★★★</code>任何元素浮动后，都会变成<strong>块级元素</strong>；</li>
  <li>浮动元素的容纳块，与普通块级元素一样，是距离最近的块级祖先元素；</li>
  <li>行内框与浮动元素重叠，<strong>行内框的一切都在浮动元素之上渲染</strong>；</li>
  <li>块级框与浮动元素重叠，<strong>块级框的背景和边框在浮动元素之下渲染，内容在浮动元素之上渲染</strong>。</li>
  <li>△浮动元素如果不是置换元素，应该显式地设置宽度，否则浮动后元素宽度可能趋近于0；</li>
</ul>

<p>浮动元素的几个排布规则：</p>

<ol>
  <li>浮动元素左、右边界，都不会超过容纳块的左右内边界（内边距内界）；</li>
  <li>浮动元素之间不会相互遮盖、重叠；</li>
  <li>浮动元素的顶边，不会超过元素浮动之前所在的行框的顶边；</li>
  <li>浮动元素沿着浮动方向，尽量移动到更远的位置。</li>
  <li>从左到右排布的行内元素，如果全部添加右浮动，顺序会反转。</li>
</ol>

<h3 id="282-清除浮动">2.8.2 清除浮动</h3>

<p>clear属性可以设置为: left/right/both/none(默认)。</p>

<p>用来保证在当前元素的左（右）侧不出现浮动的元素，如果出现就把元素向下移动直到离开浮动元素的位置。</p>

<blockquote>
  <p><strong>注意</strong></p>

  <p>清除浮动的本质，是在当前元素外边距之外添加间隙(clearance)。如果需要向下移动50px才能离开左（右）侧的浮动元素，而元素上外边距为0，那么元素上方就会添加50px的间隙来实现清除浮动的效果。</p>

  <p>当元素本身存在上外边距，比如20px，那么浏览器只会添加30px的间隙，就足以使元素清除浮动。这样在完成清除浮动之后，元素设置的20px上外边距看起来好像消失了，元素的上边框外界紧贴着浮动元素。</p>
</blockquote>

<h3 id="283-定义浮动形状">2.8.3 △定义浮动形状</h3>

<ul>
  <li>shape-outside：使用图像或者一个基本形状来定义元素的浮动形状，也就是外部文字围绕的形状，默认是浮动元素外边距外界的矩形；</li>
  <li>shape-image-threshold：浮动形状为带透明度的图像时，定义文字可穿过的透明度阈值；</li>
  <li>shape-margin: 为浮动形状添加外边距；</li>
</ul>

<h2 id="29-定位">2.9 定位</h2>

<h3 id="291-各种定位形式的容纳块确定">2.9.1 各种定位形式的容纳块确定</h3>

<p>容纳块是确定定位位置的基准元素。定位相对于<strong>容纳块的左上角点</strong>。</p>

<ul>
  <li><strong>static、relative</strong>: 最接近的祖先块级（包括inline-block）元素的内容区(content-box)；</li>
  <li><strong>absolute</strong>:
    <ul>
      <li>容纳块是最接近的position属性不为static的祖先元素（块级或行内），如果没有这样的元素，那么容纳块是初始容纳块，也就是html元素；</li>
      <li><code>★★★</code>当找到的<strong>祖辈元素是块级元素</strong>，容纳块是它的<strong>内边距外界组成的框（padding-box）</strong>；</li>
      <li>当找到的<strong>祖辈元素是行内元素</strong>，容纳块是它的<strong>内容边界</strong>（顶边底边由行框上下界组成，左边为第一个元素左边，右边为最后一个元素的右边界）；</li>
    </ul>
  </li>
  <li><strong>fixed</strong>: 容纳块为视口；</li>
  <li><strong>sticky</strong>：定位基准是最近的<strong>可滚动父元素</strong>，top、bottom、left和right定义的是相对定位基准四个边的偏移量。</li>
</ul>

<h3 id="292-偏移属性topbottomleft和right">2.9.2 偏移属性：top、bottom、left和right</h3>

<ul>
  <li><strong>left、right设置百分数相对于容纳块的宽度，top和bottom设置百分数相对于容纳块的高度</strong>；</li>
  <li>对于绝对定位，如果四个偏移值都设定了值，无需设定width和height（auto），元素的宽高会自动按照约束的区域计算；</li>
  <li>定位元素横向格式化： left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 容纳块宽度；</li>
  <li>当横向过约束时，right的值会被忽略，替换为auto；</li>
  <li>当纵向过约束时，bottom的值会被忽略，替换为autox;</li>
</ul>

<h3 id="293-定位是否保留原文档占位">2.9.3 定位是否保留原文档占位</h3>

<ul>
  <li>absolute、fixed定位，元素从源文档中脱离，源文档中不再占有位置；</li>
  <li>其他定位方式，元素虽然可能不显示在原位置，但是在源文档中仍占位。</li>
</ul>

<h3 id="294-z轴位置z-index">2.9.4 z轴位置：z-index</h3>

<p>z-index属性<strong>只能用于position不为static的元素，或者是flex、grid布局中的元素</strong>。</p>

<ul>
  <li>z-index可正可负；</li>
  <li>声明了z-index的元素，会创建自己的<strong>堆叠上下文</strong>，它的后代元素会在这个堆叠上下文中进行比较排列；</li>
  <li>在同一个堆叠上下文中，z-index值越大，显示越靠前；</li>
  <li><strong>子元素永远显示在父元素前面；</strong></li>
  <li><strong>z-index默认为auto，相当于z-index=0。</strong></li>
</ul>

<h3 id="295-粘滞定位">2.9.5 粘滞定位</h3>

<ul>
  <li>粘滞定位的定位基准最近的<strong>可滚动（有滚动条）的父元素</strong>；</li>
  <li>粘滞定位的top、bottom、left和right设置的不再是元素的位置，而是容纳块四个边的位移（正数向里，负数向外）；</li>
  <li>设置了粘滞定位的元素，在滚动过程中，遇到四个位置属性不为auto的边，则粘附在这个边上；</li>
</ul>

<h2 id="210-弹性盒布局">2.10 弹性盒布局</h2>

<p>Flex布局相对比较熟悉，记录一些特殊知识点：</p>

<ul>
  <li>Flex布局的目的是实现一维布局，最适合沿一个方向布局内容；</li>
  <li>使用writting-mode、direction或text-orientation改变文字书写模式，Flex布局的主轴会随之自动改变；</li>
  <li>弹性容器的直接子代自动变成弹性元素，不论是子元素还是文本节点；</li>
  <li><strong>弹性容器的外边距与它内部弹性元素的外边距不折叠；</strong></li>
  <li>弹性元素的特点：
    <ul>
      <li><strong>弹性元素彼此之间，外边距不折叠；</strong></li>
      <li>float和clear属性对弹性元素无效；</li>
      <li>vertical-align对弹性元素没有影响，只用于设定弹性元素中文本的对齐方式；</li>
      <li>弹性元素中的绝对定位元素：
        <ul>
          <li>绝对定位弹性元素依然会被从文档流移除；</li>
          <li>容纳块是弹性容器；</li>
          <li>绝对定位弹性元素不参与弹性布局，因为他们已经不在文档流中；</li>
          <li>仍然受弹性容器上CSS属性的影响；</li>
        </ul>
      </li>
      <li>flex是flex-grow、flex-shrink、flex-basis属性的简写属性（设置顺序必须是grow/shrink/basis）；</li>
      <li>弹性元素的属性强烈建议<strong>一直用flex缩写属性定义，不要分开来写</strong>，flex只对弹性元素有效；</li>
      <li>min-width这类尺寸限制属性对弹性元素有影响，弹性元素尺寸需要优先满足它们约定的条件；</li>
      <li>弹性元素的尺寸由flex属性中的<strong>弹性基准flex-basis决定</strong>
        <ul>
          <li>★ 如果弹性元素上既没设置flex，也没设置flex-basis，那么它的弹性基准值<strong>默认为auto</strong>;</li>
          <li>★ 如果弹性元素上设置了flex但没显式设置第三个值flex-basis，弹性基准这时<strong>默认为0</strong>；</li>
          <li>如果flex中设定弹性基准flex-basis为一个特定的长度或百分比（基准为弹性容器主轴长度），那么width（纵向则是height）会被忽略，以弹性基准为主；</li>
          <li>如果flex中设定弹性基准为auto，则以设定的非auto的width值为尺寸；</li>
          <li>如果基准和width都为auto，则基准值等同于content关键字，意味着是容纳弹性元素内容的最小尺寸。</li>
        </ul>
      </li>
      <li>flex-grow: 弹性容器中多余的空间，按各元素的flex-grow比例分配给各个弹性元素；（默认为0，必须是正数）</li>
      <li>如果flex中设定的（显式或默认）弹性基准为0，而且各元素的flex-grow也为0的话，各元素的宽度是自身可正好容纳内容的最小宽度（而不是0宽度）；</li>
      <li>flex-shrink: 超过弹性容器长度，按照设定的缩小因子缩放各弹性元素，具体公式如下：（默认为1，必须是正数）</li>
      <li><img src="/assets/posts/26.png" alt="缩小公式" /></li>
      <li>flex属性有几个关键字可以设置：
        <ul>
          <li>initial: 默认值，元素只能缩小不能放大。相当于flex: 0 1 auto;</li>
          <li>auto: 元素既可以缩小也可以放大，相当于flex: 1 1 auto;</li>
          <li>none: 完全没有弹性的弹性元素。相当于flex: 0 0 auto；</li>
          <li>&lt;number&gt;: 只提供一个单独的数字，默认为flex-grow值。此时相当于flex: <number> 0 0;
</number>            <ul>
              <li>这种情况相当于为每个弹性元素，设置了它在弹性容器中占容器长度的比例。因为元素弹性基准都为0，相当于总尺寸也为0，容器全部是空余长度，按设置的flex-grow分配给各弹性元素。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>order属性：设置弹性元素在弹性容器轴上显示的顺序：
        <ul>
          <li>小的在前，大的在后，可以为负值；</li>
          <li>同样order值的元素，按在源代码中出现的先后顺序排列；</li>
          <li>order<strong>纯粹是视觉上的排列效果变化</strong>，Tab键的索引和屏幕阅读器<strong>依然按照源代码顺序检索</strong>。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="211-栅格布局">2.11 栅格布局</h2>

<p>栅格布局用于定义二维平面网格，并方便把元素边界与网格线对齐。</p>

<p><img src="/assets/posts/27.png" alt="栅格布局" /></p>

<ul>
  <li>栅格布局由声明<code>display:grid</code>开启，这样声明的元素是一个栅格容器；</li>
  <li>栅格容器为它的内容定义一个<strong>栅格格式化上下文</strong>，栅格容器的子元素是栅格元素；</li>
  <li><strong>栅格容器外边距与它内部栅格元素的外边距不折叠</strong>；</li>
  <li>栅格元素上float和clear属性无效；</li>
  <li>vertical-align对栅格元素没有影响，只用于设定弹性元素中文本的对齐方式；</li>
  <li>栅格容器和其内部定义的栅格线外界不一定重合，栅格容器只是为内部栅格定义提供一个尺寸基准，以及为文档流中其他外部元素提供栅格容器的尺寸；</li>
  <li>栅格元素按照栅格线划分的栅格单元排布，所以可能会超出栅格容器显示，超出部分不会对文档中的其他元素排布产生影响，只是覆盖；</li>
  <li>栅格元素全部包含在栅格区域中，栅格区域包含的边界是元素的外边距外界；</li>
  <li>grid-template-rows、grid-template-columns定义栅格轨道宽度，也用于放置栅格线：
    <ul>
      <li>轨道宽度之间用空格分开，轨道宽度两侧可以定义栅格线名称，用方括号括起来; <code>[col1] 1em [col2] 1em [col3]</code></li>
      <li>轨道宽度可以有几种表示方式：
        <ul>
          <li><strong>百分数：</strong> 按行和列区分，分别相对于栅格容器的height和width；</li>
          <li><strong>长度：</strong> 固定的轨道宽度；</li>
          <li><strong>最小最大值范围：</strong> minmax(min, max)， 如果最大值比最小值小，则设定最小值的固定宽度轨道。最小值部分不能使用fr单位，会导致整个声明失效;</li>
          <li><strong>分配余下空间</strong>： fr为单位，1fr为平均分配1份；</li>
          <li><strong>关键字</strong>：
            <ul>
              <li>min-content: 根据内容设置轨道宽度，尽量缩短每个内容的宽度，然后轨道宽度设为整个轨道中最窄的内容宽度；</li>
              <li>max-content: 尽量放宽每个内容的宽度，然后轨道宽度设为整个轨道中最宽的内容宽度。</li>
              <li>fit-content(arg): 适应内容宽度。
                <ul>
                  <li>当 min &lt; arg &lt; max: 宽度为arg;</li>
                  <li>当 arg &lt; min &lt; max: 宽度为min；</li>
                  <li>当 mim &lt; max &lt; arg: 宽度为max。</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><strong>重复定义：</strong> repeat(times / autofill / autofit, pattern);
            <ul>
              <li>重复函数中不能再嵌套重复函数；</li>
              <li>重复函数中的patten如果有栅格线，首尾连接的栅格线将合二为一，这个栅格线具有两个名称；</li>
              <li><strong>自动填充autofill</strong>：<code>repeat(autofill, 1em)</code>代表使用1em宽度，自动填充剩余的空间直到无法填充为止，不论是否有栅格空间中是否有元素；</li>
              <li><strong>自动填充autofit</strong>：<code>repeat(autofit, 1em)</code>代表使用1em宽度自动填充，如果没有元素填满栅格空间，就去掉这个自动填充的空间。</li>
            </ul>
          </li>
          <li>不同单位可以混用。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>grid-template-areas: 定义栅格区域
    <ul>
      <li>按照栅格顺序，每一行用一个字符串表示；</li>
      <li>每一列之间用空格隔开，用一个字母序列代表这个栅格单元所属的区域；</li>
      <li>空单元用一个或多个 <strong>.</strong> 表示；</li>
      <li>相同的字符串指向的区域，合并成为一个栅格区域，栅格区域必须是矩形；</li>
      <li>例如：grid-areas: “a b b c” “. b b .”；</li>
      <li>命名的栅格区域，它的行、列方向起止栅格线都隐式添加了名称，分别为name-start和name-end，行和列栅格线命名空间不冲突。</li>
    </ul>
  </li>
  <li>grid-row、grid-column：用于栅格元素。为栅格元素指定栅格区域（绑定元素边界到某一条栅格线）
    <ul>
      <li>grid-row-start、grid-row-end、grid-column-start、grid-column-end用来指定四个边界的栅格线；</li>
      <li>绑定栅格线，可以使用栅格线序号（从1开始），也可以使用栅格线名称，或者是栅格区域名称；</li>
      <li>使用栅格线序号，如果起始序号大于终止序号（在终止线之后），则系统自动默认对调二者；</li>
      <li>使用span+number，可以指定栅格元素跨越的栅格单元数目。如果span后面没有数字，则默认为1；</li>
      <li>span+number形式定义跨越单元数目，可以用在起始线，也可以用在终止线，方向都是向确定的边界的相反方向；</li>
      <li>span+number中number可以是负值，表示相反方向跨越计数；</li>
      <li>如果使用栅格线名称，同时有多条线用了同一个名称，则需要在名称后面加上空格隔开的序号n，表示是第几个同名栅格线；</li>
      <li><code>span number &lt;col-name&gt;</code> 也是有效的语法，表示跨越number个col-name栅格线；</li>
      <li>如果是栅格区域名称，则根据起始还是终止线，自动识别区域的-start和-end线；</li>
      <li>grid-row、grid-column是简写属性，start和end栅格线定义用/号隔开，前面是起始线定义，后面是终止线定义；</li>
      <li>如果设置的栅格线超出定义范围，则生成<strong>隐式栅格</strong>：
        <ul>
          <li>如果设置的栅格线名称不存在，则在该方向末尾添加一个这个名称的栅格线，然后把边界绑定到它；</li>
          <li>如果设置的栅格线序号超出定义范围，则根据序号大小自动生成若干栅格线，直到序号被覆盖；</li>
          <li>隐式增加栅格线的轨道宽度，受grid-auto-rows或grid-auto-columns影响；</li>
          <li>隐式栅格是一种回落机制，一般最好不要使用。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>grid-area：直接指定栅格元素的栅格区域
    <ul>
      <li>直接使用栅格区域名称，则元素四个边界自动绑定到这个区域的对应边界；</li>
      <li>也可以用row-start/col-start/row-end/col-end这种形式显式定义四个边界的具体栅格线，方向比较奇怪，是<strong>从上边界开始的顺时针方向</strong>；</li>
    </ul>
  </li>
  <li>栅格流：
    <ul>
      <li>如果不指定栅格元素的位置（绑定边界），栅格元素按照默认的栅格流顺序，依次放入栅格单元中；</li>
      <li>如果放不下，则自动创建轨道，用于放置多出来的栅格元素；</li>
      <li>grid-auto-flow设置默认的放置顺序：
        <ul>
          <li>row（默认）: 按行放置；</li>
          <li>column：按列放置；</li>
          <li>可以附加dense关键字，表示紧凑布局，也就是无视元素原来的先后顺序，尽量铺满整个栅格。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>grid-auto-rows、grid-auto-columns: 自动添加的轨道宽度
    <ul>
      <li>设置自动创建的轨道宽度，可以是固定值，或者fr值，或者<code>minmax()</code>；</li>
    </ul>
  </li>
  <li>grid：定义栅格模板的缩写形式
    <ul>
      <li>基本形式是： <code>&lt;row&gt; / &lt;column&gt;</code> （具体语法复杂，查书）;</li>
      <li><strong>grid属性会把其他所有未设置的值，重置为auto</strong>，因此需要把grid属性写在所有其他属性的最前面；</li>
    </ul>
  </li>
  <li>gap: 设置栏距
    <ul>
      <li>栏距基本上可以看做把栅格线加宽，让栅格单元之间留有距离；</li>
      <li>栏距不占栅格单元的空间（除非是以fr定义的宽度，栏距计入在栅格总宽度里，剩余的宽度才会分配给fr定义的区域）；</li>
    </ul>
  </li>
  <li>对齐方式：
    <ul>
      <li>justify-items、align-items： 元素在栅格区域内的行、列方向对齐方式；</li>
      <li>justify-content、align-content： 整个栅格在栅格容器中的行、列方向对齐方式；</li>
      <li>justify-self、align-self：用于栅格元素。表示栅格元素单独在栅格区域内的对齐方式。</li>
    </ul>
  </li>
  <li>分层、排序：
    <ul>
      <li>默认按文档源码中的先后顺序分层：<strong>后者在上，前者在下；</strong></li>
      <li>使用z-index也可以显式修改分层顺序；</li>
      <li>使用order可以设置栅格元素的排列顺序（尽量不用）。</li>
    </ul>
  </li>
</ul>

<h2 id="212-bfc块级格式化上下文">2.12 BFC块级格式化上下文</h2>

<h3 id="bfc是什么">BFC是什么</h3>

<p>BFC(块级格式化上下文)，有如下特性：</p>

<ul>
  <li>BFC 会创建一个独立的空间，内部元素永远不会超出它的范围，即使是float元素（因此浮动元素也会撑开触发了BFC的盒子）；</li>
  <li>不同BFC之间，不会发生外边距折叠；</li>
  <li>BFC区域不会与任何float元素重叠（相当于左右都清除浮动）；</li>
</ul>

<h3 id="bfc的作用是">BFC的作用是？</h3>

<ol>
  <li>防止浮动元素跑出父容器；</li>
  <li>防止外边距折叠；</li>
  <li>创建左右浮动，中间自适应的双飞翼布局（使用flex更佳）；</li>
</ol>

<h3 id="如何触发bfc">如何触发BFC</h3>

<p>以下元素会创建 BFC：</p>

<ul>
  <li>根元素（<code>&lt;html&gt;</code>）</li>
  <li><strong>浮动元素（元素的 float 不是 none）</strong></li>
  <li><strong>绝对定位元素（元素的 position 为 absolute 或 fixed）</strong></li>
  <li><strong>overflow 计算值(Computed)<code>不为 visible</code> 的块元素</strong></li>
  <li><strong>★（没有副作用）display 值为 flow-root 的元素</strong></li>
  <li><strong>弹性元素</strong>（display 为 flex 或 inline-flex 元素的直接子元素）</li>
  <li><strong>网格元素</strong>（display 为 grid 或 inline-grid 元素的直接子元素）</li>
  <li>行内块元素（元素的 display 为 inline-block）</li>
  <li>表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）</li>
  <li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
  <li>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li>
  <li>contain 值为 layout、content 或 paint 的元素</li>
  <li>多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）</li>
</ul>

<h2 id="213-滤镜裁剪混合遮罩">2.13 滤镜、裁剪、混合、遮罩</h2>

<ul>
  <li>clip-path: 裁剪
    <ul>
      <li>形状函数:
        <ul>
          <li>inset(): 上右下左四个向内收缩值；</li>
          <li>circle(): 只接受一个圆的半径（长度、百分比），然后可以加上一个<code>at</code>，后面接圆心的位置（可以是关键字，如<code>center</code>）；</li>
          <li>ellipse(): 接受一对值，定义纵轴和横轴半径。同样用<code>at</code>接圆心位置；</li>
          <li>polygon(): 多边形，用多个逗号分隔的点（一对由空格隔开的长度或百分数值）定义。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>mask 遮罩
    <ul>
      <li>mask-image: 用于蒙版的图片（与background-image类似）；</li>
      <li><strong>mask-mode:</strong> 定义蒙版的实现模式。
        <ul>
          <li>alpha: 通过透明度通道实现（全透明为不可见）；</li>
          <li>luminance: 通过亮度实现（全黑为不可见）；</li>
        </ul>
      </li>
      <li>mask-size、mask-position、mask-repeat、mask-origin、mask-clip：都与对应的background属性类似；</li>
      <li>mask-composite：定义多个蒙板的合并方式（相交、减除等）。</li>
    </ul>
  </li>
  <li>object 置换元素相关
    <ul>
      <li>object-fit：置换元素在框内的填充方式:
        <ul>
          <li>fill（默认）: 元素被拉伸到容器尺寸，不保留宽高比；</li>
          <li>cover: 保留宽高比，拉伸元素直到覆盖整个容器（多余部分被切除）；</li>
          <li>contain: 保留宽高比，拉伸元素直到正好被容器容纳；</li>
          <li>none: 不拉伸元素，保留元素初始尺寸；</li>
        </ul>
      </li>
      <li>object-position：置换元素在框内的位置。与background-position类似，只不过是设置置换元素的位置。</li>
    </ul>
  </li>
</ul>

<h1 id="响应式布局">响应式布局</h1>

<p><a href="https://github.com/forthealllight/blog/issues/13">响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh)</a></p>

<h2 id="逻辑像素物理像素像素密度">逻辑像素、物理像素、像素密度</h2>

<p><strong>物理像素：</strong> 设备屏幕上的一个物理像素点；
<strong>逻辑像素：</strong> CSS中设置的像素单位(<code>1px</code>)，一个逻辑像素可以对应多个物理像素（多倍屏）；
<strong>像素密度：</strong> 一个逻辑像素对应多少个物理像素。例如：<code>CSS</code>中设置<code>1px</code>在iphone等设备上可能显示为<code>3</code>个像素点，那么这台iphone此时的像素密度为<code>pixel ratio = 3</code>；</p>

<h1 id="bem规范">BEM规范</h1>

<p><a href="https://juejin.cn/post/6844903672162304013">BEM规范</a></p>

<h2 id="bem规范解决的问题">BEM规范解决的问题</h2>

<p>通过CSS选择器名称，就可以知道它定位的元素，以及与父元素的嵌套层级关系；</p>

<h2 id="bem规范内容">BEM规范内容</h2>

<p>BEM 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p>

<p>块是一个功能区域的根元素，元素是其内部实现的子元素，而修饰符代表元素的某一状态。</p>

<p>它定义CSS选择器的命名如下：</p>

<blockquote>
  <p><code>Block__Element--Modifier</code></p>
</blockquote>

<p>其中：</p>

<ol>
  <li>块与其内部元素之间用两个下划线(<code>__</code>)隔开;</li>
  <li>元素与其修饰符之间用两个短横线(<code>--</code>)隔开；</li>
  <li>如果块、元素、状态需要由多个单词组成，单词之间用<code>-</code>隔开；</li>
</ol>

<p>例如：</p>

<ul>
  <li><code>container__button--hover</code>;</li>
  <li><code>video-box__show-btn--active</code>;</li>
</ul>

<h2 id="bem规范的实操">BEM规范的实操</h2>

<ol>
  <li>只在需要处理父子嵌套关系的时候，使用BEM规范命名，单一状态等不需要；</li>
  <li>手写麻烦，一般使用SCSS等预处理器的嵌套功能编写；</li>
  <li>层级最好不要超过4级；</li>
  <li>也可使用预处理器的mixin等功能，实现BEM的自动命名;</li>
</ol>

<h1 id="一些常用css技巧">一些常用CSS技巧</h1>
<h2 id="单行文字溢出显示三点省略号">单行文字溢出显示三点省略号</h2>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">overflow</span><span class="o">:</span> <span class="nt">hidden</span><span class="o">;</span>            <span class="o">//</span> <span class="err">溢出隐藏</span>
<span class="nt">text-overflow</span><span class="o">:</span> <span class="nt">ellipsis</span><span class="o">;</span>      <span class="o">//</span> <span class="err">溢出用省略号显示</span>
<span class="nt">white-space</span><span class="o">:</span> <span class="nt">nowrap</span><span class="o">;</span>         <span class="o">//</span> <span class="err">规定段落中的文本不进行换行</span>
</code></pre></div></div>

<h2 id="多行文字溢出显示三点省略号">多行文字溢出显示三点省略号</h2>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">overflow</span><span class="o">:</span> <span class="nt">hidden</span><span class="o">;</span>            <span class="o">//</span> <span class="err">溢出隐藏</span>
<span class="nt">text-overflow</span><span class="o">:</span> <span class="nt">ellipsis</span><span class="o">;</span>     <span class="o">//</span> <span class="err">溢出用省略号显示</span>
<span class="nt">display</span><span class="o">:</span> <span class="nt">-webkit-box</span><span class="o">;</span>         <span class="o">//</span> <span class="err">作为弹性伸缩盒子模型显示。</span>
<span class="nt">-webkit-box-orient</span><span class="o">:</span> <span class="nt">vertical</span><span class="o">;</span> <span class="o">//</span> <span class="err">设置伸缩盒子的子元素排列方式：从上到下垂直排列</span>
<span class="nt">-webkit-line-clamp</span><span class="o">:</span> <span class="nt">3</span><span class="o">;</span>        <span class="o">//</span> <span class="err">显示的行数</span>
</code></pre></div></div>

        </div>
    </div>

    <!-- 关键词 -->
    <div id="tagsBox">
      Keywords:
      <a id="tags" href="CSS"><span>CSS</span></a>
      </div>

</article>

<!-- 上一篇与下一篇按钮 -->
<div id="postPager">
    
    <span id="previousPost">
        <a href="/blog/2021/06/17/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/" title="使用数组构建堆结构的过程和堆排序原理">
            <img src="http://localhost:4000/assets/posts/beforeBlack.svg" alt="previousPost">
        </a>
    </span>
    

    <!-- 文章位置功能 （未实现）-->
    <!-- 
      <p id="postNumBox">Blog &nbsp; 
        <span id="postNum"></span> &nbsp; Of &nbsp; 
        <span id="postNum"></span>
      </p> -->

    
    <span id="nextPost">
        <a href="/blog/2021/08/01/%E7%8E%B0%E4%BB%A3JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Module%E6%A8%A1%E5%9D%97%E5%8C%96/" title="JS模块化">
            <img src="http://localhost:4000/assets/posts/nextBlack.svg" alt="nextPost">
        </a>
    </span>
    
</div>
<!-- Valine 浏览量统计 -->
<span id="/blog/2021/07/28/CSS%E7%AC%94%E8%AE%B0/" class="leancloud-visitors" data-flag-title="Your Article Title">
    <span>已经有 </span><i class="leancloud-visitors-count" style="color: #edebdc;">1000000</i> <span> 个小伙伴看完了这篇推文。</span>
</span>

<!-- Valine 评论框 -->
<div id="vcomments"></div>

    </main><footer>
    <div id="footerBox">
        <div id="socialBox">
            
            
            
            <a href="mailto:mars_yao@yeah.net" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-envelope"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://marswiz.com/aboutMe" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-weixin"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://github.com/marswiz" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-github"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://juejin.cn/user/131597123717319" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent2">掘</p>
                    
                </div>
            </a></div>
        <div id="webInfo">
            <p>
                <span id="beian">京ICP备 17067352 号</span>
                <span id="powered">&nbsp;Powered by <span style="font-style: italic;">Jekyll</span>. &nbsp;</span>
                <span id="copyright">Copyright © 2019 Mars. All rights reserved.</span>
            </p>
        </div>
    </div>

    <script src="http://localhost:4000/assets/js/dist/main.js" defer></script>
    <script>
        // window.addEventListener('load', postsFunc, false);
        // if (window.innerWidth <= 768) {
        //     window.addEventListener('load', loadDayNight, false);
        //     $(document).one('touchstart', loadDayNight);
        // }
    </script>

    <!-- Valine 评论 -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '5mfc7sb6aVJyKPMGY6K423B6-MdYXbMMI',
            appKey: 'Tv40sJl6jo9ac84eFi8H3ejb',
            placeholder: '- 无需注册，理性讨论.&#10;- 可使用Gravatar注册邮箱修改个人头像~&#10;- 我爱刘小宝~~',
            notify: true,
            verify: true,
            visitor: true,
            avatar: 'retro',
            serverURLs: 'https://5mfc7sb6.api.lncldglobal.com'
        })
    </script>
</footer><!-- 回到页首按钮 -->
    <a href="#mainBox" class="fa fa-rocket" id="toTop"></a>

</body>
<!-- <script>
    blogYearFunc();
    if (window.innerWidth >= 769) {
        document.querySelector('#navBlog').style.display = 'block';
    }

    window.addEventListener('resize', debounce(resize, 0.5));
</script> --></html>