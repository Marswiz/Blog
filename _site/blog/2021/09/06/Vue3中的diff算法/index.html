<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="路旁有花，心中有歌，天上有星。">
  <meta name="keywords" content="Marswiz,blog,Mars,技术博客,前端,Frontend,个人博客">
  <meta name="author" content="Marswiz"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Vue3中的diff算法 | 个人杂记:MarsWiz</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Vue3中的diff算法" />
<meta name="author" content="Mars" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、Vue3中的diff算法" />
<meta property="og:description" content="一、Vue3中的diff算法" />
<link rel="canonical" href="http://localhost:4000/blog/2021/09/06/Vue3%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/" />
<meta property="og:url" content="http://localhost:4000/blog/2021/09/06/Vue3%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/" />
<meta property="og:site_name" content="个人杂记:MarsWiz" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"一、Vue3中的diff算法","@type":"BlogPosting","url":"http://localhost:4000/blog/2021/09/06/Vue3%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","headline":"Vue3中的diff算法","dateModified":"2021-09-06T00:00:00+08:00","datePublished":"2021-09-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2021/09/06/Vue3%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/"},"author":{"@type":"Person","name":"Mars"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="preload" href="/assets/fonts/Didot.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Clarendon_BT.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/TodaySB-CapExtLig.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/PoiretOne-Regular.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Memphis.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="preload" href="/assets/fonts/Folio-Light.woff2" as="font" type="font/woff2" crossorigin> 
  <link rel="stylesheet" href="/assets/main1.css?v=1.1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="个人杂记:MarsWiz" /><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Icons -->
	<link rel="shortcut icon" href = "/assets/pics/logo_cat.jpg">
	<link rel="bookmark" href = "/assets/pics/logo_cat.jpg">
	<link rel="apple-touch-icon" href = "/assets/pics/logo_cat.jpg">

  <!--  jquery  -->
  <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js" defer></script>


    <!-- Valine 评论
    <script src='//unpkg.zhimg.com/valine/dist/Valine.min.js'></script> -->
  <!-- Vconsole -->
<!--   <script src="http://localhost:4000/assets/js/vconsole.min.js"></script>
  <script>
    // init vConsole
    var vConsole = new VConsole();
    console.log('Hello world');
  </script>
   -->
  <!-- Hammer.js 移动手势操作库 -->
  <script src="http://localhost:4000/assets/js/hammer.js" defer></script>


</head>
<body><!-- 日志页导航栏结构 -->

<nav id="navBlog">


	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id="blogLogo" src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>
		<!-- 导航按钮 -->
<!--		<div id="navItems">-->
<!--			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>-->
<!--			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>-->
<!--			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>-->
<!--			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>-->
<!--			<a href="" id="projectsBtn">Projects</a>-->
<!--		</div>-->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><div id="blogBtnSprite"></div></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><div id="tagsBtnSprite"></div></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><div id="aboutMeBtnSprite"></div></a>
			<a id="searchBtn" href="http://localhost:4000/search"><div id="searchBtnSprite"></div></a>
			<a href="http://localhost:4000/projects" id="projectsBtn"><div id="projectsBtnSprite"></div></a>
		</div>

		<!-- 移动端按钮 -->
		<div id="navItemsBtnMobile">
			<span class="fa fa-bars"></span>
		</div>
	</div>



</nav>
<!-- 日志页移动端导航栏结构 -->

<nav id="navMobile">
	<div id="navBlur"></div>
	<div id="navTrans">
		<!-- logo -->
		<a id="logo" href="/">
			<img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
		</a>

		<!-- 导航按钮 -->
		<div id="navItems">
			<a id="blogBtn" href="http://localhost:4000/blog"><img src="http://localhost:4000/assets/nav/blogBlack.svg" alt="blog"></a>
			<a id="tagBtn" href="http://localhost:4000/tags"><img src="http://localhost:4000/assets/nav/tagsBlack.svg" alt="tags"></a>
			<a id="aboutMeBtn" href="http://localhost:4000/aboutMe"><img src="http://localhost:4000/assets/nav/aboutMeBlack.svg" alt="aboutMe"></a>
			<a id="searchBtn" href="http://localhost:4000/search"><img src="http://localhost:4000/assets/nav/searchBlack.svg" alt="search"></a>
			<a id="projectsBtn" href="http://localhost:4000/projects"><img src="http://localhost:4000/assets/nav/projectBlack.svg" alt="project"></a>
		</div>
		<div id="changeDayNight" class="fa fa-lightbulb-o"></div>
	</div>
</nav>
<main id="mainBox" aria-label="Content">

        <!-- 移动端页面标题 -->
        <!--   <a id="logoBoxBlog" href="/">
      <img id='logo' src="http://localhost:4000/assets/logo/logoBlack.svg" alt="MarsWiz">
    </a> -->
        <!--  -->
        <span id="pIdentifier" style="display: none;">中文缩进</span>
<span id="baseURLIdentifier" style="display: none;">http://localhost:4000</span>
<article id="postBox">

    <!-- 标题和日期 -->
    <header id="postHeader">
        <h1 id="postTitle">Vue3中的diff算法</h1>
        <p id="postInfo">
            Posted by<span id="postAuthor"> Mars </span>. Modified at
            <time id="postTime">Sep 6, 2021
            </time>
        </p>
    </header>

    <div id="postContentBox">
        <!-- 标题headerIndex导航 -->
        <div id="headerIndex"></div>

        <!-- 内容主体 -->
        <div id="postContent">
            <h1 id="一vue3中的diff算法">一、Vue3中的diff算法</h1>

<blockquote>
  <p>Vue3中对于没有key的片段，采用的是<strong>直接数组比较</strong>方法；</p>

  <p>对于有key的片段，采用的是<strong>先掐头去尾，然后执行最长递增子序列的方法。</strong></p>
</blockquote>

<h2 id="1-最长递增子序列算法">1. 最长递增子序列算法</h2>

<p>最长递增子序列算法：</p>

<p>贪心策略：<strong>为了找到最长的递增子序列，我们希望递增序列增长得慢一些。这样后面的元素就更容易与其形成更长的递增子序列。</strong></p>

<p>因此，假设我们在遍历过程中当前找到的最长递增子序列是<code>sub</code>，此时sub末尾（最大）的元素是<code>a</code>，当位于后面的元素<code>b</code>比<code>a</code>更小，我们应该更新<code>a</code>为<code>b</code>，因为此时b比a更容易实现最长的递增子序列。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// By Mars 2021.09.06</span>
<span class="c1">// Get max asscending sequence of an pure number array.</span>
<span class="c1">// getMaxSequence(arr);</span>
<span class="c1">// eg. [2,3,6,1,7]  -&gt; [2,3,6,7]</span>

<span class="c1">// Algorithum (greedy) :</span>
<span class="c1">// Time: O(n*logn)</span>
<span class="c1">// Steps:</span>
<span class="c1">//      1. Maintain an accending order array:[result], and an array:[p] whose length is the same with given array.</span>
<span class="c1">//      2. result[i] = n, means that at current status, we have found a max accending sequence of length i+1, and the minimum number at the tail of the sequence is [n]. </span>
<span class="c1">//      3. p[i] is setted when we take an element form the original given array and refresh the result array with it. p[i] records the previous number of result array of where we put the current element array[i] into at the result array;</span>
<span class="c1">//      4. result array is an accending array, we iterate the original array and pick current element (arr[i]), then find the first element which is larger than current element in result array (assume that position is [pos]), and replace it with current element value;</span>
<span class="c1">//      5. then we get the previous element of result array (result[pos-1]), and set p[i] with it;</span>
<span class="c1">//      6. after we iterate all the elements, the last element of result array must be the real number of the max sequence, other elements can be replaced during the precess above, so they may be not the real number of the result max sequence;</span>
<span class="c1">//      7. Luckily, we record the real element when we refresh every element of result, which is in array p. </span>
<span class="c1">//      8. everytime, we get the element of result array, and find the position of it in the original array [pos], the real previous element of max subsquence  is p[pos];</span>
<span class="c1">//      9. repeat the step.8 until all the sequence is found.</span>

<span class="kd">function</span> <span class="nx">getMaxSequence</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span> <span class="c1">// same length of arr.</span>

    <span class="kd">function</span> <span class="nx">bs</span><span class="p">(</span><span class="nx">tar</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// find the first num which [ &gt;= tar ].</span>
        <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nx">r</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">result</span><span class="p">[</span><span class="nx">m</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="nx">tar</span><span class="p">)</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">m</span><span class="p">;</span>
            <span class="k">else</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">l</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">bs</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">result</span><span class="p">[</span><span class="nx">pos</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">pos</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">result</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
                    <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">result</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
                    <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">result</span><span class="p">[</span><span class="nx">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">;</span>
        <span class="nx">prev</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">result</span><span class="p">[</span><span class="nx">cur</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="2-无key元素的diff算法">2. 无key元素的diff算法</h2>

<p>没有key的元素片段，patch的时候采用的是<strong>直接进行数组比较</strong>的方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 基本思路：</span>
<span class="c1">// 1. 对oldChildren, newChildren，选取二者中长度较小的作为公共长度；</span>
<span class="c1">// 2. 从0位置开始，对公共长度部分一一对应直接patch；</span>
<span class="c1">// 3. 如果oldChildren长度更长，则把多余的部分直接unmount；</span>
<span class="c1">// 4. 如果newChildren长度更长，则直接把剩余的部分依次mount到最下方。</span>
<span class="kd">const</span> <span class="nx">patchUnkeyedChildren</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span> <span class="o">||</span> <span class="nx">EMPTY_ARR</span><span class="p">;</span>
    <span class="nx">c2</span> <span class="o">=</span> <span class="nx">c2</span> <span class="o">||</span> <span class="nx">EMPTY_ARR</span><span class="p">;</span>
    <span class="c1">// Choose the common length of c1 and c2.</span>
    <span class="kd">const</span> <span class="nx">oldLength</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">newLength</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">commonLength</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">oldLength</span><span class="p">,</span> <span class="nx">newLength</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
    <span class="c1">// Patch the common area.</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commonLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span>
            <span class="p">?</span> <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="p">:</span> <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
        <span class="nx">patch</span><span class="p">(</span><span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nextChild</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">oldLength</span> <span class="o">&gt;</span> <span class="nx">newLength</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// remove old</span>
        <span class="nx">unmountChildren</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">commonLength</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// mount new</span>
        <span class="nx">mountChildren</span><span class="p">(</span><span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">,</span> <span class="nx">commonLength</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="3-有key元素的diff算法">3. 有key元素的diff算法</h2>

<p><strong>基本思路如下：</strong></p>

<p>对于两个子VNode数组oldChildren，newChildren：</p>

<ol>
  <li>从头部<code>i=0</code>开始，一直向后匹配，直到二者vnode不相同（或到达尾部）；<strong>（Vue3以key和Vnode.type都相同标记为二者相同）</strong></li>
  <li>从二者各自尾部<code>e1=oldChildren.length-1</code>和<code>e2=newChildren.length-1</code>开始，一直向前匹配，直到二者vnode不同（或遇到头部指针i）；</li>
  <li>此时，存在三种情况：
    <ul>
      <li>① newChildren 在 oldChildren的基础上，前或后增加了若干元素(<code>e.g. oc = [1,2,3]; nc = [1,2,3,4,5]</code>)：<strong>i &gt; e1 &amp;&amp; i &lt;= e2</strong></li>
      <li>② newChildren 在 oldChildren的基础上，前或后删除了若干元素(<code>e.g. oc = [1,2,3,4,5]; nc = [1,2,3]</code>)：<strong>i &lt;= e1 &amp;&amp; i &gt; e2</strong></li>
      <li>③ newChildren、oldChildren在执行了前后比对之后，二者中间都剩余了部分元素(<code>e.g. oc = [1,2,3]; nc = [1,2,3,4,5]</code>)：<strong>i &lt;= e1 &amp;&amp; i &lt;= e2</strong></li>
    </ul>
  </li>
  <li>对于①、②两种情况，和没有key的数组比较相同，直接mount或unmount剩下的元素即可；</li>
  <li>对于③情况，对二者<strong>剩余子数组oc、nc</strong>，执行最大递增子序列算法：
    <ul>
      <li>① 为nc创建一个哈希表Map，键名为子元素child的key，键值为child在children中的索引；（为了减少复杂度，方便步骤②的查询）</li>
      <li>② 设置一个数组<code>newIndexToOldIndexMap</code>，初始化各元素为-1（Vue3中为0，oc中newIndex向后移动了1），记录nc各元素在oc中的位置：<strong><code>newIndexToOldIndexMap[i] = k</code>代表nc中i位置元素，在oc中位置为k</strong>；</li>
      <li>③ 从头到尾遍历oc，对于它的子元素oldChild，找到它在新数组nc中的位置newIndex：
        <ul>
          <li>如果有key，从Map中查找key对应的index为newIndex，找不到则为undefined；</li>
          <li>如果没有key，遍历nc，比较元素是否相同，相同则记录下它的index作为newIndex，找不到则为undefined。</li>
          <li>如果newIndex为undefined，说明新子元素nc中没有这个旧元素，<strong>直接删除(unmount)当前的旧元素</strong>；</li>
          <li>如果newIndex不是undefined：
            <ul>
              <li>记录它当前在oc中的位置<code>newIndexToOldIndexMap[newIndex] = i;</code></li>
              <li>因为nc中元素为升序排列，如果相对位置在oc中没变，那么它们在newIndexToOldIndexMap也应该是升序，因此newIndex应该是递增的：
                <ul>
                  <li>记录当前已遍历的newIndex的最大值maxNewIndex，如果<code>newIndex &gt;= maxNewIndex</code>，则更新<code>maxNewIndex</code>;</li>
                  <li>如果<code>newIndex &lt; maxNewIndex</code>，因为newIndex也不是undefined，则<strong>说明当前的元素移动了位置，记录下这个情况(moved = true，代表nc整体存在元素移动情况)</strong>；</li>
                  <li>patch新、旧这两个元素;</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>④ 寻找newIndexToOldIndexMap的最大递增子序列maxSequence，它内部含有的元素，都只需要内部更新，不需要移动；</li>
      <li>⑤ <strong>从后到前</strong>遍历nc：
        <ul>
          <li>对于nc最后一个元素，它mount到容器的下方。对于非最后一个元素，它的anchor是前一个元素<code>[i+1]</code>对应的DOM元素；</li>
          <li>如果<code>newIndexToOldIndexMap[i] === -1</code>，则说明oc中没有这个新元素，将它按照anchor，进行mount；</li>
          <li>否则，如果存在moved === true，而且i不在maxSequence中，则按照anchor，移动当前元素（当前元素已经在步骤③被patch过，现在只需要移动）。</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">patchKeyedChildren</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">l2</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">e1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// prev ending index</span>
    <span class="kd">let</span> <span class="nx">e2</span> <span class="o">=</span> <span class="nx">l2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// next ending index</span>

    <span class="c1">// [Mars] : 1. Compare the head and the tail first.</span>

    <span class="c1">// 1. sync from start</span>
    <span class="c1">// (a b) c</span>
    <span class="c1">// (a b) d e</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">n2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span> <span class="p">?</span>
            <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">:</span>
            <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">isSameVNodeType</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// type and key are the same.</span>
            <span class="nx">patch</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. sync from end</span>
    <span class="c1">// a (b c)</span>
    <span class="c1">// d e (b c)</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">e1</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">n2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">e2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span> <span class="p">?</span>
            <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">e2</span><span class="p">])</span> <span class="p">:</span>
            <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">e2</span><span class="p">]));</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">isSameVNodeType</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// type and key are the same.</span>
            <span class="nx">patch</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">e1</span><span class="o">--</span><span class="p">;</span>
        <span class="nx">e2</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// [Mars] : 2. Compare the head and the tail first.</span>

    <span class="c1">// 3. common sequence + mount</span>
    <span class="c1">// (a b)</span>
    <span class="c1">// (a b) c</span>
    <span class="c1">// i = 2, e1 = 1, e2 = 2</span>
    <span class="c1">// (a b)</span>
    <span class="c1">// c (a b)</span>
    <span class="c1">// i = 0, e1 = -1, e2 = 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">e1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">nextPos</span> <span class="o">=</span> <span class="nx">e2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">nextPos</span> <span class="o">&lt;</span> <span class="nx">l2</span> <span class="p">?</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">nextPos</span><span class="p">].</span><span class="nx">el</span> <span class="p">:</span> <span class="nx">parentAnchor</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// mount new added vnodes not contained in oldChilds.</span>
                <span class="nx">patch</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span> <span class="p">?</span>
                    <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">:</span>
                    <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])),</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
                <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 4. common sequence + unmount</span>
    <span class="c1">// (a b) c</span>
    <span class="c1">// (a b)</span>
    <span class="c1">// i = 2, e1 = 2, e2 = 1</span>
    <span class="c1">// a (b c)</span>
    <span class="c1">// (b c)</span>
    <span class="c1">// i = 0, e1 = 0, e2 = -1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">unmount</span><span class="p">(</span><span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
            <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 5. unknown sequence</span>
    <span class="c1">// [i ... e1 + 1]: a b [c d e] f g</span>
    <span class="c1">// [i ... e2 + 1]: a b [e d c h] f g</span>
    <span class="c1">// i = 2, e1 = 4, e2 = 5</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="c1">// prev starting index</span>
        <span class="kd">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="c1">// next starting index</span>

        <span class="c1">// 5.1 build key:index map for newChildren</span>
        <span class="kd">const</span> <span class="nx">keyToNewIndexMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span> <span class="c1">// use hashMap, cause it's easy to search an index of a key.</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span> <span class="p">?</span>
                <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">:</span>
                <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
                    <span class="nx">warn$1</span><span class="p">(</span><span class="s2">`Duplicate keys found during update:`</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="s2">`Make sure keys are unique.`</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 5.2 loop through old children left to be patched and try to patch</span>
        <span class="c1">// matching nodes &amp; remove nodes that are no longer present</span>
        <span class="kd">let</span> <span class="nx">j</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">patched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">toBePatched</span> <span class="o">=</span> <span class="nx">e2</span> <span class="o">-</span> <span class="nx">s2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">moved</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">// used to track whether any node has moved</span>
        <span class="kd">let</span> <span class="nx">maxNewIndexSoFar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// works as Map&lt;newIndex, oldIndex&gt;</span>
        <span class="c1">// Note that oldIndex is offset by +1</span>
        <span class="c1">// and oldIndex = 0 is a special value indicating the new node has</span>
        <span class="c1">// no corresponding old node.</span>
        <span class="c1">// used for determining longest stable subsequence</span>
        <span class="kd">const</span> <span class="nx">newIndexToOldIndexMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">toBePatched</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">toBePatched</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">s1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">prevChild</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">patched</span> <span class="o">&gt;=</span> <span class="nx">toBePatched</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// all new children have been patched so this can only be a removal</span>
                <span class="nx">unmount</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kd">let</span> <span class="nx">newIndex</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">prevChild</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">newIndex</span> <span class="o">=</span> <span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// key-less node, try to locate a key-less node of the same type</span>
                <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="nx">s2</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                        <span class="nx">isSameVNodeType</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">j</span><span class="p">]))</span> <span class="p">{</span> <span class="c1">// type and key are the same.</span>
                        <span class="nx">newIndex</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">newIndex</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">unmount</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">newIndex</span> <span class="o">-</span> <span class="nx">s2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// n:[h,c,d,e]  o:[c,d,e,h]  -&gt;  newIndexToOldIndexMap: [4,1,2,3]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">newIndex</span> <span class="o">&gt;=</span> <span class="nx">maxNewIndexSoFar</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">maxNewIndexSoFar</span> <span class="o">=</span> <span class="nx">newIndex</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">moved</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nx">patch</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">newIndex</span><span class="p">],</span> <span class="nx">container</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
                <span class="nx">patched</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 5.3 move and mount</span>
        <span class="c1">// generate longest stable subsequence only when nodes have moved</span>
        <span class="kd">const</span> <span class="nx">increasingNewIndexSequence</span> <span class="o">=</span> <span class="nx">moved</span> <span class="p">?</span>
            <span class="nx">getSequence</span><span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">EMPTY_ARR</span><span class="p">;</span>
        <span class="nx">j</span> <span class="o">=</span> <span class="nx">increasingNewIndexSequence</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// looping backwards so that we can use last patched node as anchor !!!!!!★★★</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">toBePatched</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="nx">s2</span> <span class="o">+</span> <span class="nx">i</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">nextIndex</span><span class="p">];</span>
            <span class="kd">const</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">nextIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">l2</span> <span class="p">?</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">nextIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nx">el</span> <span class="p">:</span> <span class="nx">parentAnchor</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// mount new</span>
                <span class="nx">patch</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">nextChild</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">slotScopeIds</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">moved</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// move if:</span>
                <span class="c1">// There is no stable subsequence (e.g. a reverse)</span>
                <span class="c1">// OR current node is not among the stable sequence</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">!==</span> <span class="nx">increasingNewIndexSequence</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">move</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="mi">2</span> <span class="cm">/* REORDER */</span> <span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// position is matched, no movement.</span>
                    <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

        </div>
    </div>

    <!-- 关键词 -->
    <div id="tagsBox">
      Keywords:
      <a id="tags" href="Vue"><span>Vue</span></a>
      </div>

</article>

<!-- 上一篇与下一篇按钮 -->
<div id="postPager">
    
    <span id="previousPost">
        <a href="/blog/2021/09/02/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/" title="前端实用工具库">
            <img src="http://localhost:4000/assets/posts/beforeBlack.svg" alt="previousPost">
        </a>
    </span>
    

    <!-- 文章位置功能 （未实现）-->
    <!-- 
      <p id="postNumBox">Blog &nbsp; 
        <span id="postNum"></span> &nbsp; Of &nbsp; 
        <span id="postNum"></span>
      </p> -->

    
    <span id="nextPost">
        <a href="/blog/2021/09/06/preload%E5%92%8Cprefetch%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD/" title="preload和prefetch关键字实现资源预加载">
            <img src="http://localhost:4000/assets/posts/nextBlack.svg" alt="nextPost">
        </a>
    </span>
    
</div>
<!-- Valine 浏览量统计 -->
<span id="/blog/2021/09/06/Vue3%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/" class="leancloud-visitors" data-flag-title="Your Article Title">
    <span>已经有 </span><i class="leancloud-visitors-count" style="color: #edebdc;">1000000</i> <span> 个小伙伴看完了这篇推文。</span>
</span>

<!-- Valine 评论框 -->
<div id="vcomments"></div>

    </main><footer>
    <div id="footerBox">
        <div id="socialBox">
            
            
            
            <a href="mailto:mars_yao@yeah.net" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-envelope"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://marswiz.com/aboutMe" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-weixin"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://github.com/marswiz" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent1" class="fa fa-github"></p>
                    
                </div>
            </a>
            
            
            
            <a href="https://juejin.cn/user/131597123717319" target="_blank">
                <div id="socialBall">
                    
                    <p id="socialContent2">掘</p>
                    
                </div>
            </a></div>
        <div id="webInfo">
            <p>
                <span id="beian">京ICP备 17067352 号</span>
                <span id="powered">&nbsp;Powered by <span style="font-style: italic;">Jekyll</span>. &nbsp;</span>
                <span id="copyright">Copyright © 2019 Mars. All rights reserved.</span>
            </p>
        </div>
    </div>

    <script src="http://localhost:4000/assets/js/dist/main.js" defer></script>
    <script>
        // window.addEventListener('load', postsFunc, false);
        // if (window.innerWidth <= 768) {
        //     window.addEventListener('load', loadDayNight, false);
        //     $(document).one('touchstart', loadDayNight);
        // }
    </script>

    <!-- Valine 评论 -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '5mfc7sb6aVJyKPMGY6K423B6-MdYXbMMI',
            appKey: 'Tv40sJl6jo9ac84eFi8H3ejb',
            placeholder: '- 无需注册，理性讨论.&#10;- 可使用Gravatar注册邮箱修改个人头像~&#10;- 我爱刘小宝~~',
            notify: true,
            verify: true,
            visitor: true,
            avatar: 'retro',
            serverURLs: 'https://5mfc7sb6.api.lncldglobal.com'
        })
    </script>
</footer><!-- 回到页首按钮 -->
    <a href="#mainBox" class="fa fa-rocket" id="toTop"></a>

</body>
<!-- <script>
    blogYearFunc();
    if (window.innerWidth >= 769) {
        document.querySelector('#navBlog').style.display = 'block';
    }

    window.addEventListener('resize', debounce(resize, 0.5));
</script> --></html>