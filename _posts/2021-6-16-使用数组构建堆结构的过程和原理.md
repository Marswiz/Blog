---
layout: post
title: 使用数组构建堆结构的过程和原理
date: 2021-6-17
categories: blog
tags: [Data Structure]
author: Mars
pIdentifier: 中文缩进
---

> 使用数组构建堆结构的过程和原理:
> 
> heapify()函数的含义和代码，构建起始位置和过程等。

# 1. 堆结构的特点

一个完全二叉树，如果每一个父节点值都大于等于（或小于等于）它子节点的值，则这个二叉树称为一个**堆**。

- 大顶堆：任一父节点值大于子节点值（最大值在根节点）
- 小顶堆：任一父节点值小于子节点值（最小值在根节点）

# 2. 数组构建堆结构过程

对于一个任一数组arr，可以使用下面的方法将其转化为一个堆。

**从任一叶子节点向前遍历，对每一个节点使用heapify(arr,index)方法，直到index === 0（根节点）为止。**

# 2.1 heapify()函数的作用

heapify(arr,index)函数的作用是： 

**将arr中index位置的元素，放在它子树中正确的位置。**

因此，从叶子节点开始，向上遍历执行heapify()直到根节点，可以保证整棵树的元素都按堆的原则，放在了正确的位置上。（堆构建完成）

```js
// heapify函数的实现：i从0开始
    function heapify(arr,i){
        let left = 2 * i + 1, right = 2 * i + 2
        let length = arr.length
        let largest = i
        if (left < length && arr[left] > arr[largest]) largest = left
        if (right < length && arr[right] > arr[largest]) largest = right
        if (largest !== i){
            [arr[largest],arr[i]] = [arr[i],arr[largest]]
            heapify(arr,largest)
        }
    }
```

# 2.2 数组构建堆的起始位置，可以不是最后一个节点

**可以使用`Math.floor(arr.length/2)`或`Math.floor(arr.length/2)-1`来作为第一个节点。**

证明如下图：

![证明](/assets/posts/heap.png)

Math.floor(arr.length/2)-1返回的总是最后一个叶子节点的父节点。
