---
layout: post
title: CSS笔记
date: 2021-7-28
categories: blog
tags: [CSS]
author: Mars
pIdentifier: 中文缩进
---

> CSS细节记录
>

> 1. [特指度、继承和层叠关系](#21-特指度继承和层叠关系)
> 2. [CSS函数](#22-css函数)
> 3. [CSS变量](#23-css变量)
> 4. [CSS的@规则](#24-css的规则)

# 二、主要内容
## 2.1 特指度、继承和层叠关系
### 2.1.1 CSS特指度

CSS特指度由4位构成`比如(0,0,0,0)`，可以认为是个十百千四位。越靠左优先级越高。

每存在一个选择器，总的CSS特指度按选择器权重增大。各选择器权重如下：

- 行内声明（元素的style属性）：`(1,0,0,0)`；
- Id选择器： `(0,1,0,0)`；
- 类、伪类：`(0,0,1,0)`；
- 元素、伪元素：`(0,0,0,1)`；
- 通用选择器（*）的特指度为0：`(0,0,0,0)`;
- 连接符（如：>、+等）和**继承的属性没有特指度**。（区别于0，它们没有特指度，相当于比0还要小）

如果两个选择器选择了同一个元素，特指度更大的将胜出（被应用）。

> 末尾带有!important的声明单独进行比较，同样遵循特指度优先规则。
> 
> 带有!important和不带的CSS规则进行比较，始终是带！important的规则胜出。

### 2.1.2 CSS属性继承

CSS属性一般只会父传后代，不会向上传播。（特例是body元素的背景属性，可以向上传播给html根元素。）

不继承的CSS属性：

 - 边框属性；
 - 盒模型相关属性；
 
 继承的属性，没有特指度，连0也没有。（弱于通配选择器*）
 
### 2.1.3 CSS的层叠关系
 
CSS的层叠关系，也就是谁的优先级更高，相互之间的覆盖关系。

CSS的层叠关系有以下几个影响因素：

- **显式权重**：有无`!important`标记；（带有!important的比没有的优先级更高）
- **来源**： 1. 创作人员 2.读者 3.浏览器默认；（带有!important的读者 > 带有!important的创作人员 > 普通创作人员 > 普通读者 > 浏览器默认）
- **特指度：** 同上节；
- **声明顺序：** CSS语句的声明前后顺序。（后面的覆盖前面的）

> 因为有层叠关系，超链接的CSS伪类推荐声明顺序： LVFHA （link -> visited -> focus -> hover -> active）

## 2.2 CSS函数
### 2.2.1 calc()函数

calc()用于进行简单的数学计算。它的使用有如下**几点限制**：

- +和-号两边必须是同一单位类型，或者都是数字；
- *号两边必须有一个是数字，不能都是带单位的值；
- /号右边必须是数字，左边可以是数字也可以是带单位的值；
- 任何情况下都不能除以0；
- +和-号两边必须有空格，因为要与正负数区分开。

### 2.2.2 attr()函数

attr()函数，用于获取CSS选择的元素上的某一个属性值。（比如id属性）

> attr()目前仅支持在伪元素的content属性里使用，用于获取元素的某一属性作为字符串显示在伪元素中。

# 2.3 CSS自定义变量

使用`--`开头可以自定义一个CSS变量，它的作用和特性如下：

- 在后面可以使用var()函数引用这个变量，作用仅是把变量值替换到当前位置；
- 变量名称一般根据作用定义，尽量使用带有短横线连接的变量名；
- 变量名大小写敏感；
- **自定义变量具有作用域**。

## 2.4 CSS的@规则
### 2.4.1 CSS特性查询

使用`@supports(<css>){<css>}`语法可以对不同的CSS支持情况，编写不同的CSS。

```css
/* 仅支持color:black;的情况，才添加如下CSS */
@supports (color:black) {
    body {
        color: black;
    }
}
```

### 2.4.2 @font-face

用于使用自定义字体。可以指定一个服务器上的字体，然后用户在读取到这个声明的时候会下载这个字体文件，用于渲染页面。

```css
@font-face {
    font-family: 'Good';
    src: url("good.otf") format('opentype');
}
```

> 对于浏览器，无论是否使用声明的字体，都会进行下载。

@font-family中两个属性是必须的：

- font-family: 给要引入的字体起个名；
- src: 字体的位置。

> src中指定的字体文件位置，必须是同源的。
> 
> 也可以设置多个用逗号分隔的列表，用于提供备用字体文件下载。

使用@font-face，在字体没加载完成前，会使用默认字体显示，然后在加载完成后瞬间替换成自定义字体。如果二者字形大小相差过大，会导致页面重新布局，影响性能。

## 2.5 视觉格式化
### 2.5.1 容纳块

> 容纳块由离元素最近的生成**块级框**或**列表项目**的祖辈元素的边界构成。
>> ---《CSS权威指南》

容纳块是元素布局的参考基础。比如计算width等的百分比。

- body元素的容纳块是html元素；
- html元素对应的容纳块，叫初始容纳块。它由的大小等于视口的大小。
- 内部框的左右外边界间距（content-box宽度+内边距+边框+外边距），永远等于容纳块的content-box宽度；

### 2.5.2 块级框模型

![box](/assets/posts/23.png)

块级元素内部格式化基本原理：

**横向**：

- 核心条件：左右外边界间距（content-box宽度+内边距+边框+外边距），永远等于容纳块的content-box宽度；
- 只有margin和width可以设置为auto（自动计算），其他横向属性(padding、border)不能，只能设置为0或具体值；
- 只有外边距可以为负值，其他都不可以；
- 如果两边margin都设为auto，则两外边距平分，值相等；
- 置换元素（比如img），设置width为auto时，会自动设置为内部元素（图片）的宽度的100%；

**纵向**：

- 当设定块高度小于实际内容的高度时，行为取决于overflow属性的设置；
- 相邻的**纵向外边距**会发生折叠；
- 内边距和边框，不与任何区域发生折叠；
- 当设定块height为自动计算(auto): 
    - 如果没有为块设置触发BFC的条件（比如设置边框、内边距等），块的高度默认为：子代块级元素中**最上面的上边框外侧**到**最下面的下边框外侧**；
    - 如果触发了BFC，则块的高度为：子代块级元素中**最上面的上边距外边界**到**最下面的下边距外边界**（子元素外边距也包含进去，不发生外边距折叠）；
- 正外边距折叠时，结果取二者之间较大值。 负外边距折叠时，结果取负的绝对值较大的那个，然后用正外边距与它相加得到结果。

### 2.5.3 box-sizing 块模型修改

box-sizing属性只能用于块级元素，作用是设定块级元素的盒模型类型。（标准盒模型、怪异盒模型）

本质上是设定了width和height属性约束的是哪一个框。

- content-box（默认）：width和height都约束内容框（内边距内界以里）的尺寸；
- border-box: width和height都约束边框框（边框外界以里）的尺寸，内边距从里面扣除，扣除后部分才是内容框；

### 2.5.4 行内元素模型

![inline-box](/assets/posts/24.png)

行内元素内部格式化基本原理：

- 行内元素内部可以划分为：内容区、行内框；
- 非置换元素（比如span）的内容区，等于字体框的合集区域；
- 置换元素（比如img）的内容区，等于置换元素内容本身+内边距+边框+外边距的合集区域；
- 行距 = line-height - font-size；
- 非置换行内元素的行内框高度由line-height属性决定，非置换元素的行内框高度 = line-height = 内容区高度 + 行距；（因为行距可正可负，所以行内框可以大于内容框高度，也可以小于）
- 置换元素的行内框高度 = 内容区高度；
- 行内框在行中纵向如何对齐，用vertical-align属性设定，这也决定着行框的高度；
- 行的高度（行框高度），由行内元素内部各元素的行内框最高点和最低点之差决定；

确定一行的行框高度步骤：

1. 非置换元素：根据line-height与font-size之差计算行距，然后除以2，分别添加在字体框的上部和下部；
2. 置换元素：将纵向的padding、border和margin与height相加即为内容区高度；
3. 非置换元素的基线是内部字体的基线，置换元素的基线相当于是内容区的底边；
4. 根据各元素的vertical-align设置，按各自方法进行纵向对齐；
5. 找到最高点和最低点，二者就是行框的上界和下界，行框高度是二者之差；

### 2.5.5 行内块级元素 inline-block

行内块级元素(display:inline-block;)，对外部其他元素与行内框相同，对其内部内容它本身视作块级元素。
