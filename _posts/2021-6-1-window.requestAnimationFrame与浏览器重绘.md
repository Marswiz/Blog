---
layout: post
title: window.requestAnimationFrame与浏览器重绘
date: 2021-6-1
categories: blog
tags: [JavaScript]
author: Mars
pIdentifier: 中文缩进
---

> window.requestAnimationFrame API的功能：精确控制函数在重绘前时间节点执行。
>

# 1. 有关浏览器重绘机制的几个事实

1. 大多数浏览器会限制重绘频率，一般**不大于**屏幕刷新率**60Hz**；
2. 浏览器发生重绘的时机不确定，但是两次重绘时间间隔一定不小于(1/60)s，也就是大约**16ms**；
3. requestAnimationFrame API传入一个函数，控制这个函数精确在紧邻浏览器下次重绘前被调用。

# 2. requestAnimationFrame的机制

requestAnimationFrame中传入的函数，会被依次加入一个回调队列，这个回调队列中的全部函数都会在**浏览器下次重绘前**依次执行。

requestAnimationFrame(fn1)中，如果fn1内部再次调用requestAnimationFrame(fn2)，则传入的函数fn2会被放入下下次重绘前执行。

也就是说，如果递归调用requestAnimationFrame，则可以保证依次传入的函数fn1,fn2,fn3在每次重绘前依次执行。

> **微任务和requestAnimationFrame的执行顺序:**
>
> 先依次执行微任务队列，最后依次执行requestAnimationFrame回调函数队列。（保证requestAnimationFrame传入的函数紧贴着重绘执行）

# 3. 取消requestAnimationFrame

和setTimeout一样，通过返回的id进行取消。

```js
let a = requestAnimationFrame()
// 手动取消
cancelAnimationFrame(a)
```

取消后，requestAnimationFrame(fn)传入函数fn被从重绘前执行的回调队列中清除。

# 4. 典型应用：过渡的计数器

效果：

![过渡的计数器](/assets/posts/1.gif)

```js
// Marswiz @2021

let cur = 0;
let counting = false;

function count(target = 600, step = 10, anchor = '#counter') {
    counting = true;
    let container = document.querySelector(anchor);
    let i = cur;

    const show = function() {
        // 调用 requestAnimationFrame
        requestAnimationFrame(() => {
            container.innerText = i;
            i += step;
            cur += step;
            // 在 requestAnimationFrame 内部实现递归调用
            if (i <= target) show();
            else {
                // 递归出口
                container.innerText = target;
                cur = target;
                counting = false;
            }
        });
    }
    
    show();
}

document.querySelector('#btn-100').addEventListener('click', () => {
    if (!counting) count(cur + 100,  Math.floor(100/33));
});
document.querySelector('#btn-500').addEventListener('click', () => {
    if (!counting) count(cur + 500, Math.floor(500/33));
});
```

