---
layout: post
title: Vue3响应式原理基本概念及手动实现
date: 2021-4-12
categories: blog
tags: [Vue]
author: Mars
pIdentifier: 中文缩进
---

> 以前学的Vue3响应式基本原理和自己实现的代码，这里记录一下。

# 1.Vue3响应式基本实现原理

假设reacObj是Vue中的一个响应式对象，它具有属性a和b；

Vue3使用reactive(obj)函数，创建一个响应式的对象。

reactive内部使用track、effect和trigger三个关键方法来描述响应式过程：

- track(obj, property)：对obj中的property进行响应式追踪；
- effect: 依赖某一个响应式property的变量的计算方法函数；
- trigger(obj, property)：对依赖obj.property的所有变量计算方法进行重新调用。

基本流程是：

reacitive函数使用Proxy对响应式对象property的get和set操作进行捕获。

- 当get的时候，对属性进行track操作；
- 当set的时候，对属性进行trigger操作。

> 解释：
> 
> 当get操作被捕获，说明有变量计算需要访问这个响应式属性，也就是依赖这个属性，所以要对这次get操作的effect进行追踪，添加到dep中以便后续进行响应式更新。
>
> 当set操作被捕获，说明有变量被更改，那么需要找到这个变量的dep依赖集，并运行内部的全部方法，来更新依赖它的全部变量。

# 2.响应式对象内部属性的响应原理

对于属性a，如果我们用一个集合Set记录了依赖a的所有变量和它们的计算方法函数（这些计算方法函数叫做effect），在更新a的时候，将这些方法一一重新调用一遍，就可以实现a更改之后依赖它的变量的实时更新，也就是a属性成为了响应式的。

Vue中，为每个响应式对象内部属性所建立的Set对象称为一个dep（PS:dependency，依赖集），只要在修改任何响应式变量后，对应的依赖集dep内方法全部运行一次，就能实现其他变量的更新。

> 使用Set对象的理由是：它可以保证依赖集内部没有重复。

# 3.响应式对象本身的响应原理

一个响应式对象本身可能具有多个属性，需要为它们每个单独建立一个dep依赖集，然后用另一个映射Map将对象属性和dep一一对应。

当track另一个对象属性property2的时候，就把这个property2也添加到映射Map里，然后把所有依赖property2的变量计算方法添加到新的对应dep中，并在Map中与property2对应起来。

这样，这个Map就记录了这个对象obj的全部属性的依赖信息，并可以根据属性更新其对应的那一部分依赖变量。这个Map变量名为depsMap。

# 整个Vue应用实例的响应式原理

一个Vue应用实例，可能声明有多个响应式对象，每一个响应式对象及其内部属性都应该被记录并追踪(track)。

整个应用实例使用一个WeakMap，记录应用实例中的每个响应式对象。这个WeakMap为targetMap。

![响应式依赖图](/assets/posts/11.png)

# track(obj, property)的实现流程

track(obj, property)运行后：

1. 从targetMap中查找obj，如果没有就创建一个新的Map并赋值给obj对应的值，并作为depsMap返回。如果已经存在，则找到对应的depsMap；
2. 在找到的depsMap中，查找property。如果没有则创建一个新的Set，赋值给property对应的值作为dep，并返回这个dep。如果已经存在，则返回找到的Dep；
3. 在dep中加入全部effect。

# trigger(obj, property)的实现流程

trigger(obj, property)运行后：

1. 先从targetMap中查找obj，然后找到对应的depsMap；
2. 从depsMap中查找property，找出对应的dep；
3. 对dep中每一个effect进行执行。

> 弱映射WeakMap：只能储存对象，且当对象在其他地方没有引用的时候，WeakSet内的对象会被垃圾回收机制识别并回收。

# reactive()函数：将对象变成响应式

Vue使用reactive(obj)函数，将一个对象变成响应式对象。

官方教程代码如下：（示例，并非源码）

![reactive实现](/assets/posts/12.png)

> 因为在Vue3中，响应式是通过Proxy实现的，它不再单独为每个property设置get和set访问器，而是为每个property采取同样的操作方式。
>
> 因此，即使在声明的时候没有声明的property，后续在响应式对象中添加，也同样是响应式的。（与Vue2有区别）

# 手动实现Vue响应式代码

```js
// targetMap to store depMaps
let targetMap = new WeakMap();

// track and trigger function
function track(target, key, effect){
  // get depsMap from targetMap
  let depsMap, deps;
  if ( !targetMap.has(target) ){
    depsMap = new Map();
    targetMap.set(target, depsMap);
  } else {
    depsMap = targetMap.get(target);
  }

  // get deps from depsMap
  if ( !depsMap.has(key) ){
    deps = new Set();
    depsMap.set(key, deps);
  } else {
    deps = depsMap.get(key);
  }

  deps.add(effect);
  console.log(depsMap);
}


function trigger(target, key){
  let depsMap,deps;

  //If no deps or no depsMap , return directly, nothing to refresh.
  if ( !targetMap.has(target) ){
    return ;
  } else {
    depsMap = targetMap.get(target);
  }

  if ( !depsMap.has(key) ){
    return ;
  } else {
    deps = depsMap.get(key);
  }

  // run all the effect in deps. (Refresh Data.)
  for (let effect of deps){
    effect();
  }
  console.log(depsMap);
}

let added;
let effect = function (){
  added = a.num1 + a.num2;
};

function reactive(target){
  const handler = {
    get(target, key, receiver){
      track(target, key, effect);
      console.log();
      return target[key];
    },
    set(target, key, value, receiver){
      if ( target[key] != value ){
        target[key] = value;
      }
      trigger(target, key);
      return value;
    },
  };

  // return a new proxy of target.
  return new Proxy(target, handler);
}

let a = reactive({
  num1: 1,
  num2: 2,
});

effect();

a.num1  = 4;
console.log(added); //6

a.num2 = 40;
console.log(added); //44
```
