---
layout: post
title: 经典算法
date: 2021-11-19
categories: blog
tags: [Algorithm]
author: Mars
pIdentifier: 中文缩进
---

> 经典的算法。

# 1. Kadane 算法

Kadane算法，用于计算数组中连续子数组的最大或最小值。

## 1.1 计算连续子数组最大和、最小和

> **【1.求子数组最大和】**
>
> 求一个非空数组A中的一个子数组SubA，使得SubA中元素的加和最大。
>
> （子数组：在原数组中必须是连续的，长度最小为1。单个元素构成的数组和数组A本身也是A的子数组。）

Kadane算法，基于以下事实：

- 最终求得的子数组SubA一定以数组A中某一个元素A<sub>i</sub>作为结尾；
- SubA在原数组A中是连续的。

假设在位置i的元素为A<sub>i</sub>，则位置i+1的元素为A<sub>i+1</sub>。

以A<sub>i</sub>结尾的最大加和子数组SubA<sub>i</sub>，要么只是它本身自己构成，要么是和它相连的前面若干元素一同构成。设它前面的若干元素加和为K，那么此时加和Sum（A<sub>i</sub>）=K+A<sub>i</sub>。

如果SubA<sub>i</sub>只由自己本身构成，那么K=0。

这时考察以**A<sub>i+1</sub>**结尾的子数组**SubA<sub>i+1</sub>**。它有两个选择：

> ① 继续使用**A<sub>i</sub>**结尾的最大子数组，**SubA<sub>i+1</sub>**的加和可以表示为**K+A<sub>i</sub>+A<sub>i+1</sub>**，也就是 **Sum（A<sub>i+1</sub>）= Sum（A<sub>i</sub>）+A<sub>i+1</sub>**。
>
> ② 不继续沿用之前**A<sub>i</sub>**的最大子数组，而是自己单独成为一个子数组，如果之前的子数组**SubA<sub>i</sub>**的加和**Sum（A<sub>i</sub>）**对它而言是个累赘（为负）。这时**Sum（A<sub>i+1</sub>） = A<sub>i+1</sub>**;

这两种情况的取舍，取决于二者所得子数组加和哪个更大。也就是**Sum（A<sub>i+1</sub>）=Math.max(Sum（A<sub>i</sub>）+A<sub>i+1</sub>, A<sub>i+1</sub>)**。

因此得出Kadane算法如下：

> 1. 初始化 **maxSumHere = A\[0\]** 和 **max = A\[0\]**;
> 2. 对原数组A从左到右进行遍历，计算以每个数组元素位置i为结尾的子数组加和值maxSumHere，计算方法为：Sum（A<sub>i+1</sub>）=Math.max(Sum（A<sub>i</sub>）+A<sub>i+1</sub>, A<sub>i+1</sub>)；
> 3. 当前元素i计算完成后，更新max值。（最终结果为各个元素为结尾位置，而得到的子数组加和集的最大值。）
> 4. 返回max值即为结果。

```js
// Kadane's Algorithm
function kadanesAlgorithm(array) {
	let lastSubArrayMax = array[0];
	let totalMax = array[0];
	for(let i=1; i<array.length; i++){
        // Sum（Ai_+_1）=Math.max(Sum（A_i）+A_i_+_1, A_i_+_1)；
		if(lastSubArrayMax + array[i] < array[i]) lastSubArrayMax = array[i];
		else lastSubArrayMax = lastSubArrayMax + array[i];

        // Refresh the total Max Value.
		totalMax = Math.max(lastSubArrayMax, totalMax);
	}
	return totalMax;
}
```

计算连续子数组的最大和或最小和问题。
```js
// Kadane's Algorithm
// Max / Min
function kadane(arr){
    let curMax = arr[0]; // let curMin = arr[0]
    let max = arr[0];  // let min = arr[0];
    for(let i=1; i<arr.length; i++){
        curMax = Math.max(curMax+arr[i], arr[i]);  //  curMin = Math.min(curMin+arr[i], arr[i]);
        max = Math.max(max, curMax); // min = Math.min(min, curMin);
    }
    return max;
}
```
## 1.2 计算环形数组的连续子数组最大和、最小和

> [环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

如果原数组首尾连接，那么有两种情况：

1. 最大子数组包含首尾两个元素（覆盖了首尾连接成环的间隙）；
2. 最大子数组出现在原数组内部（不覆盖首尾连接成环的间隙）。

对于2情况，等同于一般的Kadane算法计算连续子数组最大和。

对于1情况，最大子数组包含了数组首尾连接点，则最小和一定出现在数组之中。此时**最大和 = 数组全部元素和 - 最小和**。

![环形数组](/assets/posts/19.png)

因此，可以使用Kadane算法，分别计算数组内（首尾不连接成环）的全部元素总和sum、最大和max和最小和min，然后返回sum-min和max中的最大值。

这里有一种特殊情况：当全部元素为负，min=sum，此时sum-max=0。此时max为元素中的最大值，应该返回max而非0。

```js
var maxSubarraySumCircular = function(nums) {
    let sum = nums[0];
    let curMin = nums[0], curMax = nums[0];
    let min = curMin, max = curMax;
    for(let i=1; i<nums.length; i++){
        sum += nums[i];
        curMax = Math.max(curMax+nums[i], nums[i]);
        curMin = Math.min(curMin+nums[i], nums[i]);
        max = Math.max(max, curMax);
        min = Math.min(min, curMin);
    }
// 全部元素为负，返回max而非0.
    return max < 0 ? max : Math.max(max, sum-min);
};
```

## 1.3 计算连续子数组乘积的最大值、最小值

> [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

乘积不同于加和，它的特点是：

1. 如果下一个元素为正，则包含下一个元素数组的最大乘积`max[i] = max[i-1] * num[i]`，最小乘积`min[i] = min[i-1] * num[i]`;
2. 如果下一个元素为负，则包含下一个元素数组的最大乘积`max[i] = min[i-1] * num[i]`，最小乘积`min[i] = max[i-1] * num[i]`。

因此，必须同时记录当前状态i的最大乘积max和最小乘积min，才能用于下一个状态i+1的计算。

```js
var maxProduct = function(nums) {
    let curMax = nums[0];
    let curMin = nums[0];
    let max = curMax, min = curMin;
    for(let i=1; i<nums.length; i++){
    // 无论情况如何，乘积最大值应该是这三者中的最大者，乘积最小值应该是最小者。 
        let a1 = curMax*nums[i], a2 = curMin*nums[i], a3 = nums[i];
        curMax = Math.max(a1, a2, a3);
        curMin = Math.min(a1, a2, a3);
        max = Math.max(max, curMax);
        min = Math.min(min, curMin);
    }
    return max;
};
```

# 2. KMP算法

KMP算法，用于解决查询字符串str1中是否存在子字符串str2的问题。

## 2.1 算法内容

![KMP](/assets/posts/KMP.png)

```js
function knuthMorrisPrattAlgorithm(string, substring) {
  
	function getSuffixPosition(str){
		let suffixPosition = new Array(str.length);
		suffixPosition.fill(-1);
		let j = 0;
		for(let i=1; i<str.length; i++){
			if(str[i] === str[j])	suffixPosition[i] = j++;
			else j=0;
		}
		return suffixPosition;
	}
	
	let suffixPosition = getSuffixPosition(substring);
	
	let i=0, j=0;
	while(i < string.length){
		if(string[i] === substring[j]){
			if(j === substring.length-1) return true;
			j++; i++;
		}
		else {
			if(j === 0) i++;
			else j = suffixPosition[j-1]+1;
		}
	}
	
	return false;
}
```

## 2,2 复杂度分析

时间： `O(m+n)`  

空间： `O(m)`

m为查询子串长度，n为被查询原字符串长度。 

原字符串被遍历一次，查询子字符串也被遍历一次（用来建立相同前后缀的位置数组suffixPosition）。

原字符串的每次遍历，最多与子字符串执行两次比较。因此，总时间复杂度为`O(2n+m) = O(m+n)`。

# 3. 打乱数组：Fisher–Yates shuffle 洗牌算法

## 3.1 算法内容

对于一个待打乱数组`arr`：

1. 指针`i`从末尾位置开始，选取从起始位置到i的闭区间`[0,i]`；
2. 在该区间内随机抽取一个数`pick`，将pick与i位置的元素进行交换，此时i位置元素确定，将i向前移动1个位置；
3. 重复1-2步骤，直到i到达起始位置0，结束打乱数组；

```js
    function rand(arr){
      for(let i=arr.length-1; i>0; i--){
        let pick = Math.floor(Math.random() * (i+1));
        [arr[pick], arr[i]] = [arr[i], arr[pick]];
      }
      return arr;
    }
```

该算法可以保证打乱的随机性。

## 3.2 复杂度分析

时间复杂度： O(n);
空间复杂度： O(1);

# 4. 寻找下一个更大排列

> [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

1. 从右到左找到`[i,i+1]`，使得`arr[i] < arr[i+1]`;
2. 从末尾向前搜索，找到第一个p，使得`arr[p] > arr[i]`;
3. 调换`arr[i]`和`arr[p]`；
4. 将i+1到数组末尾的部分反转（降序变升序），即找到下一个更大排列。

# 5. 颜色分类（荷兰国旗）

> [颜色分类](https://leetcode-cn.com/problems/sort-colors/)

将三个数0,1,2组成的随机数组，通过一次遍历，完成从小到大排列。

1. 设定左右指针l,r，分别代表下一个0和下一个2的位置（初始：l=0, r=length-1）；
2. 设置游标cur，时刻保证两个条件：
    - l <= cur <= r；
    - l的左边都是0，r的右边都是2；
3. 每次cur到达一个位置，都保证它要么触及左边界l，要么触及右边界r，要么为1才向后移动。

```js
    const sortColors = function(nums) {
        let l = 0, r = nums.length-1;
        let cur = 0;
    
        function swap(i,j){
            [nums[i],nums[j]] = [nums[j],nums[i]];
        }
    
        while(cur <= r){
            while(cur >= l && cur <= r && nums[cur] !== 1){
                if(nums[cur] === 0) swap(cur,l++);
                else if (nums[cur] === 2) swap(cur, r--);
            }
            cur++;
        }
    
        return nums;
    };
```

# 6. 寻找众数 —— Boyer-Moore 投票算法

> [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
> 
> [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

投票算法用来**寻找一个数字组成的数组中的众数（数目严格大于数组长度`length/n`的元素）**。

## 6.1 投票算法基本流程

对于找到数组中，个数大于`length/2`的元素:

**Boyer-Moore 投票算法基本过程如下：**

1. 设置一个候选人变量`candidate`，设置一个投票数变量`count=0`;
2. 对原始数组`nums`进行遍历，对每个`nums[i]`：
   1.1 如果`count=0`，赋值`candidate = nums[i]`；
   1.2 然后，判断：
      - 如果`candidtate === nums[i]`: count增加1；
      - 否则，count减小1；
3. 最终，`candidate`就是寻找的众数。

> **Moore 投票算法也可以用于找数目大于 length/n 的元素：**
> 
> 数目大于length/n的元素，最多只能有n-1个。Moore算法步骤如下：
> 
> 1. 设置n个候选人位置candidate，初始化为任意值；
> 2. 设置n个计票器count，初始化票数为0；
> 3. 遍历原数组`nums`的每个值i，对任意一个候选人t:
>       1. 如果: `nums[i] === candidate[t]`，且 `count[t] > 0`， 则`count[t]`增加1；
>       2. 如果：`count[t] === 0`，更换候选人`candidate[t] = nums[i]`;
>       3. 否则： 让各候选人的投票数`count[t]`都 `-1`。
> 4. 最后留下来的，其中一定有要寻找的数目大于 length/n 的元素（但并非全部都是）；
> 5. 再对原数组进行一次遍历，查看每个找到的元素，出现次数是否大于 length/n。

## 6.2 投票算法的证明

**Boyer-Moore 投票算法的证明：**

假设nums中，众数x一定存在，那么x的数目一定大于nums.length/2。

假设我们从左到右遍历数组`nums`：

1. 如果**全程count都没有变为0**：

那么，可知此时candidate一定为众数。

因为如果candidate不是众数，因为众数数目占优，遍历过程中count一定会被众数变成负值，从而经过变0的过程。

2. 对于任意位置`i`遍历之后，**如果`count=0`**:

- 如果`candidate`本身就是要寻找的众数x，那么可以知道包含i的左侧区间，非众数的数目n1等于众数x的数目n2，因为众数数目大于数组长度的一半，因此i右侧剩余数组众数依然为x；
- 如果`candidate`本身不是要寻找的众数x，那么可以知道包含i的左侧区间，众数x和其他非当前candidate的数之和，等于当前candidtate的数目，因此左侧区间众数x的数目小于当前candidate的数目，右侧区间众数依然为x；
- 因为右侧区间众数始终为x，所以对于最后一段区间，count一定不会再变为0，并且count最后一定不会是0(一定大于0)，这等同于第一种情况。

因此，最终candidate一定是众数。

```js
const majorityElement = function(nums) {
    let candidate;
    let count = 0;
    
    for (let i of nums) {
        if (count === 0) candidate = i;
        if (candidate === i) count += 1;
        else count -= 1;
    }

    return candidate;
};
```

# 7. 约瑟夫环问题

> [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

> **约瑟夫环问题：**
> 
> 假设有`n`个人围成一圈，编号为`0 ~ n-1`。给定一个数值m，从编号0开始起（作为第1个），每一轮向后数m个，将当前位置的人驱逐出去，然后下一轮从他的下一位开始数，以此类推，直到圈中只剩一个人，求最终剩下这个人的编号。

基本思路：

1. 每次从驱逐出去一个人，然后下一轮从他的下一位开始数，所以每轮圈中的人编号会发生变化；
2. 假设当前轮剩余`n`人，`f(n,m)`表示计算圈中还剩n人的时候，按这种每轮淘汰第m位的规则，最终会留下的人员编号；
3. 那么在当前轮之后，因为要淘汰掉一个，所以下一轮剩余`n-1`人，下一轮淘汰掉的人员编号为`f(n-1, m)`；
4. 但是，因为一轮之后，大家的编号要发生变化，必须找出前后两轮编号之间的对应关系：

![yuesefu](/assets/posts/37.png)

5. 因此，`f(n,m) = (f(n-1,m) + m) % n` ，当`n = 1`的时候，说明圈内只有一人，此时应返回他的编号`0`。

```js
var lastRemaining = function(n, m) {
    if (n === 1) return 0;
    return (lastRemaining(n-1, m) + m) % n;
};
```

# 8. Brian Kernighan 算法

> [201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)

Brian Kernighan 算法用来**消除一个数字二进制表示中，最右边的1（将其变为0）。**

算法实现：

对于一个数`n`：**将其进行`n = n & (n-1)`操作**。

> 例如：
> 
> n = 5时， n = (110)<sub>2</sub>。进行`n = n & (n-1)`操作后，n = 4 = (100)<sub>2</sub>
> 
> 消除了最右边的一个1.

# 9. LRU 缓存算法

> [LRU 缓存算法](https://leetcode-cn.com/problems/lru-cache/)
> 
> 描述： 
> 
> 设计一套缓存机制，容量最大为n。其中有put（key, value）和get（key）两个方法，put添加一条记录，get获取记录。
> 
> put和get都算作一次操作，当记录数目超过容量n时，删除最久未使用的记录。

算法实现：

1. 通过JS的`Map`数据结构可实现，它是有序的（遍历时是按照加入的顺序）；
2. `get(key)`操作时，如果查询到key，则将key从map中删除，然后将其重新添加到map，来更新key的记录顺序到最新；
3. `put(key,val)`操作时：
   1. 如果map中存在对应key，则同上面一样，先删除key，再添加key记录到最新的值val；
   2. 如果map中不存在对应key，则直接添加key，然后判断是否容量超限，如果超限则删除掉Map中遍历出来的第一个key记录（因为遍历是按照插入顺序，第一个是最早插入的）。

```js
var LRUCache = function(capacity) {
    this.map = new Map();
    this.capacity = capacity;
};

LRUCache.prototype.get = function(key) {
    if (this.map.has(key)) {
        let val = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, val);
        return val;
    }
    return -1;
};

LRUCache.prototype.put = function(key, value) {
    if (this.map.has(key)) {
        this.map.delete(key);
    }
    this.map.set(key, value);
    if (this.map.size > this.capacity) {
        let oldest = this.map.keys().next().value;
        this.map.delete(oldest);
    }
};
```

# 10. 素数筛

用于筛选从`2~n`范围内的质数。

## 10.1 埃氏筛选法

**基本思路：**

1. 假设要找的素数范围`range`是`[2,n]`；
2. 维护一个数组`deleted`，长度为`n+1`，初始时任何数都没有被筛除，数组值全部为`false`(表示未筛除)；
3. 从`i = 2`开始，每次取`deleted`中第一个未被筛除的数（索引为`i`），将它在`range`内的全部倍数都筛除掉（deleted对应位置`n*i`设为`true`）；
4. 因为：如果一个数`n`能被分解为因数之积`a*b`，那么只有两种情况：
   1. `a = b = sqrt(n)`；
   2. `a`和`b`一个大于sqrt(n)，另一个小于sqrt(n)。
5. 所以只要选取`i <= sqrt(n)`范围内的数，进行上述筛选，就可以完成全部范围内的筛选工作；
6. 返回全部`deleted[i] = false`的`i`的集合，即是要求的素数集。

```js
// 素数筛：埃氏筛
// O(n * ln(ln n))
// Mars 2021.11

function getPrime(n = 100) {
    let deleted = new Array(n + 1).fill(false);
    let primes = [];
    // 筛选到sqrt(n)即可
    let e = Math.sqrt(n);
    for (let i = 2; i <= e; i++) {
        if (!deleted[i]) {
            // -- 为何是 j=i 开始？
            // 只需要从当前找到的质数i之后进行筛除即可，之前的数已经被筛除过了。
            // 例如： 当前找到的数是5，那么不需要再对2*5, 3*5, 4*5进行筛除了，因为之前已经筛选过了，只需要从5*5开始。
            for (let j = i; i * j <= n; j++) {
                deleted[i * j] = true;
            }
        }
    }
    deleted.forEach((i, index) => {
        if (!i && index >= 2) primes.push(index);
    });
    return primes;
}
```

## 10.2 线性筛选法(欧拉筛)

埃氏筛选法中，一个合数可能会被多个素数筛除：

例如`12`会被`2`和`3`筛除，从而多次执行`delete[12] = true`操作。

线性筛选法降低时间复杂度到`O(n)`，其中主要是避免了这种情况。它的基本思想：

**对于一个合数，只被它最小的质因数筛除。**

在线性筛中，`12`这个数只被`2`筛除一次，不会被`3`筛除。

**基本思路：**

1. 与埃氏筛相同，假设要找的素数范围`range`是`[2,n]`；
2. 维护一个数组`deleted`，长度为`n+1`，初始时任何数都没有被筛除，数组值全部为`false`(表示未筛除)；
3. 同时维护一个被筛选出的质数数组`primes`，初始为空数组；
4. 从`i = 2`开始遍历`deleted`（不论其是否已被筛除掉），如果`deleted[i] = false`（没被筛除），则将`i`加入到`primes`数组中；
5. 然后遍历数组`primes`，对每一个已查找到的质数`s = primes[j]`：
   1. 如果`i % s === 0`，说明当前的数`i`不是最小的质因数，应该停下当前的筛选过程（停止遍历primes）；
   2. 否则，如果`s*i <= n`，筛除掉`s * i`这个数：`deleted[s*i] = true`;
6. 当全部筛选完毕，`primes`中即是结果素数集。

```js
// 素数筛：线性筛
// O(n)
function getPrime2(n = 100) {
    let deleted = new Array(n + 1).fill(false);
    let primes = [];
    for (let i = 2; i <= n; i++) {
        if (!deleted[i]) primes.push(i);
        for (let j of primes) {
            if (j * i > n) break;    // 只筛选范围内的数
            deleted[j * i] = true;   // 利用当前已找到素数j，对i*j进行筛除
            if (j % i === 0) break;  // 如果当前素数j是i的因数，那么直接结束j后续的循环，因为i=n*j，后续的数应该用j进行删除而不是j之后的
        }
    }
    return primes;
}
```