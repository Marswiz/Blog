---
layout: post
title: 经典算法
date: 2021-7-5
categories: blog
tags: [Algorithm]
author: Mars
pIdentifier: 中文缩进
---

> 经典的算法。

# 1. Kadane 算法

Kadane算法，用于计算数组中连续子数组的最大或最小值。

## 1.1 计算连续子数组最大和、最小和

> **【1.求子数组最大和】**
>
> 求一个非空数组A中的一个子数组SubA，使得SubA中元素的加和最大。
>
> （子数组：在原数组中必须是连续的，长度最小为1。单个元素构成的数组和数组A本身也是A的子数组。）

Kadane算法，基于以下事实：

- 最终求得的子数组SubA一定以数组A中某一个元素A<sub>i</sub>作为结尾；
- SubA在原数组A中是连续的。

假设在位置i的元素为A<sub>i</sub>，则位置i+1的元素为A<sub>i+1</sub>。

以A<sub>i</sub>结尾的最大加和子数组SubA<sub>i</sub>，要么只是它本身自己构成，要么是和它相连的前面若干元素一同构成。设它前面的若干元素加和为K，那么此时加和Sum（A<sub>i</sub>）=K+A<sub>i</sub>。

如果SubA<sub>i</sub>只由自己本身构成，那么K=0。

这时考察以**A<sub>i+1</sub>**结尾的子数组**SubA<sub>i+1</sub>**。它有两个选择：

> ① 继续使用**A<sub>i</sub>**结尾的最大子数组，**SubA<sub>i+1</sub>**的加和可以表示为**K+A<sub>i</sub>+A<sub>i+1</sub>**，也就是 **Sum（A<sub>i+1</sub>）= Sum（A<sub>i</sub>）+A<sub>i+1</sub>**。
>
> ② 不继续沿用之前**A<sub>i</sub>**的最大子数组，而是自己单独成为一个子数组，如果之前的子数组**SubA<sub>i</sub>**的加和**Sum（A<sub>i</sub>）**对它而言是个累赘（为负）。这时**Sum（A<sub>i+1</sub>） = A<sub>i+1</sub>**;

这两种情况的取舍，取决于二者所得子数组加和哪个更大。也就是**Sum（A<sub>i+1</sub>）=Math.max(Sum（A<sub>i</sub>）+A<sub>i+1</sub>, A<sub>i+1</sub>)**。

因此得出Kadane算法如下：

> 1. 初始化 **maxSumHere = A\[0\]** 和 **max = A\[0\]**;
> 2. 对原数组A从左到右进行遍历，计算以每个数组元素位置i为结尾的子数组加和值maxSumHere，计算方法为：Sum（A<sub>i+1</sub>）=Math.max(Sum（A<sub>i</sub>）+A<sub>i+1</sub>, A<sub>i+1</sub>)；
> 3. 当前元素i计算完成后，更新max值。（最终结果为各个元素为结尾位置，而得到的子数组加和集的最大值。）
> 4. 返回max值即为结果。

```js
// Kadane's Algorithm
function kadanesAlgorithm(array) {
	let lastSubArrayMax = array[0];
	let totalMax = array[0];
	for(let i=1; i<array.length; i++){
        // Sum（Ai_+_1）=Math.max(Sum（A_i）+A_i_+_1, A_i_+_1)；
		if(lastSubArrayMax + array[i] < array[i]) lastSubArrayMax = array[i];
		else lastSubArrayMax = lastSubArrayMax + array[i];

        // Refresh the total Max Value.
		totalMax = Math.max(lastSubArrayMax, totalMax);
	}
	return totalMax;
}
```

计算连续子数组的最大和或最小和问题。
```js
// Kadane's Algorithm
// Max / Min
function kadane(arr){
    let curMax = arr[0]; // let curMin = arr[0]
    let max = arr[0];  // let min = arr[0];
    for(let i=1; i<arr.length; i++){
        curMax = Math.max(curMax+arr[i], arr[i]);  //  curMin = Math.min(curMin+arr[i], arr[i]);
        max = Math.max(max, curMax); // min = Math.min(min, curMin);
    }
    return max;
}
```
## 1.2 计算环形数组的连续子数组最大和、最小和

> [环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

如果原数组首尾连接，那么有两种情况：

1. 最大子数组包含首尾两个元素（覆盖了首尾连接成环的间隙）；
2. 最大子数组出现在原数组内部（不覆盖首尾连接成环的间隙）。

对于2情况，等同于一般的Kadane算法计算连续子数组最大和。

对于1情况，最大子数组包含了数组首尾连接点，则最小和一定出现在数组之中。此时**最大和 = 数组全部元素和 - 最小和**。

![环形数组](/assets/posts/19.png)

因此，可以使用Kadane算法，分别计算数组内（首尾不连接成环）的全部元素总和sum、最大和max和最小和min，然后返回sum-min和max中的最大值。

这里有一种特殊情况：当全部元素为负，min=sum，此时sum-max=0。此时max为元素中的最大值，应该返回max而非0。

```js
var maxSubarraySumCircular = function(nums) {
    let sum = nums[0];
    let curMin = nums[0], curMax = nums[0];
    let min = curMin, max = curMax;
    for(let i=1; i<nums.length; i++){
        sum += nums[i];
        curMax = Math.max(curMax+nums[i], nums[i]);
        curMin = Math.min(curMin+nums[i], nums[i]);
        max = Math.max(max, curMax);
        min = Math.min(min, curMin);
    }
// 全部元素为负，返回max而非0.
    return max < 0 ? max : Math.max(max, sum-min);
};
```

## 1.3 计算连续子数组乘积的最大值、最小值

> [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

乘积不同于加和，它的特点是：

1. 如果下一个元素为正，则包含下一个元素数组的最大乘积`max[i] = max[i-1] * num[i]`，最小乘积`min[i] = min[i-1] * num[i]`;
2. 如果下一个元素为负，则包含下一个元素数组的最大乘积`max[i] = min[i-1] * num[i]`，最小乘积`min[i] = max[i-1] * num[i]`。

因此，必须同时记录当前状态i的最大乘积max和最小乘积min，才能用于下一个状态i+1的计算。

```js
var maxProduct = function(nums) {
    let curMax = nums[0];
    let curMin = nums[0];
    let max = curMax, min = curMin;
    for(let i=1; i<nums.length; i++){
    // 无论情况如何，乘积最大值应该是这三者中的最大者，乘积最小值应该是最小者。 
        let a1 = curMax*nums[i], a2 = curMin*nums[i], a3 = nums[i];
        curMax = Math.max(a1, a2, a3);
        curMin = Math.min(a1, a2, a3);
        max = Math.max(max, curMax);
        min = Math.min(min, curMin);
    }
    return max;
};
```
