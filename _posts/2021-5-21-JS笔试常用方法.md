---
layout: post
title: JS笔试：数据结构、算法和技巧
date: 2021-5-21
categories: blog
tags: [JavaScript]
author: Mars
pIdentifier: 中文缩进
---

> 记录笔试常用方法技巧
>

# 写在前面
## 算法的复杂度

### 基本操作

在普通的计算机上，**加减乘除**、**访问变量**（访问基本数据类型的变量）、**给变量赋值**等都可以看作基本操作。

**对基本操作的次数统计或是估测，可以作为评判算法用时的指标。**

> 不同的基本操作，其实执行用时是不同的（除法比加法用时长），这种不同在计算时间复杂度的时候因过小被忽略。

### 数据规模

衡量一个算法的快慢，一定要考虑数据规模的大小。

所谓数据规模，一般指输入的**数字个数**、输入中**给出的图的点数与边数**等等。

一个数据规模，一般用一个字母来表示（m、n等）。

### 时间复杂度

**程序执行的用时随数据规模而增长的趋势**，叫做时间复杂度。

时间复杂度分为**最坏时间复杂度**和**平均时间复杂度**。

> **最坏时间复杂度**，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。
> 
> **平均（期望）时间复杂度**，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。

## 算法为何高效

- 计算机解决问题，本质上都是**穷举出所有可能结果**，然后进行比较选择；
- 计算的问题可能性越多，就从本质上决定了计算的复杂度越大；
- 提升算法效率，无非是以下几个途径：
    - 通过逻辑分析，减少计算步骤，充分**避免无意义的计算步骤**；
    - 通过充分利用已经计算的结果，避免重复计算；
    - 通过合并操作，减少高成本的操作次数。

# 栈、队列和哈希表

## 栈
### 单调栈

> 单调栈：栈内的元素索引值单调递增，且元素值从底向顶也单调递增或单调递减。
> 
> 单调栈同普通栈一样，元素只能在栈顶进出。

单调栈的目的是，随着原序列的遍历，维护一个局部最优的子序列。属于贪心算法的工具。

单调栈可以用来解决：

- 查找数组中每个元素下一个大于自身的值；
- 查找最小或最大子序列；

> [找出最具竞争力的子序列](https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/)
> 
> [移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

## 队列

队列是"先进先出（FIFO）"的数据结构。

### 单调队列

> 单调队列：队列中元素的索引值单调递增，且队列中的元素值单调也递增（或递减）。
> 
> 单调队列与普通队列不同，一般为双端队列。元素可以在两侧出队，而只能在队尾入队。
>
> Out: `Head <- [a,b,c,d] -> Tail`;
>
> In: `[a,b,c,d] <- Tail`

单调队列在滑动窗口中应用，可以获取窗口内的最大、最小值。操作如下：

1. 设置单调队列queue，初始值为空；（假设我们要保存的是窗口的最大值，queue为单调递减队列）
2. 假设窗口左指针为left，右指针为right。当窗口扩大时，right向右移动，此时判断新加入窗口的元素`arr[right+1]`与queue队尾的元素大小关系：
    - 如果`arr[right+1] > queue[queue.length-1]`，说明有新的最大值加入，这里因为queue中的元素都比新加入的元素更靠前，因此在left到达right+1位置之前`queue[queue.length-1]`绝不可能再成为最大值，因此可以将它在队尾删除；
    - 同理，删除后还需要对下一个队尾值进行比较删除操作，直到队空或队尾元素值**大于等于**新值，将新值从队尾加入队列；（等于的情况需要保留，因为之前加入的值仍然是最大值。）
    - 这样就保证了单调队列的两个特性：索引和值都单调递增。
3. 当窗口需要缩小，left向右移动，事项如下：
    - 在窗口中不存在的元素，需要从队列中删除；
    - 因为left <= right，当前要删除的left元素最先加入队列，因此它要么在队列的最前面，要么已经被后来的最大值淘汰，被从队尾删除掉；
    - 此时只需判断队首元素是否是left对应的元素，如果是则将它从队首出队，如果不是则不用做任何操作。
4. 每次窗口移动，队首的元素就是当前窗口内的最大值。

> [窗口中的最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
> 
> [绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

## 哈希表

适用于：**计数类问题。哈希表可以快速判断一个值是否出现在集合中，而避免了每次都要遍历查找**。

缺点是空间复杂度高，是以空间换时间的方法。

哈希结构：**数组、对象、Set、Map**

### 哈希表计数去重

> **使用哈希表计数两数组合，如何能不重复？**
>
> *`给出一个数组arr，求数组中子序列 [a,b] 加和 a+b=target 的组合数。`*
>
> 使用暴力解法时间复杂度为`O(n^2)`，可以使用两个嵌套for循环，通过索引来实现无重复计数。
>
> 使用一个哈希表map，可以实现`O(n)`复杂度的算法。但是如果采用**先将数组元素添加到map统计数目，后遍历map计算组合数**的方式，计算的组合数将包含重复情况：
>
> **例如:**  map = {1: 3, 2: 3} ，target = 3，遍历map时，会得到`[1,2]`+`[2,1]` 共计18种组合，实际上只有9种。
> 
> **可以采用边统计，边计数的方式，避免这种重复计数的情形：**
>
> - **每次将元素i放入map前，先计算 map 中 target-i 的数目num，将其加入计数结果count；**
> - **将元素放入map，它对应在map中的数目+1.**
>
> 这样做可以避免重复计数（`[a,b]`和`[b,a]`）的原因是：
> 
> 如果a和b是一对待计入组合，那么按照这种依次加入的方式，他们加入map一定有先后顺序。我们只在二者中后加入map的一方加入map的时候计数。因为所有元素最终一定都被添加到map，他们之间两两存在先后顺序，也就是说如果存在任意组合需要被计入，只会在组合元素最后一次被添加的时候计数，也就是只会计数一次。

## 数组

### 差分数组

#### 定义和适用情况

**差分数组**：对于一个源数组arr，差分数组`diff[i]`定义如下：

1. `diff[0] = 0;`
2. `diff[i] = arr[i] - arr[i-1]; (i > 0)`

差分数组主要用于**对原数组子区间内元素，进行统一增减操作**的情况，可以更方便地合并区间操作（降低时间复杂度），更直观地显示出操作结果。

#### 差分数组的性质

> [差分数组是个啥](https://blog.csdn.net/qq_44786250/article/details/100056975)

对于一个数组arr，计算它的差分数组diff，如果它的子区间`[a,b]`进行统一的增减n的操作，diff数组的变化如下：

- 统一增大n：`diff[a]增大n，diff[b+1]减小n`，其他不变；
- 统一减小n: `diff[a]减小n，diff[b+1]增大n`，其他不变；

> 也就是说，区间`[a,b]`同时增减操作，只影响差分数组的区间**头位置a**和**尾位置+1位置b+1**，diff[a]与变化方向相同，diff[b+1]与变化方向相反，变化值绝对值相同都为n。

从另一个角度考虑，在对区间`[a,b]`进行了统一增加n操作后，**diff的`[a,b]`区间前缀和统一增加了n，而其他位置前缀和不变。**

> 因为+n发生在`diff[a]`位置，-n发生在`diff[b+1]`位置，而中间的元素不变。
> 
> 所以`[a,b]`区间内前缀和都统一增加了n，而到b+1位置恢复，b+1之后的前缀和没有变化。

#### 差分数组的好处

差分数组将一个区间内的操作，转化为在两个端点的操作，省去了遍历整个区间的过程，减少了时间复杂度。

差分数组应用实例：

> [1893.区间是否被全覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)

### 前缀和

对于一个数组arr的索引i，前缀和也就是求区间`[0,i]`中数组所有元素的和。

对于一个**子数组（连续）的所有元素之和，等于它首尾位置前缀和之差**。这有时可以用于降低复杂度。

> [和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

## 哈希数组

> [1146. 快照数组](https://leetcode-cn.com/problems/snapshot-array/)

哈希数组，数组的每一个元素为一个哈希表，适用于需要保存数组元素各个变化状态的情况。

数组元素`arr[i]`每次变化，将变化存储在`i`对应位置的哈希表中，需要时从哈希表中取出对应状态的值即可。这样没有变化的元素不会被额外存储，造成空间浪费。

# 二叉树、BST、Trie
## 二叉树 Binary Tree
### 二叉树的前、中、后序遍历

**二叉树前中后序遍历的迭代的统一写法思路：**

- 使用一个栈stk来保存遍历的路径，使用Res数组记录结果；
- 因为栈的入栈与出栈顺序相反，所以入栈顺序需要与前、中、后序遍历的顺序相反（**前序：** 中→左→右，**入栈：** 右→左→中）；
- 只有在中间元素出栈的时候才记录结果到res数组；
- 在中间元素后面添加一个null元素，作为它出现在中间位且没被res数组记录的标志，一旦在出栈过程中出现null，说明此时应该向res添加记录下一个元素；
- 直到栈stk为空，结束迭代。

例如： 

```js
// 后序遍历：

// 遍历：左右中
// 入栈：中右左
function postOrderIterate(root){
    let stk = [root];
    let res = [];
    while(stk.length !== 0){
        let cur = stk.pop();
        if(cur === null){
            res.push(stk.pop().value);
            continue;
        }
        stk.push(cur, null); // 中 （记录标志为null）
        if(cur.right) stk.push(cur.right); // 右
        if(cur.left) stk.push(cur.left);   // 左
    }
    return res;
}
```

## 字典树 Trie

字典树由字符串生成，形式是嵌套的哈希表形成的树结构。

字典树以输入字符串的每位字母为键名，

字典树可以用于文本推断、自动填充等场景。

**时间复杂度：**

- 构建、插入： O(n)
- 查询： O(n)

**空间复杂度：**

- 构建、插入： O(n)
- 查询： O(1)

### 构建字典树：前缀、后缀

![Trie](/assets/posts/trie.svg)

构建前缀、后缀字典树Trie的步骤：

1. **初始化：**设置根节点为一个空哈希表(Map或空对象)，也可以在内部设置各种结尾的标志符；
2. **插入操作：**从插入字符串的0位置（前缀）或末尾位置（后缀）开始，向后（前）遍历，设置初始哈希表cur为根节点，对于每一位的字符letter，执行如下操作：
   -  ① 在当前哈希表中查找letter键名，如果不存在，则在cur中为letter创建一个新哈希表；
   -  ② 将cur指向letter对应的哈希表，在letter哈希表设置对应的结束标志为true（如果构建前缀树，每步都设置前缀结束标志为true，最后词尾设置词汇结束标志true）；
   -  ③ 继续遍历，直到字符串尽头，完成插入；
3. **查询操作：**从插入字符串的0位置（前缀）或末尾位置（后缀）开始，向后（前）遍历，设置初始哈希表cur为根节点，对于被查询字符串query每一位的字符letter，执行如下操作：
   -  ① 在当前哈希表中查找letter键名，如果不存在，则说明没有此查询字符串，返回false结束；
   -  ② 将cur指向letter对应的哈希表，继续查询；
   -  ③ query全部查询完毕后，判断此时cur中各结束标志是否为true（比如查询前缀query，那么此时前缀结束标志应该是True），如果为true则返回ture，否则返回false。

# 并查集
## 定义
并查集是一种算法，它操作一组互不相交的集合，可进行高效**集合合并**和**查询两个元素是否在同一集合**的操作。

## 基本思路
1. 一个集合用一个代表元素来表示，称为**代表元**。判断两个集合是否相同，被简化为判断两个集合的代表元是否相同；
2. 一个集合被组织成一个树形结构，代表元是这个树的根元素；
3. 集合中的每个元素`x`，具有根据`x`本身访问它父元素的途径`parent(x)`；
4. 根元素的`parent`，指向它自己，也就是`parent(x) = x`；
5. 查找一个元素`x`的代表元，只需要不断迭代查询元素的`parent(x)`，即可最终找到集合的根元素；

## 并查集的方法
1. 初始化：每个元素的父节点各自指向自身，因为它们独立组成集合，还没有合并；
2. 查询：两个元素是否在同一集合中；
3. 合并：将两个集合合并成一个；

## 并查集的优化
### 记录集合高度
对于每个集合，记录集合树的高度`rank`，在合并的时候，**将较小`rank`的集合连接到较大`rank`的集合树上**，可以减小合并后树的高度。

### 路径压缩
对于每次查询，如果查询到元素`a`所在集合的根元素是`root_A`，那么直接把`a`连接在`root_A`上，这样下次查询可以省去多级遍历的过程。

> 路径压缩后，集合树的高度可能有所变化，但是一般为简单起见，路径压缩后树的高度rank保持不变。

### 并查集的实现

可以用数组实现，也可以用哈希表。

用数组实现，是每个数组位置代表一个元素，同时定义`parent`数组和`rank`数组，记录每个位置的元素的父元素和它为根节点树的高度。

用哈希表实现，是每个元素的值作为键名，键值为一个对象，将`parent`和`rank`储存在其中。

```js
// HashMap Implementation
class BingChaJi {
    constructor(vals = []) {
        this.map = new Map();
        for (let v of vals) {
            this.map.set(v, {
                rank: 1,
                parent: v,
            });
        }
    }

    findParent(v) {
        let m = this.map;
        let p = m.get(v)['parent'];
        if (p === v) return v;
        else {
            let root = this.findParent(p);
            this.map.get(v).parent = root;
            console.log(`${v}'s parent is set to ${root}`);
            return root;
        }
    }

    isSameSet(v1, v2) {
        let root1 = this.findParent(v1);
        let root2 = this.findParent(v2);
        return root1 === root2;
    }

    merge(v1, v2) {
        let root1 = this.findParent(v1);
        let root2 = this.findParent(v2);
        if (root1 === root2) return;
        let r1 = this.map.get(root1).rank;
        let r2 = this.map.get(root2).rank;
        if (r1 < r2) {
            this.map.get(root1).parent = root2;
            console.log(`root is ${root2}`);
        } else {
            this.map.get(root2).parent = root1;
            console.log(`root is ${root1}`);
        }
        if (r1 === r2) {
            this.map.get(root1).rank += 1;
            console.log(`rank is set to ${this.map.get(root1).rank}`);
        }
    }
}
```

# 图

# DFS深度优先搜索
## 记忆化DFS搜索

记忆化DFS搜索，就是在DFS搜索的基础上，添加一个哈希表（或数组），用于保存计算过的结果（备忘录）。

当备忘录中存在结果时，直接返回。否则再进行计算+存储。

记忆化搜索是以空间换时间，可以降低时间复杂度。

> [638. 大礼包](https://leetcode-cn.com/problems/shopping-offers/)

基本思路：

1. 先对原大礼包数组进行筛选，**不划算的**或**礼包中某一物品数量多于所需数量的**，都要筛除；
2. 搜索从当前需求`need = needs`开始，对于每一个`need`数组，它都对应着一个`最低购买价格`，我们把求出这个最低价格的函数叫做`getMinPrice()`，则对于需求need的最低价格为`min = getMinPrice(need)`；
3. 下面是`getMinPrice()`函数的实现：
   1. 最坏情况是，我们的需求，一个大礼包也买不了，这时需要原价买入所有的物品，假设此时价格为`originalPrice`；
   2. 对于每一个大礼包，我们现在已知买入它们都是划算的（因为筛选过，但它们划算程度不同）。我们要找到所有大礼包中，买入后能满足当前需求，且总价格最低的；
   3. 对于每一个大礼包，如果礼包中各物品的数量，都≤当前需求物品数量，则大礼包可以买入。反之，则不能买入。
   4. 我们遍历所有大礼包，对于一个大礼包`s`，它内部物品数目列表为`sn`，如果它可以买入，那么它买入后，下次我们的需求就变成了`need - sn`（数组各位分别减去对应物品数目）。那么它买入后需求的最低购入价格就是`getMinPrice([need - sn])`，因此，买了这个礼包后，我们的购入价格是`price_need = getMinPrice([need - sn]) + price_s`；
   5. 遍历所有大礼包，对每一个能买入的礼包`s`，都计算`price_need = getMinPrice([need - sn]) + price_s`，则达成当前需求need的最低费用是: 原价购买价格`originalPrice`与所有`price_need `中的最小值；
4. 每次找到当前need的最低购入价格，就把它放在备忘录`map`中，键名是当前need形成的字符串`need.join('-')`，键值是价格；
5. 如果当前`need`的最低购入价格在备忘录中存在，则直接返回，省去计算步骤；
6. 要找的结果是最后备忘录中初始需求`needs`对应的价格。

# BFS广度优先搜索

广度优先搜索从几个节点出发，这些节点本身组成一层。他们可到达的节点组成新的一层，在本层遍历完成后遍历，依次这样分层遍历，直到全部遍历完成。

广度优先搜索一般借助一个**队列q**来实现，每次从队列头部取出一个元素n，然后把这个元素n的下一层元素添加到队列末尾，这样可以保证元素按序分层遍历。

> [地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

# 动态规划（Dynamic Programming）

## 背包（零钱）问题

背包问题有两种形式： 

- ① **0-1背包问题：** 背包内的东西只能取一次；
- ② **完全背包问题：** 背包内的东西是无限的。

> 0-1背包问题:[加减的目标值](https://leetcode-cn.com/problems/YaVDxD/)
> 
> 完全背包问题：[零钱问题2](https://leetcode-cn.com/problems/coin-change-2/)

### 0-1背包问题

[详解0-1背包问题](https://www.cnblogs.com/kkbill/p/12081172.html)

主要思想是建立一个二维DP数组，行坐标代表物品集合，列坐标代表背包的容量。

`dp[r][c]`的含义是： 背包容量为c的情况下，仅由前r个物品组成，能装下的最大价值。

这样对于一个`[r,c]`组合，有两种选择：

- 选择装下这个物品r：假设物品r本身重量为wr，价值为vr，那么背包剩余容量为c-wr，物品r已经装入，只能从`[0,r-1]`物品区间继续装入，此时能装下的最大价值为`dp[r-1][c-wr]`。 因此这种情况的最大价值为`vr+dp[r-1][c-wr]`；
- 放弃装这个物品r：最大价值与r-1个物品时一样。为`dp[r-1][c]`。

每次选二者之中较大者。

因为每次值只用到了r-1和r两行数据，可以对dp数组进行压缩。

> 最大可以压缩为一行。每次需要从右到左更新数据。(见上面的详解最下方。)

### 完全背包问题

给出零钱和目标值，求组成目标值的方法数。（比如由1,2,5组成10元有几种方法）

对于完全背包问题，存在一个for循环先后顺序导致的，排列数和组合数的问题。

> **详细说明：**
>
> 动态规划解题，可以想到将钱数amount和钞票面值note联系起来: 组成一个目标值amount的方法数，等于所有钞票面值note对应的amount-note的方法数加在一起。`dp[amount] = sum( dp[amount-note] )`
>
> 比如： 如果给出钞票`[3,10]`，那么组成目标钱数20的方法数，应该等于组成20-3=17和20-10=10的方法数之和。因为组成17的每一个方法，再加上一张3元的钞票，就都可以组成目标值20，另一个例子同理。
>
> 可以用两层for循环分别遍历amount数组和notes数组，动态更新amount数组的值： `amount[i] += amount[i-note]`。
>
> 但是这里存在一个遍历顺序问题：
>
> - **① 如果先遍历amount，后遍历notes，则意味着：对于每个目标值，都直接穷举所有当前可能的钞票组合，之后再进入下一个目标值进行更新。**
>
> - **② 如果先遍历notes，后遍历amount，则意味着：对于每个钞票note，先计算并更新单独由这个note组成各个目标值的方法数，然后再进入下一个面额note，再更新这个新面额和之前所有面额组成的方法数。**
>
> 对于情况①，计算出来的是所有的排列数。对于情况②，计算出来的是组合数。
>
> 本题不同排列同一组合，视为同一个方法，因此应该使用第二个遍历方式。
>

## 股票买卖

> [股票买卖](https://www.algoexpert.io/questions/Max%20Profit%20With%20K%20Transactions)
>
> 给你一个每日股票价格组成的数组prices（索引是日期，值是价格），和一个可交易次数k。编写返回可实现的最大收益的函数。
> 
> 股票同时期最多只能持有一份，一次也只能交易一份。也就是如果持有，必须先卖出才能再买入。

**思路分析：**

1. 一天可以有三种选择：买入、卖出、不操作；
2. 只有卖出才能获得收益；
3. 卖出必须先买入；
4. 如果不操作，则总收益和之前一天的收益相同。

基于以上四点，可以得出下面的算法：

> 对于某一天，只关注卖出操作。我们可以选择**卖出**或**不卖出**。
> 
> - 如果卖出， 则之前必定有一天进行了买入。此次交易赚取收益为`price[sell]-price[buy]`；
> - 如果不卖出，则总收益与前一天收益相同；
> 
> 设置一个矩阵，每一行代表最大可交易次数k，每一列代表交易日期day。每一个元素代表最大交易次数为k时，当前日期所能达到的最大收益。
>
> 则有如下关系： 
>
> ![股票买卖](/assets/posts/20.png)

```js
function maxProfitWithKTransactions(prices, k) {

	if(prices.length < 2) return 0;
	
	let dp = new Array(2);
	dp[0] = new Array(prices.length) .fill(0);
	dp[1] = new Array(prices.length);
	let trans = 1;
	while(trans <= k){
		for(let i=0; i<prices.length; i++){
			if(i === 0) dp[1][i] = 0;
			else {
				let notSellMaxProfit = dp[1][i-1];
				let sellMaxProfit = -Infinity;
				for(let buyDay=i-1; buyDay>=0; buyDay--){
					sellMaxProfit = Math.max(sellMaxProfit, prices[i]-prices[buyDay]+dp[0][buyDay]);
				}
				dp[1][i] = Math.max(notSellMaxProfit, sellMaxProfit);
			}
		}
		dp[0] = dp[1];
		dp[1] = new Array(prices.length);
		trans++;
	}
	return dp[0][prices.length-1];
}
```
## 三个无重叠子数组最大和

> [三个无重叠子数组最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

使用动态规划方法解题。步骤如下：

1. 先遍历数组，用一个map记录以i位置为结束位置的长度为k的子数组的加和，i<k-1的值都为0，因为元素数目不够。（map.get(i)是`[i-k+1, i]`区间的加和）；
2. 使用一个二维dp数组保存计算结果。
    - dp的行n取值从0到3，代表可以选取的不相交子数组个数；
    - dp的列i取值从0到nums.length-1，代表结束位置；
    - 因此，`dp[n][i]`代表可以取n个子数组时，`[0,i]`区间内可以取到的n个子数组的最大和。
3. 当n=0时，`dp[n][i]`全部为0；其他情况下，当进行`dp[n][i]`的取值时，分为以下两种情况：
    - 不使用当前位置i构成的子数组map.get(i)：`dp[n][i] = dp[n][i-1]`
    - 使用当前位置i构成的子数组map.get(i): 则子数组`[i-k+1,i]`一定被使用了，当前dp值应该为 `dp[n][i] = dp[n-1][i-k] + map.get(i)`
4. 当n=3，保留结果中的最大值和它对应的索引值index；
5. 反向查找dp表，获得各子数组起始索引：
    - 对于一个值`dp[n][i]`，如果它使用了i位置的子数组，那么`dp[n][i]`一定大于`dp[n][i-1]`；
    - 从n=3开始找，一直到n=1，保存结果值返回即可。 


```js
var maxSumOfThreeSubarrays = function(nums, k) {
    let map = new Map();
    let first = 0;
    for(let i=0; i<k; i++){
        first += nums[i];
        map.set(i,0);
    }
    map.set(k-1, first);
    for(let i=k; i<nums.length; i++){
        let cur = nums[i];
        let prev = nums[i-k];
        let sum = map.get(i-1) + cur - prev;
        map.set(i, sum);
    }

    let dp = new Array(4).fill(0).map(i => new Array(nums.length).fill(0));
    let max = -Infinity;
    let index = 0;
    for(let n=1; n<4; n++){
        for(let i=0; i<nums.length; i++){
            let notUsed = i-1 >= 0 ? dp[n][i-1] : 0;
            let used = i-k >= 0 ? map.get(i) + dp[n-1][i-k] : map.get(i);
            dp[n][i] = Math.max(notUsed, used);
            if(n === 3 && dp[n][i] > max){
                max = dp[n][i];
                index = i;
            }
        }
    }

    function findIndex(i){
        let n = 3;
        let res = [0,0,0];
        while(n > 0){
            while(i >= 0 && dp[n][i] === dp[n][i-1]){
                i--;
            }
            res[n-1] = i-k+1;
            i = i-k;
            n--;
        }
        return res;
    }
    
    return findIndex(index);
};
```
## 最长回文子序列

> [Leetcode516: 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

**思路:** 

1. 回文序列首尾元素一定相同；
2. 设置一个二维dp数组，`dp[i][j]`代表从`[i,j]`区间的最长子序列长度；
3. `dp[i][j]`递推根据首尾元素是否相同判断：
    - 如果首尾元素相同，则`dp[i][j] = dp[i+1][j-1] + 2`;
    - 如果首尾元素不同，则它们必定不能同时作为最长子序列的首尾，`dp[i][j] = max (dp[i+1][j], dp[i][j-1])`。
4. 需要注意dp遍历顺序问题，如果j从0到字符串末尾，那么i需要从j-1递减到0，这样才能正确利用之前的计算结果。

## 从1到n的BST的种类数

> [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)
> 
> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

**思路：**

1. 从1到n，每一个数都可以选取作为根节点；
2. 根据BST的性质，如果选择了i作为根节点，那么：
    - `[1,i-1]`的元素都在左子树；
    - `[i+1,n]`的元素都在右子树。
3. 根据BST的规则，`[1,n]`的BST种类和`[1+K,n+K]`的BST种类相同；
4. 设`dp[i]`为`[1,i]`区间可构建的BST种类数，那么：
    - `[1,i-1]`的元素都在左子树，构建的BST种类数为`dp[i-1]`；
    - `[i+1,n]`的元素都在右子树，构建的BST种类数为`dp[n-i]`。
5. 对于一个根节点，总种类数为左右子树种类数相乘，则有状态转移方程：`dp[i] = dp[i-1] * dp[n-i]`；
6. 返回`dp[n]`即可。

# 贪心、分治算法

## 为运算表达式设计优先级

> [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

采用分治算法+dfs：

- 设置一个dfs(l,r)函数，用来计算原表达式从l到r闭区间内子表达式的计算结果；
- 原表达式可以从任一操作符一分为二，可知左右两侧仍是一个表达式；
- 对两侧表达式重复上述分割步骤，直到两侧为不含操作符的数字；
- 每一个表达式因计算优先级的不同，可能有多种计算结果，因此返回的应该是一个数组，里面保存了所有表达式可能的计算结果；
- 每次用当前运算符，对左右两个表达式的计算结果进行遍历计算，合并结果集，最终返回整个表达式的结果。

```js
var diffWaysToCompute = function(expression) {
    // 测试字符串是否是纯数字
    function isNumber(str) {
        return /^\d+$/i.test(str);
    }
    // 执行单次计算
    function cal(l, r, o) {
        switch (o) {
            case '+': {
                return l+r;
            }
            case '-': {
                return l-r;
            }
            case '*': {
                return l*r;
            }
        }
    }
    // 按操作符分隔表达式，取结果集合。
    function dfs(l = 0, r = expression.length-1) {
        if (isNumber(expression.slice(l,r+1))) {
            return [+expression.slice(l,r+1)];
        }
        let res = [];
        for (let i=l; i<=r; i++) {
            if (!isNumber(expression[i])) {
                let left = dfs(l, i-1);
                let right = dfs(i+1, r);
                let operater = expression[i];
                for (let i of left) {
                    for (let j of right) {
                        res.push(cal(i, j, operater));
                    }
                }
            }
        }
        return res;
    }

    return dfs();
};
```

# 回溯算法

## 算法基本思路

回溯算法是遍历决策树的过程。决策过程可以表示为**当前路径**、**当前决策空间**和**结束条件**。

- **当前路径**：是由已经进行过的所有决策组成的。下一步决策依赖于当前走过的决策路径。（比如：有三张牌ABC，第一次选择B，第二次选择C，则当前第三次选择的路径为B-C）；
- **当前决策空间**：根据当前路径，本次决策剩余的选择空间。（ABC三张牌，前两次选择BC，则第三次当前选择空间只有一张牌A）；
- **结束条件**：决策空间中没有任何选项时，则代表决策树遍历到尽头，需要用结束条件处理这次决策的结果。（比如将当前决策路径B-C-A保存起来）

回溯算法一般是基于**递归调用**实现，递归主要负责实现决策树的遍历。回溯算法的主要过程如下：

> 1. 先判断当前路径是否满足结束条件，满足则执行结束操作；
> 2. 在当前决策空间B内进行决策，然后在当前路径A中添加当前决策（结果为A1），在当前决策空间B中去掉当前决策（结果为B1）；
> 3. 以A1为下一决策的路径，以B1为下一决策的决策空间，递归调用自身；
> 4. 调用完成后，将决策路径B1恢复为B，路径A1也恢复为A。（这一步称为回溯过程）

回溯算法的应用：DFS深度优先搜索、全排列问题、组合问题等。

> **注意：**
> 
> 理论上使用回溯算法，执行决策后的回溯过程（恢复空间），应该与决策前的顺序正好相反，代码在结构上完全**镜像对称**。否则容易出现Bug。

## 回溯算法：全排列问题

### 元素互不相同的全排列

> 给定一个由字母组成的数组arr，数组中元素互不相同，请返回由全部数组元素组成的所有排列。
>
> 例如: `['a','b','c']` 的全排列是`[['a','b','c']，['a','c','b']，['b','a','c']，['b','c','a']，['c','b','a']，['c','a','b']]`

考虑使用回溯算法：

1. 当前路径就是已经选择过的字母序列，当前决策空间就是剩余的可被选择的字母集合；
2. 每次决策，在剩余字母中选择一个(比如'a')，添加到路径中，然后在可选择字母集合中删除掉这个已经选过的字母a；
3. 使用新路径和新决策空间，递归调用执行下一次决策；
4. 结束条件：当可选择字母集合为空，说明排列已经完成，将结果添加到结果集合，然后返回；
5. 递归调用完成后，恢复路径（删掉添加的字母a）和决策空间（恢复字母a）。

![全排列问题](/assets/posts/21.png)

代码如下：
```js
// 方法1：
function getArrangement(arr, path=[], res=[]){
// arr是当前决策空间，path是当前路径 
// 1.判断结束条件：决策空间内无元素可选；
    if(arr.length === 0){
        res.push(path.slice());
        return;
    }
    for(let i=0; i<arr.length; i++){
// 2.进行决策；
        let selected = arr[i];
// 3. 修改决策空间和路径，用来进行下一次决策；
        path.push(selected);
        arr.splice(i, 1);
// 4. 递归调用，执行下一次决策；
        getArrangement(arr, path, res);
// 5. 恢复 决策空间 和 路径。
        arr.splice(i, 0, selected);
        path.pop();
    }
    return res;
}

// 方法2： 使用一个used记录选择的路径
function allArrangement2(arr){
    let path = [], used = new Array(arr.length).fill(false);
    let res = [];

    function backtrack(){
        if(path.length === arr.length){
            res.push(path.slice());
            return;
        }
        for(let i=0; i<arr.length; i++) {
            if (!used[i]) {
                path.push(arr[i]);
                used[i] = true;
                backtrack();
                used[i] = false;
                path.pop();
            }
        }
    }

    backtrack();
    return res;
}
``` 
### 元素存在重复的全排列

> [元素存在重复的全排列](https://leetcode-cn.com/problems/permutations-ii/)

当给定数组中存在重复元素时，进行全排列会出现重复结果。

比如： `[1,1,2,3]`的全排列中，`[1,1,2,3]`本身会出现两次，因为存在两个1。

**解决方法是：在相同决策空间进行选择的时候，进行一个判断。如果前后两次选择的元素值相同，则后续排列必重复，直接跳过此次选择即可。** 

> 例如在某次决策过程中，决策空间为`[1,1,2,3]`，选择从左到右进行。本轮选择为第一个1元素，则下一次决策的空间为`[1,2,3]`。
> 
> 本轮回溯过程执行完毕后，下次决策选择了第二个元素，此时发现同样为1元素，剩余空间还是`[1,2,3]`。那么这两次决策结果一定相互重复，第二轮直接跳过即可。

```js
function backtrack(path=[], space=nums, res=[]){
    if(space.length === 0){
        res.push(path.slice());
        return;
    }
// 为每一轮回溯决策过程，设置一个Set，用来保存已经选择过的元素值。
    let set = new Set();
    for(let i=0; i<space.length; i++){
// 当该决策空间中已经选取过当前元素，直接跳过，防止重复。
        if(set.has(space[i])) continue;
        else {
            set.add(space[i]);
            let cur = space[i];
            path.push(cur);
            space.splice(i,1);
            backtrack(path, space, res);
            space.splice(i,0,cur);
            path.pop();
        }
    }
    return res;
}
```
## 全部子集（组合问题）

> [子集](https://leetcode-cn.com/problems/subsets/)

求子集的回溯算法，思路如下：

1. 设置一个path，代表已经选择的元素路径；
2. 对于每一个path，设置一个start值，代表下次选择的起始位置；（含义是：path条件下，index < start的全部元素子集已经处理完毕）
3. 每次从start到数组结尾遍历剩余选择空间，将元素放入path然后记录到结果数组，最后返回结果数组。

子集（组合）问题，每次都要进行判断，记录结果，而不是在最后判断返回。

```js
function allCombination(arr){

    function backtrack(path = [], start = 0, res = []){
    // 对于每一个path，选择空间是[start, arr.length-1]，[0,start]全部子集都处理完成，不用考虑。
        for(let i=start; i<arr.length; i++){
            path.push(arr[i]);
            res.push(path.slice());
            backtrack(path, i+1, res);
            path.pop();
        }
        return res;
    }

    return backtrack();
}
```

## 回溯算法：括号匹配

> [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

回溯算法，解法等同于[div标签生成](#283-典型递归问题).

```js
var generateParenthesis = function(n) {

    function backtrack(path=[], leftleft=n, rightleft=n, res=[]){
// 结束条件
        if(leftleft === 0 && rightleft === 0){
            res.push(path.join(''));
            return;
        }
// 回溯：选择
        if(leftleft > 0){
            path.push('(');
            backtrack(path, leftleft-1, rightleft, res);
            path.pop();
        }
// 这里可以保证：右括号只有在有左括号能匹配的情况下，才会被添加。
        if(rightleft > leftleft){
            path.push(')');
            backtrack(path, leftleft, rightleft-1, res);
            path.pop();
        }

        return res;
    }

    return backtrack();
};
```

## 回溯算法：优美的排列

> [优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)

回溯算法的路径，如果每次选择只涉及两种情况，则可以使用一个与原空间等长度的数组，用true和false代表选择的与否。


# 递归

## 递归的特点和基本思想

递归是一种**解空间的遍历手段**，它不同于for/while循环，递归遍历的空间可以是**非线性**的。（图、树等）

递归通过在函数内调用自身实现。递归在内存中是通过函数调用栈来实现的，每次调用函数在调用栈中压入函数，函数执行完毕后弹出，恢复上层函数的执行环境。

因为这个原因，递归在内存中需要占用空间，空间复杂度较高。（占用空间与函数的最大调用次数n正相关。）

**递归的注意事项：**

- 设置合理的退出条件；
- 递归深度影响空间复杂度，能用迭代实现尽量不用递归。

## 递归复杂度分析

递归问题的复杂度可以画**递归树**分析：

时间复杂度等于：**每次函数调用的时间复杂度 × 递归调用次数**。

空间复杂度等于：**每次调用函数所需空间复杂度 * 最大递归深度**。

## 典型递归问题

> [生成DIV标签](https://www.algoexpert.io/questions/Generate%20Div%20Tags)

思路： 回溯算法，递归实现。

1. 控制可用的开始和结束标签数目，当开始标签可用数>0时，向后面添加一个开始标签；
2. 然后检查结束标签可用数，如果发现结束标签可用数大于开始标签可用数，说明有开始标签没有被正确关闭，此时向字符串后添加一个结束标签；
3. 当开始标签和结束标签可用数都为0，则向结果数组中保存结果。

```js
function generateDivTags(numberOfTags) {
	let res = [];
	function getStrings(prefix, openings, closings, result){
		if(openings === 0 && closings === 0){
			result.push(prefix);
		}
		if(openings > 0){
			let newPrefix = prefix + '<div>';
			getStrings(newPrefix, openings-1, closings, result);
		}
		if(closings > openings){
			let newPrefix = prefix + '</div>';
			getStrings(newPrefix, openings, closings-1, result);
		}
	}
	getStrings('', numberOfTags, numberOfTags, res);
  return res;
}
```

# 排序算法

[各排序算法基本思想与JS实现](/blog/2021/03/26/排序算法基本思想与JS实现/)

## 堆排序
### 构建堆（也叫优先级队列）

> [构建堆](/blog/2021/06/17/使用数组构建堆结构的过程和原理/)

适用于：获取一个集合中，某一属性的前N名元素集合。

> 例如： 获取一个数组中出现次数最高的前N个元素。

为集合元素构建堆（大顶堆、小顶堆），可以通过堆排序，方便获取某一属性优先的前N个元素。

> [1792. 最大平均通过率](https://leetcode-cn.com/problems/maximum-average-pass-ratio/)

# 搜索算法

各种搜索问题，本质上都是**树的遍历问题**。

## 二分查找
### 复杂度分析

时间复杂度： **O(logN)**，N为原数组长度。

空间复杂度： **O(1)**

### 二分查找适用情况

应用二分查找的必要条件是：

- ①顺序存储：数组结构；
- ②有序，可以缩小结果范围。

一般适用于：**按序排列**的数组元素搜索。

### ★二分查找的区间情况和对应的代码

假设二分查找应用的数据是**升序排列**的，假设它的区间是`[a,b]`。将它以目标值`target`分成两部分，一定是如下两种情况之一：

1. `[a,target)`和`[target,b]`;
2. `[a,target]`和`(target,b]`。

对于一个`target`,我们进行查找的目标的情况可以是：

- `≤target`的最后一个元素；
- `<target`的最后一个元素；
- `≥target`的第一个元素；
- `>target`的第一个元素。

![二分情况](/assets/posts/22.png)

需要根据上述四种查找的目标情况，对区间进行正确切分，注意**我们需要保证`[left,right]`区间内元素是我们想要的元素，而且最后left和right要重合，否则会出现数组越界。**

- **查找`≤target`的最后一个元素时：**
    - mid ≤ target: left = mid;
    - mid > target: right = mid - 1; 
    - mid的取整情况：向上取整。
- **查找`<target`的最后一个元素:**
    - mid < target: left = mid;
    - mid ≥ target: right = mid - 1; 
    - mid的取整情况：向上取整。
- **查找`≥target`的第一个元素:**
    - mid < target: left = mid + 1;
    - mid ≥ target: right = mid;
    - mid的取整情况：向下取整。
- **查找`>target`的第一个元素:**
    - mid ≤ target: left = mid + 1;
    - mid > target: right = mid; 
    - mid的取整情况：向下取整。

这里有几个技巧（对于升序排列）：

0. 先正确切分区间（哪边闭哪边开），然后判断查找的目标区间在哪一侧，目标区间边界在收缩的时候一定是闭的（在左侧：`left = mid` 或 在右侧：`right = mid`）；
1. right只能向左缩小，left只能向右缩小。也就是说，left、right取值只有以下两种情况：
    - left = mid, right = mid - 1;
    - left = mid+1, right = mid; 
2. 向上还是向下取整，取决于哪边是开区间：
    - 当存在left = mid + 1，向下取整；
    - 当存在right = mid - 1， 向上取整。
3. 二分查找过程中，mid的判断条件，和区间的切分情况一定完全相同。需要做的只是根据区间的切分情况，对mid进行开闭取舍；
4. mid位于目标值target左侧，动左区间。mid位于目标值右侧，动右区间。

###0.1.4 基本代码实现

二分查找实现的两种方式：1.迭代 2.递归。
```js
// 递归实现：升序数组nums中，查找≤target的最后一个元素。
const search = function(nums,target) {
    function find(left, right){
        if(left < right){
            let mid = Math.ceil((left+right)/2);
            if(nums[mid] <= target) return find(mid, right);
            else return find(left, mid-1);
        }
        return left;
    }
    return find(0,nums.length-1);
};

// 迭代实现
var search = function(nums,target) {
    let left = 0, right = nums.length-1;
    while(left < right){
        let mid = Math.ceil((left+right)/2);
        if(nums[mid] <= target) left = mid;   
        else right = mid-1;
    }
    return left;
};
```

##0.2 滑动窗口

适用于：寻找**空间连续**的特定组合。

基本思路：

1. 通过左右边界维护一个窗口：left,right;
2. 右边界负责向右扩展窗口，每次探索到一个符合条件的窗口值就停止扩展；
3. 收缩左边界，优化当前窗口值，直到不符合要求；

4. 继续向右扩展右边界，重复1-3步骤，直到右边界到达末尾。
##0.3 双指针

##0.3.2 快慢指针

快慢指针：同一方向，不同前进速度的两个指针。

快慢指针的用途：

- **链表寻环**： 使用快慢指针，快指针比慢指针每次多走1步，如果有环存在，则快慢指针一定会相遇；
- **寻找链表的中点**； 使用快慢指针，慢指针每次走1步，快指针每次走2步，则快指针到达尾部，慢指针正好在链表中间位置；

# 三、 常用操作

## 概念定义

**子序列**： 由原数组中部分或全部元素组成的新数组，子序列中元素的先后顺序必须与原数组相同，但是元素在原数组中不必相邻。

**子数组**： 由原数组中部分或全部元素组成的新数组，子数组中元素的先后顺序必须与原数组相同，而且元素在原数组中必须相邻。

## 数字在JS中的表示法

JS中数字表示的方式是`IEEE754`双精度浮点数。

其中，

## 位运算

- **补码**：
  - 正数的补码是它本身；
  - 负数的补码，是符号为保持为`1`不变，其他位取反，然后整体再加1。
- `AND OR XOR`都满足交换律和结合律；
- `(a&b)^(a&c) = a&(b^c)`
- `x^0 = x`
- `x^x = 0`
- `>>`是带符号右移，表示移动过程中左侧空出来位置用符号位的值来填充（正数补0，负数补1）；
- `>>>`是无符号右移，表示移动过程中左侧空出来位置，始终用`0`来填充；
- `a & (-a)` 可以找出数字a的**最低非0位**；

## 数组操作

### 数组中随机取一个元素

```js
let randPos = Math.floor( Math.random() * arr.length )
let res = arr[randPos]
```

### 数组中删除一个元素

```js
arr.splice(position, 1)
```

### 数组中动态删除元素，考虑从右到左遍历

从右到左遍历，指针左侧的元素不会被动态修改，指针右侧的元素删除不影响指针的下一位置。

### 浅拷贝数组

```js
// 1.
Array.from(arr);

// 2.
arr.slice();

// 3. 
[].concat(arr);
```

### 数组sort排序

```js
// 字符串升序
arr.sort()
// 字符串降序
arr.sort().reverse()
// 数字升序
arr.sort( (a,b) => a-b )
// 数字降序
arr.sort( (a,b) => b-a )
```

## 判断变量类型

```js
// 精确返回变量类型，首字母大写
Object.prototype.toString.call(arg).slice(8,-1)
```

## 链表操作

### 链表的前序、后序遍历

```js
    function iterate(nodeHead){
        if (nodeHead) {
            // 这里写是前序；
            iterate(nodeHead.next);
            // 这里写是后序。
        }
    }
```

## 数值操作

### 辗转相除找最大公约数

```js
    function findGCD(num1,num2){
        let remainder,divider
        if (num1 >= num2){
            remainder = num1 % num2
            divider = num2
        } else {
            remainder = num2 % num1
            divider = num1
        }
        while (remainder !== 0){
            let temp = remainder
            remainder = divider % remainder
            divider = temp
        }
        return divider
    }
```

### 找两数最小公倍数

```js
let LCM = num1 * num2 / findGCD(num1,num2)
```

### ABC集合的合集元素数目

`|A∪B∪C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|`

### 合并区间

对于一系列闭区间组成的数组arr：`[[l1,r1],[l2,r2],[l3,r3]...[ln,rn]]`，它们之间可能无序，也可能存在嵌套，合并它们的策略是：

1. 先按起始位置`l1,l2,l2.3...`对区间进行升序排序；
2. 声明一个left和一个right变量，用来保存当前区间的左右边界值，以及一个数组res用来保存结果；
3. 从左到右遍历区间数组（索引index从0到n-1），对每个区间`[l1,r1]`和它下一个区间`[l2,r2]`，因为排过序可知此时存在`l2 >= l1`：
    - 如果l2 > r1，说明下一个区间和现在的区间不重合，直接把现在的结果区间`[left,right]`放入结果数组，并更新left = l2, right = r2；
    - 否则l2 <= r1，说明区间存在重合：
        - 此时如果r2 <= r1，说明`[l2,r2]`区间被完全覆盖，此时直接跳过；
        - 如果r2 > r1，此时更新新的区间右边界值right = r2；

### 矩阵旋转

一个矩阵旋转（顺时针、逆时针），可以转化成**水平、垂直翻转**或**沿对角线翻转**的组合。

1. 如果旋转90度，可以转化为**一次沿水平、垂直的翻转+一次沿对角线的翻转**；
2. 如果旋转180度，可以转化为**两次沿水平、垂直的翻转**。

## 消除相同的数问题
### 消除相同的两个数

可以考虑使用位运算中的`异或运算`，对完全相同的两个数进行消除。

> 异或： 位相同则返回0， 否则返回1。

- 如果两个数 `a === b`，那么`a ^ b === 0`；
- 任何一个数`a`，它与0异或运算后，仍然是它本身，`a ^ 0 === a`。 

### 消除相同的多个数

**问题类型：** 一个数组中，只有一个数`x`出现的次数为1，其他数都重复出现n次，请找出这个单独的数。

基本思路：

1. 按位思考，对于每一个数的每一位，因为只能是1或0，对于重复出现的n个数，它们在这一位上的加和只能是`n`或`0`；
2. 所以对于除单独的数`x`外，其他的数在每一位上的加和只能是`nk` (k >= 0 && k <= n)；
3. 考虑单独的数x，全部数在每一位上，加起来的和只能是`nk+1`或`nk`；
4. 因此，对全部数每一位进行加和，然后用`n`取余数，余数就是要找的单独数x在该位上的实际值。

```js
// 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
var singleNumber = function(nums) {
    let res = 0;
    let cur = 1;
    for (let i=0; i<31; i++) {
        let s = 0;
        for (let n of nums) {
            if ((n & cur) !== 0) {
                s += 1;
            }
        }
        res += cur * (s % 3);
        cur <<= 1;
    }
    return res;
};
```

## 位运算判断纯字母字符串是否含有重复字母

> [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

因为字母一共只有26个，使用二进制数字的每一位`(0~25)`表示一个字母，最大为**2<sup>26</sup>-1**不会超出JS数字上限。

设初始掩码为`mask=0`（全0），当字母存在时置对应位为1。具体操作为获取字母在字符串`abcdefghijklmnopqrstuvwxyz`的索引i，然后执行以下操作：

1. `let cur = 1 << i`;
2. `mask |= cur`;

例如：`acde`对应的二进制掩码后五位为`11101`（其余全为0）

当判断字符串a与b是否有重复字母时，取a、b的掩码`mask_a`和`mask_b`，对它们执行**与操作&**：

- 如果为0，则没有重复字母；
- 否则含有重复字母。
