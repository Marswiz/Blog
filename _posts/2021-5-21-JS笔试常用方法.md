---
layout: post
title: JS笔试：数据结构、算法和技巧
date: 2021-5-21
categories: blog
tags: [JavaScript]
author: Mars
pIdentifier: 中文缩进
---

> 记录笔试常用方法技巧
>

# 一、 索引
## 1. 栈、队列、哈希表

> [数据结构汇总](/blog/2021/05/04/数据结构与算法/)
>
> 一、**栈**
> 1. [单调栈](#2111-单调栈)
>
> 二、**队列**
> 1. 单调队列；
>
> 三、**哈希表**
> 1. [构建哈希表方法的适用情况](#213-哈希表)；
> 2. [哈希表计数去重](#2131-哈希表计数去重)；

## 2. 链表

> 1. 链表反转；
> 2. 链表寻环、查找环的入口点；
> 3. 合并链表；

## 3. 二叉树、BST

> **Binary Tree**
> 1. 翻转二叉树；
> 2. 前、中、后序遍历（递归、迭代写法）；
> 3. 层序遍历；
> 4. 最大路径和；
> 5. 节点间距离；
> 
> **BST:**
> 
> 1. BST插入、查询、删除（重难点）操作；
> 2. 确认BST有效性；
> 3. 寻找BST中最大（小）kth元素；

## 4. 图

> 1. 深度优先搜索DFS；
> 2. 广度优先搜索BFS；

## 5. 动态规划

> 1. [背包问题](#251-背包零钱问题)；
> 2. [零钱问题](#251-背包零钱问题)；
> 3. 接雨水；
> 4. 字符串操作距离；
> 5. [股票买卖问题](#252-股票买卖)；

## 6. 贪心算法

## 7. 回溯算法 

> 1. [基本思想](#271-算法基本思路);
> 2. [回溯算法：全排列问题](#272-回溯算法全排列问题);

## 8. 递归

> 1. [递归复杂度分析](#282-递归复杂度分析)；
> 2. [典型递归问题](#283-典型递归问题)；

## 9. 排序

> [排序算法汇总](#29-排序算法)
> 1. 插入排序、选择排序、冒泡排序；
> 2. 快速排序；
> 3. 归并排序；
> 4. 堆排序：构建大（小）顶堆；
> 5. 桶排序；
> 6. 计数排序；
> 7. 基数排序；

## 10. 搜索

> 1. [二分查找](#2101-二分查找)；
> 2. [滑动窗口](#2102-滑动窗口)；
> 3. 双指针；

## 11. 知名算法

> 1. Kadane算法：查找最大连续子数组；
> 2. KMP算法：查找子字符串subStr是否存在于父字符串str；

### ☆概念、常用操作
> 0. [各种概念](#30-概念定义)
> 1. [数组操作](#31-数组操作)
> 2. [判断变量类型](#32-判断变量类型)
> 3. [链表的前序、后序遍历](#231-链表的前序、后序遍历)
> 4. [辗转相除找最大公约数](#341-辗转相除找最大公约数)
> 5. [找两数最小公倍数](#342-找两数最小公倍数)
> 6. [ABC集合的合集元素数目](#343-ABC集合的合集元素数目)
> 7. [合并区间](#344-合并区间)

# 二、主要内容记录

## 2.1 栈、队列和哈希表

### 2.1.1 栈
#### 2.1.1.1 单调栈

> 单调栈：栈内的元素，从底向顶单调递增或单调递减。

单调栈的目的是，随着原序列的遍历，维护一个局部最优的子序列。属于贪心算法的工具。

单调栈可以用来解决：

- 查找数组中每个元素下一个大于自身的值；
- 查找最小或最大子序列；

> [找出最具竞争力的子序列](https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/)
> 
> [移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

### 2.1.2 队列

待补充。

### 2.1.3 哈希表

适用于：**计数类问题。哈希表可以快速判断一个值是否出现在集合中，而避免了每次都要遍历查找**。

缺点是空间复杂度高，是以空间换时间的方法。

哈希结构：**数组、对象、Set、Map**

#### 2.1.3.1 哈希表计数去重

> **使用哈希表计数两数组合，如何能不重复？**
>
> *`给出一个数组arr，求数组中子序列 [a,b] 加和 a+b=target 的组合数。`*
>
> 使用暴力解法时间复杂度为`O(n^2)`，可以使用两个嵌套for循环，通过索引来实现无重复计数。
>
> 使用一个哈希表map，可以实现`O(n)`复杂度的算法。但是如果采用**先将数组元素添加到map统计数目，后遍历map计算组合数**的方式，计算的组合数将包含重复情况：
>
> **例如:**  map = {1: 3, 2: 3} ，target = 3，遍历map时，会得到`[1,2]`+`[2,1]` 共计18种组合，实际上只有9种。
> 
> **可以采用边统计，边计数的方式，避免这种重复计数的情形：**
>
> - **每次将元素i放入map前，先计算 map 中 target-i 的数目num，将其加入计数结果count；**
> - **将元素放入map，它对应在map中的数目+1.**
>
> 这样做可以避免重复计数（`[a,b]`和`[b,a]`）的原因是：
> 
> 如果a和b是一对待计入组合，那么按照这种依次加入的方式，他们加入map一定有先后顺序。我们只在二者中后加入map的一方加入map的时候计数。因为所有元素最终一定都被添加到map，他们之间两两存在先后顺序，也就是说如果存在任意组合需要被计入，只会在组合元素最后一次被添加的时候计数，也就是只会计数一次。

## 2.5 动态规划（Dynamic Programming）

### 2.5.1 背包（零钱）问题

> LeetCode问题：[零钱问题2](https://leetcode-cn.com/problems/coin-change-2/)

给出零钱和目标值，求组成目标值的方法数。（比如由1,2,5组成10元有几种方法）

这里存在一个for循环先后顺序导致的，排列数和组合数的问题。

> **详细说明：**
>
> 动态规划解题，可以想到将钱数amount和钞票面值note联系起来: 组成一个目标值amount的方法数，等于所有钞票面值note对应的amount-note的方法数加在一起。`dp[amount] = sum( dp[amount-note] )`
>
> 比如： 如果给出钞票`[3,10]`，那么组成目标钱数20的方法数，应该等于组成20-3=17和20-10=10的方法数之和。因为组成17的每一个方法，再加上一张3元的钞票，就都可以组成目标值20，另一个例子同理。
>
> 可以用两层for循环分别遍历amount数组和notes数组，动态更新amount数组的值： `amount[i] += amount[i-note]`。
>
> 但是这里存在一个遍历顺序问题：
>
> - **① 如果先遍历amount，后遍历notes，则意味着：对于每个目标值，都直接穷举所有当前可能的钞票组合，之后再进入下一个目标值进行更新。**
>
> - **② 如果先遍历notes，后遍历amount，则意味着：对于每个钞票note，先计算并更新单独由这个note组成各个目标值的方法数，然后再进入下一个面额note，再更新这个新面额和之前所有面额组成的方法数。**
>
> 对于情况①，计算出来的是所有的排列数。对于情况②，计算出来的是组合数。
>
> 本题不同排列同一组合，视为同一个方法，因此应该使用第二个遍历方式。
>

### 2.5.2 股票买卖

> [股票买卖](https://www.algoexpert.io/questions/Max%20Profit%20With%20K%20Transactions)
>
> 给你一个每日股票价格组成的数组prices（索引是日期，值是价格），和一个可交易次数k。编写返回可实现的最大收益的函数。
> 
> 股票同时期最多只能持有一份，一次也只能交易一份。也就是如果持有，必须先卖出才能再买入。

**思路分析：**

1. 一天可以有三种选择：买入、卖出、不操作；
2. 只有卖出才能获得收益；
3. 卖出必须先买入；
4. 如果不操作，则总收益和之前一天的收益相同。

基于以上四点，可以得出下面的算法：

> 对于某一天，只关注卖出操作。我们可以选择**卖出**或**不卖出**。
> 
> - 如果卖出， 则之前必定有一天进行了买入。此次交易赚取收益为`price[sell]-price[buy]`；
> - 如果不卖出，则总收益与前一天收益相同；
> 
> 设置一个矩阵，每一行代表最大可交易次数k，每一列代表交易日期day。每一个元素代表最大交易次数为k时，当前日期所能达到的最大收益。
>
> 则有如下关系： 
>
> ![股票买卖](/assets/posts/20.png)

```js
function maxProfitWithKTransactions(prices, k) {

	if(prices.length < 2) return 0;
	
	let dp = new Array(2);
	dp[0] = new Array(prices.length) .fill(0);
	dp[1] = new Array(prices.length);
	let trans = 1;
	while(trans <= k){
		for(let i=0; i<prices.length; i++){
			if(i === 0) dp[1][i] = 0;
			else {
				let notSellMaxProfit = dp[1][i-1];
				let sellMaxProfit = -Infinity;
				for(let buyDay=i-1; buyDay>=0; buyDay--){
					sellMaxProfit = Math.max(sellMaxProfit, prices[i]-prices[buyDay]+dp[0][buyDay]);
				}
				dp[1][i] = Math.max(notSellMaxProfit, sellMaxProfit);
			}
		}
		dp[0] = dp[1];
		dp[1] = new Array(prices.length);
		trans++;
	}
	return dp[0][prices.length-1];
}
```
## 2.7 回溯算法

### 2.7.1 算法基本思路

回溯算法是遍历决策树的过程。决策过程可以表示为**当前路径**、**当前决策空间**和**结束条件**。

- **当前路径**：是由已经进行过的所有决策组成的。下一步决策依赖于当前走过的决策路径。（比如：有三张牌ABC，第一次选择B，第二次选择C，则当前第三次选择的路径为B-C）；
- **当前决策空间**：根据当前路径，本次决策剩余的选择空间。（ABC三张牌，前两次选择BC，则第三次当前选择空间只有一张牌A）；
- **结束条件**：决策空间中没有任何选项时，则代表决策树遍历到尽头，需要用结束条件处理这次决策的结果。（比如将当前决策路径B-C-A保存起来）

回溯算法一般是基于**递归调用**实现，递归主要负责实现决策树的遍历。回溯算法的主要过程如下：

> 1. 先判断当前路径是否满足结束条件，满足则执行结束操作；
> 2. 在当前决策空间B内进行决策，然后在当前路径A中添加当前决策（结果为A1），在当前决策空间B中去掉当前决策（结果为B1）；
> 3. 以A1为下一决策的路径，以B1为下一决策的决策空间，递归调用自身；
> 4. 调用完成后，将决策路径B1恢复为B，路径A1也恢复为A。（这一步称为回溯过程）

回溯算法的应用：DFS深度优先搜索、全排列问题等。

### 2.7.2 回溯算法：全排列问题

#### 2.7.2.1 元素互不相同的全排列

> 给定一个由字母组成的数组arr，数组中元素互不相同，请返回由全部数组元素组成的所有排列。
>
> 例如: `['a','b','c']` 的全排列是`[['a','b','c']，['a','c','b']，['b','a','c']，['b','c','a']，['c','b','a']，['c','a','b']]`

考虑使用回溯算法：

1. 当前路径就是已经选择过的字母序列，当前决策空间就是剩余的可被选择的字母集合；
2. 每次决策，在剩余字母中选择一个(比如'a')，添加到路径中，然后在可选择字母集合中删除掉这个已经选过的字母a；
3. 使用新路径和新决策空间，递归调用执行下一次决策；
4. 结束条件：当可选择字母集合为空，说明排列已经完成，将结果添加到结果集合，然后返回；
5. 递归调用完成后，恢复路径（删掉添加的字母a）和决策空间（恢复字母a）。

![全排列问题](/assets/posts/21.png)

代码如下：
```js
function getArrangement(arr, path=[], res=[]){
// arr是当前决策空间，path是当前路径 
// 1.判断结束条件：决策空间内无元素可选；
    if(arr.length === 0){
        res.push(path.slice());
        return;
    }
    for(let i=0; i<arr.length; i++){
// 2.进行决策；
        let selected = arr[i];
// 3. 修改决策空间和路径，用来进行下一次决策；
        path.push(selected);
        arr.splice(i, 1);
// 4. 递归调用，执行下一次决策；
        getArrangement(arr, path, res);
// 5. 恢复 决策空间 和 路径。
        arr.splice(i, 0, selected);
        path.pop();
    }
    return res;
}
``` 
#### 2.7.2.2 元素存在重复的全排列

> [元素存在重复的全排列](https://leetcode-cn.com/problems/permutations-ii/)

当给定数组中存在重复元素时，进行全排列会出现重复结果。

比如： `[1,1,2,3]`的全排列中，`[1,1,2,3]`本身会出现两次，因为存在两个1。

**解决方法是：在相同决策空间进行选择的时候，进行一个判断。如果前后两次选择的元素值相同，则后续排列必重复，直接跳过此次选择即可。** 

> 例如在某次决策过程中，决策空间为`[1,1,2,3]`，选择从左到右进行。本轮选择为第一个1元素，则下一次决策的空间为`[1,2,3]`。
> 
> 本轮回溯过程执行完毕后，下次决策选择了第二个元素，此时发现同样为1元素，剩余空间还是`[1,2,3]`。那么这两次决策结果一定相互重复，第二轮直接跳过即可。

```js
function backtrack(path=[], space=nums, res=[]){
    if(space.length === 0){
        res.push(path.slice());
        return;
    }
// 为每一轮回溯决策过程，设置一个Set，用来保存已经选择过的元素值。
    let set = new Set();
    for(let i=0; i<space.length; i++){
// 当该决策空间中已经选取过当前元素，直接跳过，防止重复。
        if(set.has(space[i])) continue;
        else {
            set.add(space[i]);
            let cur = space[i];
            path.push(cur);
            space.splice(i,1);
            backtrack(path, space, res);
            space.splice(i,0,cur);
            path.pop();
        }
    }
    return res;
}
```

### 2.7.3 回溯算法：括号匹配

> [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

回溯算法，解法等同于[div标签生成](#283-典型递归问题).

```js
var generateParenthesis = function(n) {

    function backtrack(path=[], leftleft=n, rightleft=n, res=[]){
// 结束条件
        if(leftleft === 0 && rightleft === 0){
            res.push(path.join(''));
            return;
        }
// 回溯：选择
        if(leftleft > 0){
            path.push('(');
            backtrack(path, leftleft-1, rightleft, res);
            path.pop();
        }
// 这里可以保证：右括号只有在有左括号能匹配的情况下，才会被添加。
        if(rightleft > leftleft){
            path.push(')');
            backtrack(path, leftleft, rightleft-1, res);
            path.pop();
        }

        return res;
    }

    return backtrack();
};
```

## 2.8 递归

### 2.8.1 递归的特点和基本思想

递归是一种**解空间的遍历手段**，它不同于for/while循环，递归遍历的空间可以是**非线性**的。（图、树等）

递归通过在函数内调用自身实现。递归在内存中是通过函数调用栈来实现的，每次调用函数在调用栈中压入函数，函数执行完毕后弹出，恢复上层函数的执行环境。

因为这个原因，递归在内存中需要占用空间，空间复杂度较高。（占用空间与函数的最大调用次数n正相关。）

**递归的注意事项：**

- 设置合理的退出条件；
- 递归深度影响空间复杂度，能用迭代实现尽量不用递归。

### 2.8.2 递归复杂度分析

递归问题的复杂度可以画**递归树**分析：

时间复杂度等于：**每次函数调用的时间复杂度 × 递归调用次数**。

空间复杂度等于：**每次调用函数所需空间复杂度 * 最大递归深度**。

### 2.8.3 典型递归问题

> [生成DIV标签](https://www.algoexpert.io/questions/Generate%20Div%20Tags)

思路： 回溯算法，递归实现。

1. 控制可用的开始和结束标签数目，当开始标签可用数>0时，向后面添加一个开始标签；
2. 然后检查结束标签可用数，如果发现结束标签可用数大于开始标签可用数，说明有开始标签没有被正确关闭，此时向字符串后添加一个结束标签；
3. 当开始标签和结束标签可用数都为0，则向结果数组中保存结果。

```js
function generateDivTags(numberOfTags) {
	let res = [];
	function getStrings(prefix, openings, closings, result){
		if(openings === 0 && closings === 0){
			result.push(prefix);
		}
		if(openings > 0){
			let newPrefix = prefix + '<div>';
			getStrings(newPrefix, openings-1, closings, result);
		}
		if(closings > openings){
			let newPrefix = prefix + '</div>';
			getStrings(newPrefix, openings, closings-1, result);
		}
	}
	getStrings('', numberOfTags, numberOfTags, res);
  return res;
}
```

## 2.9 排序算法

[各排序算法基本思想与JS实现](/blog/2021/03/26/排序算法基本思想与JS实现/)

### 2.9.4 堆排序
#### 2.9.4.1 构建堆（也叫优先级队列）

> [构建堆](/blog/2021/06/17/使用数组构建堆结构的过程和原理/)

适用于：获取一个集合中，某一属性的前N名元素集合。

> 例如： 获取一个数组中出现次数最高的前N个元素。

为集合元素构建堆（大顶堆、小顶堆），可以通过堆排序，方便获取某一属性优先的前N个元素。

## 2.10 搜索算法

各种搜索问题，本质上都是**树的遍历问题**。

### 2.10.1 二分查找
#### 2.10.1.1 复杂度分析

时间复杂度： **O(logN)**，N为原数组长度。

空间复杂度： **O(1)** 

#### 2.10.1.2 二分查找适用情况

应用二分查找的必要条件是：

- ①顺序存储：数组结构；
- ②通过任意一个下标获取子元素，可以缩小结果范围（一般数组需有序排列）。

一般适用于：**按序排列，且无重复元素**的数据搜索。

#### 2.10.1.3 基本代码实现

二分查找实现的两种方式：1.迭代 2.递归。
```js
// 递归实现数组nums中查找一个元素target。
var search = function(nums,target) {
    function find(left, right){
        if(left <= right){
            let mid = Math.floor((left+right)/2);
            if(nums[mid] > target) return find(left, mid-1);
            else if(nums[mid] < target) return find(mid+1, right);
            else return mid;
        }
        return -1;
    }
    return find(0,nums.length-1);
};

// 迭代实现
var search = function(nums,target) {
    let left = 0, right = nums.length-1;
    while(left <= right){
        let mid = Math.floor((left+right)/2);
        if(nums[mid] > target) right = mid-1;
        else if(nums[mid] < target) left = mid+1;
        else return mid;
    }
    return -1;
};
```
#### 2.10.1.4 需注意事项

1. 二分查找的边界条件是`left<=right`，也就是区间左右指针left和right在查找完毕后会交叉(left=right+1)。因此，如果需要在查找完成后使用left或right作为索引获取数组元素，需要考虑数组索引越界的情况：
> 当数组全部元素都大于目标值target，最终left=0, right=-1；
>
> 当数组全部元素都小于目标值target，最终left=arr.length-1, right=arr.length；
>
> right只可能在左边界越界，left只可能在右边界越界。

### 2.10.2 滑动窗口

适用于：寻找**空间连续**的特定组合。

基本思路：

1. 通过左右边界维护一个窗口：left,right;
2. 右边界负责向右扩展窗口，每次探索到一个符合条件的窗口值就停止扩展；
3. 收缩左边界，优化当前窗口值，直到不符合要求；
4. 继续向右扩展右边界，重复1-3步骤，直到右边界到达末尾。

# 2.10.3 双指针

待补充。

# 三、 常用操作

## 3.0 概念定义

**子序列**： 由原数组中部分或全部元素组成的新数组，子序列中元素的先后顺序必须与原数组相同，但是元素在原数组中不必相邻。
**子数组**： 由原数组中部分或全部元素组成的新数组，子数组中元素的先后顺序必须与原数组相同，而且元素在原数组中必须相邻。

## 3.1 数组操作

### 3.1.1 数组中随机取一个元素

```js
let randPos = Math.floor( Math.random() * arr.length )
let res = arr[randPos]
```

### 3.1.2 数组中删除一个元素

```js
arr.splice(position, 1)
```

### 3.1.3 数组中动态删除元素，考虑从右到左遍历

从右到左遍历，指针左侧的元素不会被动态修改，指针右侧的元素删除不影响指针的下一位置。

### 3.1.4 浅拷贝数组

```js
Array.from(arr)
```

### 3.1.5 数组sort排序

```js
// 字符串升序
arr.sort()
// 字符串降序
arr.sort().reverse()
// 数字升序
arr.sort( (a,b) => a-b )
// 数字降序
arr.sort( (a,b) => b-a )
```

## 3.2 判断变量类型

```js
// 精确返回变量类型，首字母大写
Object.prototype.toString.call(arg).slice(8,-1)
```

## 3.3. 链表操作

### 2.3.1 链表的前序、后序遍历

```js
function iterate(nodeHead){
    while (nodeHead.next){
        // 这里写处理逻辑就是前序遍历：正序
        iterate(nodeHead.next)
        // 这里写处理逻辑就是后序遍历：倒序
    }
}
```

## 3.4 数值操作

### 3.4.1 辗转相除找最大公约数

```js
    function findGCD(num1,num2){
        let remainder,divider
        if (num1 >= num2){
            remainder = num1 % num2
            divider = num2
        } else {
            remainder = num2 % num1
            divider = num1
        }
        while (remainder !== 0){
            let temp = remainder
            remainder = divider % remainder
            divider = temp
        }
        return divider
    }
```

### 3.4.2 找两数最小公倍数

```js
let LCM = num1 * num2 / findGCD(num1,num2)
```

### 3.4.3 ABC集合的合集元素数目

`|A∪B∪C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|`

### 3.4.4 合并区间

对于一系列闭区间组成的数组arr：`[[l1,r1],[l2,r2],[l3,r3]...[ln,rn]]`，它们之间可能无序，也可能存在嵌套，合并它们的策略是：

2.1. 先按起始位置`l1,l2,l2.3...`对区间进行升序排序；
2.2. 声明一个数组`edges = [l1]`用来储存：**合并后区间的左右边界位置**（每个位置是此时是独立的，而不是两两成组）;
2.3. 从左到右遍历这个区间数组（索引index从0到n-2），对每个区间`[l1,r1]`和它下一个区间`[l2,r2]`，判断`l2 <= r1`：
    - 如果为false，则说明二者之间存在间隙，那么r1和l2一定都是合并后区间的边界，将他们push到edges数组；
    - 如果为true，则说明二者之间相连或相交，r1和l2一定不是合并后的区间边界，此时什么都不用做；
2.4. 直到遍历结束，此时index位于arr倒数第二个元素（i=arr.length-2），并且所有合并后内部区间边界已经被加入到edges数组，只剩最后一个区间的末尾边界rn没有被加入。此时将其加入。（`edges.push(arr[i+1][1])`）
2.5. 所有区间合并完毕，edges内元素一定为偶数，从前到后两两配对即可。（每对前一元素为合并后区间左边界，后一元素为右边界。）

图示如下：

![合并区间](/assets/posts/17.png)
