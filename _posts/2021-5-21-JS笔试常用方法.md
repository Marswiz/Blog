---
layout: post
title: JS笔试常用方法和技巧
date: 2021-5-21
categories: blog
tags: [JavaScript]
author: Mars
pIdentifier: 中文缩进
---

> 记录笔试常用方法技巧
>

# 1. 常用方法与应用场景

## 1.1 二分查找

### 1.1.1 复杂度分析

时间复杂度： **O(logN)**，N为原数组长度。

空间复杂度： **O(1)** 

### 1.1.2 适用情况

应用二分查找的必要条件是：

- ①顺序存储：数组结构；
- ②通过任意一个下标获取子元素，可以缩小结果范围（一般数组需有序排列）。

一般适用于：**按序排列，且无重复元素**的数据搜索。

### 1.1.3 代码实现

二分查找实现的两种方式：1.迭代 2.递归。
```js
// 递归实现数组nums中查找一个元素target。
var search = function(nums,target) {
    function find(left, right){
        if(left <= right){
            let mid = Math.floor((left+right)/2);
            if(nums[mid] > target) return find(left, mid-1);
            else if(nums[mid] < target) return find(mid+1, right);
            else return mid;
        }
        return -1;
    }
    return find(0,nums.length-1);
};

// 迭代实现
var search = function(nums,target) {
    let left = 0, right = nums.length-1;
    while(left <= right){
        let mid = Math.floor((left+right)/2);
        if(nums[mid] > target) right = mid-1;
        else if(nums[mid] < target) left = mid+1;
        else return mid;
    }
    return -1;
};
```
### 1.1.4 需注意事项

1. 二分查找的边界条件是`left<=right`，也就是区间左右指针left和right在查找完毕后会交叉(left=right+1)。因此，如果需要在查找完成后使用left或right作为索引获取数组元素，需要考虑数组索引越界的情况：
> 当数组全部元素都大于目标值target，最终left=0, right=-1；
>
> 当数组全部元素都小于目标值target，最终left=arr.length-1, right=arr.length；
>
> right只可能在左边界越界，left只可能在右边界越界。

# 1.2 滑动窗口

适用于：寻找**空间连续**的特定组合。

基本思路：

1. 通过左右边界维护一个窗口：left,right;
2. 右边界负责向右扩展窗口，每次探索到一个符合条件的窗口值就停止扩展；
3. 收缩左边界，优化当前窗口值，直到不符合要求；
4. 继续向右扩展右边界，重复1-3步骤，直到右边界到达末尾。

# 1.3 构造哈希表

适用于：**快速判断一个值是否出现在集合中**。

缺点是空间复杂度高，是以空间换时间的方法。

三种哈希结构：**数组、Set、Map**

# 1.4 构建堆（优先级队列）

适用于：获取一个集合中，某一属性的前N名元素集合。

> 例如： 获取一个数组中出现次数最高的前N个元素。

为集合元素构建堆（大顶堆、小顶堆），可以通过堆排序，方便获取某一属性优先的前N个元素。

# 1.5 二叉树相关

# 1.6 动态规划（Dynamic Programming）

# 1.6.1 背包（零钱）问题

> LeetCode问题：[零钱问题2](https://leetcode-cn.com/problems/coin-change-2/)

给出零钱和目标值，求组成目标值的方法数。（比如由1,2,5组成10元有几种方法）

这里存在一个for循环先后顺序导致的，排列数和组合数的问题。

> **详细说明：**
>
> 动态规划解题，可以想到将钱数amount和钞票面值note联系起来: 组成一个目标值amount的方法数，等于所有钞票面值note对应的amount-note的方法数加在一起。`dp[amount] = sum( dp[amount-note] )`
>
> 比如： 如果给出钞票`[3,10]`，那么组成目标钱数20的方法数，应该等于组成20-3=17和20-10=10的方法数之和。因为组成17的每一个方法，再加上一张3元的钞票，就都可以组成目标值20，另一个例子同理。
>
> 可以用两层for循环分别遍历amount数组和notes数组，动态更新amount数组的值： `amount[i] += amount[i-note]`。
>
> 但是这里存在一个遍历顺序问题：
>
> - **① 如果先遍历amount，后遍历notes，则意味着：对于每个目标值，都直接穷举所有当前可能的钞票组合，之后再进入下一个目标值进行更新。**
>
> - **② 如果先遍历notes，后遍历amount，则意味着：对于每个钞票note，先计算并更新单独由这个note组成各个目标值的方法数，然后再进入下一个面额note，再更新这个新面额和之前所有面额组成的方法数。**
>
> 对于情况①，计算出来的是所有的排列数。对于情况②，计算出来的是组合数。
>
> 本题不同排列同一组合，视为同一个方法，因此应该使用第二个遍历方式。
>

# 1.6.2 股票买卖

> [股票买卖](https://www.algoexpert.io/questions/Max%20Profit%20With%20K%20Transactions)
>
> 给你一个每日股票价格组成的数组prices（索引是日期，值是价格），和一个可交易次数k。编写返回可实现的最大收益的函数。
> 
> 股票同时期最多只能持有一份，一次也只能交易一份。也就是如果持有，必须先卖出才能再买入。

**思路分析：**

1. 一天可以有三种选择：买入、卖出、不操作；
2. 只有卖出才能获得收益；
3. 卖出必须先买入；
4. 如果不操作，则总收益和之前一天的收益相同。

基于以上四点，可以得出下面的算法：

> 对于某一天，只关注卖出操作。我们可以选择**卖出**或**不卖出**。
> 
> - 如果卖出， 则之前必定有一天进行了买入。此次交易赚取收益为`price[sell]-price[buy]`；
> - 如果不卖出，则总收益与前一天收益相同；
> 
> 设置一个矩阵，每一行代表最大可交易次数k，每一列代表交易日期day。每一个元素代表最大交易次数为k时，当前日期所能达到的最大收益。
>
> 则有如下关系： 
>
> ![股票买卖](/assets/posts/20.png)

```js
function maxProfitWithKTransactions(prices, k) {

	if(prices.length < 2) return 0;
	
	let dp = new Array(2);
	dp[0] = new Array(prices.length) .fill(0);
	dp[1] = new Array(prices.length);
	let trans = 1;
	while(trans <= k){
		for(let i=0; i<prices.length; i++){
			if(i === 0) dp[1][i] = 0;
			else {
				let notSellMaxProfit = dp[1][i-1];
				let sellMaxProfit = -Infinity;
				for(let buyDay=i-1; buyDay>=0; buyDay--){
					sellMaxProfit = Math.max(sellMaxProfit, prices[i]-prices[buyDay]+dp[0][buyDay]);
				}
				dp[1][i] = Math.max(notSellMaxProfit, sellMaxProfit);
			}
		}
		dp[0] = dp[1];
		dp[1] = new Array(prices.length);
		trans++;
	}
	return dp[0][prices.length-1];
}
```

# 1.7 递归（Recursion）

# 1.7.1 特点和基本思想

递归通过在函数内调用自身实现。递归在内存中是通过函数调用栈来实现的，每次调用函数在调用栈中压入函数，函数执行完毕后弹出，恢复上层函数的执行环境。

因为这个原因，递归在内存中需要占用空间，空间复杂度较高。（占用空间与函数的最大调用次数n正相关。）

**递归的注意事项：**

- 设置合理的退出条件；
- 递归深度影响空间复杂度，能用迭代实现尽量不用递归。

# 1.7.2 复杂度分析

# 1.7.3 典型问题

> [生成DIV标签](https://www.algoexpert.io/questions/Generate%20Div%20Tags)

思路： 递归实现。

1. 控制可用的开始和结束标签数目，当开始标签可用数>0时，向后面添加一个开始标签；
2. 然后检查结束标签可用数，如果发现结束标签可用数大于开始标签可用数，说明有开始标签没有被正确关闭，此时向字符串后添加一个结束标签；
3. 当开始标签和结束标签可用数都为0，则向结果数组中保存结果。

```js
function generateDivTags(numberOfTags) {
	let res = [];
	function getStrings(prefix, openings, closings, result){
		if(openings > 0){
			let newPrefix = prefix + '<div>';
			getStrings(newPrefix, openings-1, closings, result);
		}
		if(closings > openings){
			let newPrefix = prefix + '</div>';
			getStrings(newPrefix, openings, closings-1, result);
		}
		if(openings === 0 && closings === 0){
			result.push(prefix);
		}
	}
	getStrings('', numberOfTags, numberOfTags, res);
  return res;
}
```

# 2. 常用操作

# 2.1 数组操作

## 2.1.1 数组中随机取一个元素

```js
let randPos = Math.floor( Math.random() * arr.length )
let res = arr[randPos]
```

# 2.1.2 数组中删除一个元素

```js
arr.splice(position, 1)
```

# 2.1.3 数组中动态删除元素，考虑从右到左遍历

从右到左遍历，指针左侧的元素不会被动态修改，指针右侧的元素删除不影响指针的下一位置。

# 2.1.4 浅拷贝数组

```js
Array.from(arr)
```

# 2.1.5 数组sort排序

```js
// 字符串升序
arr.sort()
// 字符串降序
arr.sort().reverse()
// 数字升序
arr.sort( (a,b) => a-b )
// 数字降序
arr.sort( (a,b) => b-a )
```

# 2.2. 判断变量类型

```js
// 精确返回变量类型，首字母大写
Object.prototype.toString.call(arg).slice(8,-1)
```

# 2.3. 链表操作

# 2.3.1 链表的前序、后序遍历

```js
function iterate(nodeHead){
    while (nodeHead.next){
        // 这里写处理逻辑就是前序遍历：正序
        iterate(nodeHead.next)
        // 这里写处理逻辑就是后序遍历：倒序
    }
}
```

# 2.4. 数值操作

# 2.4.1 辗转相除找最大公约数

```js
    function findGCD(num1,num2){
        let remainder,divider
        if (num1 >= num2){
            remainder = num1 % num2
            divider = num2
        } else {
            remainder = num2 % num1
            divider = num1
        }
        while (remainder !== 0){
            let temp = remainder
            remainder = divider % remainder
            divider = temp
        }
        return divider
    }
```

# 2.4.2 找两数最小公倍数

```js
let LCM = num1 * num2 / findGCD(num1,num2)
```

# 2.4.3 ABC集合的合集元素数目

`|A∪B∪C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|`

# 2.4.4 合并区间

对于一系列闭区间组成的数组arr：`[[l1,r1],[l2,r2],[l3,r3]...[ln,rn]]`，它们之间可能无序，也可能存在嵌套，合并它们的策略是：

2.1. 先按起始位置`l1,l2,l2.3...`对区间进行升序排序；
2.2. 声明一个数组`edges = [l1]`用来储存：**合并后区间的左右边界位置**（每个位置是此时是独立的，而不是两两成组）;
2.3. 从左到右遍历这个区间数组（索引index从0到n-2），对每个区间`[l1,r1]`和它下一个区间`[l2,r2]`，判断`l2 <= r1`：
    - 如果为false，则说明二者之间存在间隙，那么r1和l2一定都是合并后区间的边界，将他们push到edges数组；
    - 如果为true，则说明二者之间相连或相交，r1和l2一定不是合并后的区间边界，此时什么都不用做；
2.4. 直到遍历结束，此时index位于arr倒数第二个元素（i=arr.length-2），并且所有合并后内部区间边界已经被加入到edges数组，只剩最后一个区间的末尾边界rn没有被加入。此时将其加入。（`edges.push(arr[i+1][1])`）
2.5. 所有区间合并完毕，edges内元素一定为偶数，从前到后两两配对即可。（每对前一元素为合并后区间左边界，后一元素为右边界。）

图示如下：

![合并区间](/assets/posts/12.7.png)
