---
layout: post
title: JS执行环境与作用域
date: 2021-8-27
categories: blog
tags: [JavaScript]
author: Mars
pIdentifier: 中文缩进
---

> JS函数词法环境和作用域问题，还有var和let的区别问题。
>
> [执行环境 Execution Context](#1-执行环境-execution-context)
> 
> [作用域 Scope、作用域链、闭包](#2-作用域-scope作用域链闭包)
>
> [上下文 Context](#3-上下文-context)
> 
> [var和let的区别](#二var和let的区别)

# 一、执行环境(Execution Context)、作用域(Scope)、闭包(Closure)、作用域链和上下文(Context)

## 1. **执行环境 Execution Context**

执行环境，也叫执行上下文，是JavaScript在运行时，用于控制程序执行流程的一种手段。

执行环境记录了当前执行流条件下，可访问**的变量空间、访问顺序（作用域链）**和**上下文（this指向）**。

只有以下三种情况会**创建新的执行环境**：

- **程序开始运行时，创建全局执行环境Global；**
- **函数开始被执行时，会创建自己的执行环境，也叫本地执行环境；**
- 使用`eval()`函数，也会创建自己的执行环境。（比较少用，不建议使用）

每个执行环境中，都存在一个**变量对象VO（或活动对象AO）**，它的内部属性包含三部分：

- 当前执行环境内部的变量`(local variables)`；
- 当前执行环境的this属性指向；
- 执行环境栈中，外部执行环境的引用`(作用域链)`。

因此，**在当前执行环境下声明、修改变量，实际上是在修改当前执行环境下（或通过作用域链找到的上级执行环境内）VO对象的属性值。**

> 作用域、上下文概念，都通过执行环境下的VO对象来实现：
> 
> 函数执行环境新建时，引用函数内部的`[[Scope]]`属性所记载的作用域链，然后将当前环境放在它的最前方，拼接在一起作为当前执行环境的作用域链。
>
> 上下文，通过变量对象VO的`this`属性记录。

JS引擎会把内存分为**栈内存**和**堆内存**。其中：

- **栈内存**：包含**全局作用域**和**函数执行环境栈**。
- **堆内存**：存放引用类型数据本体。栈内存中如果有变量引用了堆内存中的引用类型数据（比如对象），在栈内存中实际上是保存了这个对象的内存地址。

执行环境在内存中以栈的形式存储：

**JS执行流每进入一个函数，就创建一个新的执行环境，将其压入函数执行环境栈顶部。函数执行完毕，再将执行环境弹出，恢复上层执行环境继续执行。**

![执行环境栈](/assets/posts/28.png)

## 2. **作用域 Scope、作用域链、闭包**

作用域是针对**变量访问**这一操作而言的，它是一个**变量集合**，如果一个作用域在当前执行环境的作用域链上，那么该作用域中的变量都可以沿着作用域链被访问（前提是不与作用域链前方的其他作用域中变量重名）。

JS中存在四种作用域：

- 全局作用域Global：JS程序开始执行就生成的初始作用域;
- 函数作用域Closure：函数内部生成的作用域；
- 块级作用域Block：使用`{}`括起来的部分，如果不是函数，形成的作用域是块级作用域；
- 模块作用域Module：使用ES6模块引入的变量汇总在一起，单独存在于一个作用域中。

作用域链通过**函数声明时内部记载的`[[Scopes]]`内部属性（一个栈）**，和**函数执行环境中的作用域链**来实现，它的原理是：

1. JS程序执行过程中，如果遇见**函数声明**或**函数表达式**：
    - 如果当前执行环境是全局：则函数的`[[Scopes]]`内部属性被设置为只有Global；
    - 否则，新声明的函数可能存在对其他函数作用域内变量的引用：
        1. 对新创建的函数内部进行静态词法分析，找到它引用的外部作用域变量；
        2. 除最末端全局作用域外，对当前执行环境作用域链内其他作用域中变量进行一轮筛选，只保留被新声明函数引用的变量；
        3. 将筛选后的被引用外部变量，按各自作用域分组，分别组成新的对象叫做闭包Closure（保持原链中的位置关系），放入堆内存中；
        4. 将闭包按原作用域链顺序（堆栈顺序），组成新的作用域链，保存在新声明函数的内部`[[Scopes]]`属性中。
2. 当声明的函数fn被执行：
    1. 创建新的函数执行环境，包含新的活动对象AO；
    2. 将函数fn的内部`[[Scopes]]`属性值取出，作为初始作用域链Scope；
    3. 将函数执行环境的AO对象放在Scope的最前面，然后将它设为当前执行环境的作用域链；
    4. 将当前函数执行环境，压入函数执行栈，继续执行。


### 2.1 块级作用域

一对花括号会创建一个块级作用域。if{}、for(){}、while(){}和普通的{}都会创建块级作用域。

for{}和while{}循环，相当于多次执行了块级作用域创建，并在新的块作用域内修改变量。

函数内部是函数作用域，全局环境是全局作用域。

### 2.1.1 for、while循环内声明函数

for{}和while{}循环，相当于多次创建了块级作用域。如果使用let声明变量，每次是在新的块作用域内声明、修改变量。

因此每一个在for、while循环内声明的函数，都通过\[\[Scopes\]\]记录下当前的外部作用域，也就是不同的块级作用域，因此当它们在执行的时候，引用的也是不同的块级作用域内的不同变量。这也就解释了如下的代码：

```js
for (let i = 0; i < 10; i++){
  setTimeout(() => {
    console.log(i)
  })
}

// 0,1,2,3,4,5,6,7,8,9
// let声明的i，绑定在块级作用域内，相当于有如下块级作用域{i:0}、{i:1}、{i:2}、{i:3}...
// setTimeout内部声明的箭头函数的[[Scopes]]，记录了每次迭代时产生的外部的块级作用域里的i。
// 当后续这个箭头函数按序执行的时候，创建函数执行环境，作用域链引用的是创建时[[Scopes]]记录的各自外部块级作用域，因此log的是每个块级作用域下的不同i，也就是0-9
```

## 3. **上下文 Context**

对于当前执行环境，它的**上下文**，指的是**当前执行环境中变量对象VO的this属性值**

# 二、var和let的区别

## 1. 是否有块级作用域

var只能存在于函数作用域和全局作用域，没有块级作用域。在块级作用域内部声明的var，会穿透块级作用域泄漏到外部。

let可以有块级作用域，块级作用域内部用let声明的变量，只能在块内部访问，外部无法访问。

## 2. 变量提升、暂时性死区

var声明的变量，声明会被提升到块级作用域的头部，而赋值还是在本地。

```js
// other js code..

var a = 2;
```

其实是发生了下面的事情：

```js
var a;  //此时a是undefined.
// other js code..

a = 2;
```

因此Var声明的变量可以提前使用，只是此时为undefined。

而let声明的变量，在当前代码块开始位置直到let声明之前区域，叫做暂时性死区，不可访问，否则报错。

## 3. var可以重复声明

var可以重复声明同名的变量，后面的覆盖前面的。而let不可以（报错）。
